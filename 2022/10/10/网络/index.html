<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>计算机网络 |  LPL&#39;s Blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-网络"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  计算机网络
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/10/10/%E7%BD%91%E7%BB%9C/" class="article-date">
  <time datetime="2022-10-10T01:52:45.000Z" itemprop="datePublished">2022-10-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%85%AB%E8%82%A1%E6%96%87/">八股文</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">22.1k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">78 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="1-OSI七层模型"><a href="#1-OSI七层模型" class="headerlink" title="1.OSI七层模型"></a>1.OSI七层模型</h2><img src="/2022/10/10/%E7%BD%91%E7%BB%9C/image-20220805130408268.png" class="">

<span id="more"></span>

<img src="/2022/10/10/%E7%BD%91%E7%BB%9C/image-20220805130455502.png" class="">

<h2 id="2-TCP-x2F-IP四层模型"><a href="#2-TCP-x2F-IP四层模型" class="headerlink" title="2.TCP&#x2F;IP四层模型"></a>2.TCP&#x2F;IP四层模型</h2><img src="/2022/10/10/%E7%BD%91%E7%BB%9C/TCP-IP-4-model.a534f46f.png" class="">

<h2 id="3-TCP和UDP"><a href="#3-TCP和UDP" class="headerlink" title="3.TCP和UDP"></a>3.TCP和UDP</h2><p>TCP和UDP都是全双工通信，三次握手类似于半双工。</p>
<p>TCP三个特点：<strong>面向连接</strong>、<strong>可靠</strong>、基于<strong>字节流</strong></p>
<h3 id="1-1-三次握手"><a href="#1-1-三次握手" class="headerlink" title="1.1 三次握手"></a>1.1 三次握手</h3><p>三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。</p>
<p>刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。</p>
<p>进行三次握手：</p>
<p>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN。此时客户端处于 SYN_SEND 状态。</p>
<p>首部的同步位SYN&#x3D;1，初始序号seq&#x3D;x，SYN&#x3D;1的报文段不能携带数据，但要消耗掉一个序号。</p>
<p>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。</p>
<p>在确认报文段中SYN&#x3D;1，ACK&#x3D;1，确认号ack&#x3D;x+1，初始序号seq&#x3D;y。</p>
<p>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。</p>
<p>确认报文段ACK&#x3D;1，确认号ack&#x3D;y+1，序号seq&#x3D;x+1（初始为seq&#x3D;x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。</p>
<p>发送第一个SYN的一端将执行主动打开（active open），接收这个SYN并发回下一个SYN的另一端执行被动打开（passive open）。</p>
<p>在socket编程中，客户端执行connect()时，将触发三次握手。</p>
<img src="/2022/10/10/%E7%BD%91%E7%BB%9C/v2-2a54823bd63e16674874aa46a67c6c72_720w.jpg" class="">

<h4 id="1-1-为什么需要三次握手，两次不行吗？"><a href="#1-1-为什么需要三次握手，两次不行吗？" class="headerlink" title="1.1 为什么需要三次握手，两次不行吗？"></a><strong>1.1 为什么需要三次握手，两次不行吗？</strong></h4><p>弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。</p>
<p>第一次握手：客户端发送网络包，服务端收到了。</p>
<p>这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p>
<p>第二次握手：服务端发包，客户端收到了。</p>
<p>这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</p>
<p>第三次握手：客户端发包，服务端收到了。</p>
<p>这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</p>
<p>因此，需要三次握手才能确认双方的接收与发送能力是否正常。</p>
<p>试想如果是用两次握手，则会出现下面这种情况：</p>
<blockquote>
<p>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</p>
</blockquote>
<h4 id="1-2-什么是半连接队列？"><a href="#1-2-什么是半连接队列？" class="headerlink" title="1.2 什么是半连接队列？"></a><strong>1.2 什么是半连接队列？</strong></h4><p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。</p>
<p>当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p>
<p>这里在补充一点关于SYN-ACK 重传次数的问题：</p>
<p>服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。</p>
<p>注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…</p>
<h4 id="1-3-ISN-Initial-Sequence-Number-是固定的吗？"><a href="#1-3-ISN-Initial-Sequence-Number-是固定的吗？" class="headerlink" title="1.3 ISN(Initial Sequence Number)是固定的吗？"></a><strong>1.3 ISN(Initial Sequence Number)是固定的吗？</strong></h4><p>当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN随时间而变化，因此每个连接都将具有不同的ISN。ISN可以看作是一个32比特的计数器，每4ms加1 。这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。</p>
<p>三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。</p>
<h4 id="1-4-三次握手过程中可以携带数据吗？"><a href="#1-4-三次握手过程中可以携带数据吗？" class="headerlink" title="1.4 三次握手过程中可以携带数据吗？"></a><strong>1.4 三次握手过程中可以携带数据吗？</strong></h4><p>其实第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手不可以携带数据</p>
<p>为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。</p>
<p>也就是说，第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。</p>
<h4 id="1-5-SYN攻击是什么？"><a href="#1-5-SYN攻击是什么？" class="headerlink" title="1.5 SYN攻击是什么？"></a><strong>1.5 SYN攻击是什么？</strong></h4><p>服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS&#x2F;DDoS 攻击。</p>
<p>检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux&#x2F;Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -n -p TCP | grep SYN_RECV</span><br></pre></td></tr></table></figure>

<p>常见的防御 SYN 攻击的方法有如下几种：</p>
<ul>
<li>缩短超时（SYN Timeout）时间</li>
<li>增加最大半连接数</li>
<li>过滤网关防护</li>
<li>SYN cookies技术</li>
</ul>
<h3 id="1-2-四次挥手"><a href="#1-2-四次挥手" class="headerlink" title="1.2 四次挥手"></a>1.2 四次挥手</h3><p>建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p>
<p>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作。</p>
<p>刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：</p>
<p><strong>第一次挥手</strong>：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。</p>
<p>即发出连接释放报文段（FIN&#x3D;1，序号seq&#x3D;u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。</p>
<p><strong>第二次挥手</strong>：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。</p>
<p>即服务端收到连接释放报文段后即发出确认报文段（ACK&#x3D;1，确认号ack&#x3D;u+1，序号seq&#x3D;v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。</p>
<p><strong>第三次挥手</strong>：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。</p>
<p>即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN&#x3D;1，ACK&#x3D;1，序号seq&#x3D;w，确认号ack&#x3D;u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。</p>
<p><strong>第四次挥手</strong>：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</p>
<p>即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK&#x3D;1，seq&#x3D;u+1，ack&#x3D;w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。</p>
<p>收到一个FIN只意味着在这一方向上没有数据流动。客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。</p>
<p>在socket编程中，任何一方执行close()操作即可产生挥手操作。</p>
<img src="/2022/10/10/%E7%BD%91%E7%BB%9C/v2-c7d4b5aca66560365593f57385ce9fa9_720w.jpg" class="">

<h4 id="1-2-1-挥手为什么需要四次？"><a href="#1-2-1-挥手为什么需要四次？" class="headerlink" title="1.2.1 挥手为什么需要四次？"></a><strong>1.2.1 挥手为什么需要四次？</strong></h4><p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。</p>
<h4 id="1-2-2-2MSL等待状态"><a href="#1-2-2-2MSL等待状态" class="headerlink" title="1.2.2 2MSL等待状态"></a><strong>1.2.2 2MSL等待状态</strong></h4><p>TIME_WAIT状态也成为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。</p>
<p>对一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）。</p>
<p>这种2MSL等待的另一个结果是这个TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。这个连接只能在2MSL结束后才能再被使用。</p>
<h4 id="1-2-3-四次挥手释放连接时，等待2MSL的意义"><a href="#1-2-3-四次挥手释放连接时，等待2MSL的意义" class="headerlink" title="1.2.3 四次挥手释放连接时，等待2MSL的意义?"></a><strong>1.2.3 四次挥手释放连接时，等待2MSL的意义?</strong></h4><p>MSL是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p>
<p>为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。</p>
<p>两个理由：</p>
<ul>
<li>保证客户端发送的最后一个ACK报文段能够到达服务端。</li>
</ul>
<p>这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。</p>
<ul>
<li>防止“已失效的连接请求报文段”出现在本连接中。</li>
</ul>
<p>客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。</p>
<h4 id="1-2-4-为什么TIME-WAIT状态需要经过2MSL才能返回到CLOSE状态？"><a href="#1-2-4-为什么TIME-WAIT状态需要经过2MSL才能返回到CLOSE状态？" class="headerlink" title="1.2.4 为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？"></a><strong>1.2.4 为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？</strong></h4><p>理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但是可能网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</p>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>《TCP&#x2F;IP详解 卷1:协议》有一张TCP状态变迁图，很具有代表性，有助于大家理解三次握手和四次挥手的状态变化。如下图所示，粗的实线箭头表示正常的客户端状态变迁，粗的虚线箭头表示正常的服务器状态变迁。</p>
<img src="/2022/10/10/%E7%BD%91%E7%BB%9C/v2-7c402fde8210519feb8f65d41410c205_720w.jpg" class="">

<h3 id="1-3-TCP和UDP的区别？"><a href="#1-3-TCP和UDP的区别？" class="headerlink" title="1.3. TCP和UDP的区别？"></a>1.3. TCP和UDP的区别？</h3>

<p>应用场景：TCP 用于在传输层有必要实现可靠传输的情况，UDP 用于对高速传输和实时性有较高要求的通信。TCP和 UDP 应该根据应用目的按需使用。</p>


<h3 id="1-4-TCP-协议如何保证可靠传输"><a href="#1-4-TCP-协议如何保证可靠传输" class="headerlink" title="1.4 TCP 协议如何保证可靠传输"></a>1.4 <strong>TCP 协议如何保证可靠传输</strong></h3><ol>
<li>应用数据被<strong>分割</strong>成TCP认为最适合发送的数据块。</li>
<li>TCP 给发送的每一个包进行<strong>编号</strong>，接收方对数据包进行排序，把<strong>有序</strong>数据传送给应用层。</li>
<li><strong>校验和：</strong> TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li>TCP 的接收端会丢弃重复的数据。</li>
<li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li>
<li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。慢开始、快恢复、快重传、拥塞避免</li>
<li><strong>ARQ 协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>
</ol>
<h3 id="1-5-ARQ-协议"><a href="#1-5-ARQ-协议" class="headerlink" title="1.5 ARQ 协议"></a>1.5 <strong>ARQ 协议</strong></h3><p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是 OSI 模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ 包括停止等待 ARQ 协议和连续 ARQ 协议。</p>
<h4 id="停止等待-ARQ-协议"><a href="#停止等待-ARQ-协议" class="headerlink" title="停止等待 ARQ 协议"></a><strong>停止等待 ARQ 协议</strong></h4><p>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复 ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组。</p>
<p>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。</p>
<p><strong>优缺点：</strong></p>
<ul>
<li><strong>优点：</strong> 简单</li>
<li><strong>缺点：</strong> 信道利用率低，等待时间长</li>
</ul>
<p><strong>1) 无差错情况:</strong></p>
<p>发送方发送分组, 接收方在规定时间内收到, 并且回复确认. 发送方再次发送。</p>
<p><strong>2) 出现差错情况（超时重传）:</strong></p>
<p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 <strong>自动重传请求 ARQ</strong> 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。<strong>连续 ARQ 协议</strong> 可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p>
<p><strong>3) 确认丢失和确认迟到</strong></p>
<ul>
<li><strong>确认丢失</strong> ：确认消息在传输过程丢失。当 A 发送 M1 消息，B 收到后，B 向 A 发送了一个 M1 确认消息，但却在传输过程中丢失。而 A 并不知道，在超时计时过后，A 重传 M1 消息，B 再次收到该消息后采取以下两点措施：1. 丢弃这个重复的 M1 消息，不向上层交付。 2. 向 A 发送确认消息。（不会认为已经发送过了，就不再发送。A 能重传，就证明 B 的确认消息丢失）。</li>
<li><strong>确认迟到</strong> ：确认消息在传输过程中迟到。A 发送 M1 消息，B 收到并发送确认。在超时时间内没有收到确认消息，A 重传 M1 消息，B 仍然收到并继续发送确认消息（B 收到了 2 份 M1）。此时 A 收到了 B 第二次发送的确认消息。接着发送其他数据。过了一会，A 收到了 B 第一次发送的对 M1 的确认消息（A 也收到了 2 份确认消息）。处理如下：1. A 收到重复的确认后，直接丢弃。2. B 收到重复的 M1 后，也直接丢弃重复的 M1。</li>
</ul>
<h4 id="连续-ARQ-协议"><a href="#连续-ARQ-协议" class="headerlink" title="连续 ARQ 协议"></a><strong>连续 ARQ 协议</strong></h4><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p>
<p><strong>优缺点：</strong></p>
<ul>
<li><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</li>
<li><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5 条 消息，中间第三条丢失（3 号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</li>
</ul>
<h3 id="1-6-滑动窗口和流量控制"><a href="#1-6-滑动窗口和流量控制" class="headerlink" title="1.6 滑动窗口和流量控制"></a>1.6 <strong>滑动窗口和流量控制</strong></h3><p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong> 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<h3 id="1-7拥塞控制"><a href="#1-7拥塞控制" class="headerlink" title="1.7拥塞控制"></a><strong>1.7拥塞控制</strong></h3><p><strong>基本概念</strong></p>
<p>​	拥塞：即对资源的需求超过了可用的资源。若网络中许多资源同时供应不足，网络的性能就要明显变坏，整个网络的吞吐量随之负荷的增大而下降。</p>
<p>  拥塞控制：<strong>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。</strong>拥塞控制所要做的都有一个<strong>前提：网络能够承受现有的网络负荷。</strong>拥塞控制是一个<strong>全局性的过程</strong>，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。</p>
<p>  流量控制：指点对点通信量的控制，是端到端正的问题。流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>
<p>  拥塞控制代价：需要获得网络内部流量分布的信息。在实施拥塞控制之前，还需要在结点之间交换信息和各种命令，以便选择控制的策略和实施控制。这样就产生了额外的开销。拥塞控制还需要将一些资源分配给各个用户单独使用，使得网络资源不能更好地实现共享。</p>
<h4 id="1几种拥塞控制方法"><a href="#1几种拥塞控制方法" class="headerlink" title="1几种拥塞控制方法"></a>1几种拥塞控制方法</h4><p>  慢开始( slow-start )、拥塞避免( congestion avoidance )、快重传( fast retransmit )和快恢复( fast recovery )。</p>
<h4 id="2慢开始和拥塞避免"><a href="#2慢开始和拥塞避免" class="headerlink" title="2慢开始和拥塞避免"></a>2慢开始和拥塞避免</h4><p>  发送方维持一个<strong>拥塞窗口 cwnd</strong> ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞。</p>
<p>  发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</p>
<h5 id="2-1慢开始算法："><a href="#2-1慢开始算法：" class="headerlink" title="2.1慢开始算法："></a>2.1<strong>慢开始算法</strong>：</h5><p>当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。因此，较好的方法是 先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS（MSS&#x3D;MTU-20字节TCP报头-20字节IP报头，MSS值一般就是1500-20-20&#x3D;1460字节）的数值。而在每收到一个对新的报文段的确认后，把<strong>拥塞窗口加倍</strong>。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。</p>
<img src="/2022/10/10/%E7%BD%91%E7%BB%9C/2010101120451114.jpg" class="">

<p>每经过一个传输轮次，拥塞窗口 cwnd 就加倍。一个传输轮次所经历的时间其实就是往返时间RTT。不过“传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。</p>
<p>另，慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd&#x3D;1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。</p>
<h5 id="2-2慢开始门限ssthresh"><a href="#2-2慢开始门限ssthresh" class="headerlink" title="2.2慢开始门限ssthresh"></a>2.2慢开始门限ssthresh</h5><p> 为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态<strong>变量</strong>（如何设置ssthresh）。慢开始门限ssthresh的用法如下：</p>
<p>  当 cwnd &lt; ssthresh 时，使用上述的慢开始算法。</p>
<p>  当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</p>
<p>  当 cwnd &#x3D; ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。</p>
<h5 id="2-3拥塞避免算法："><a href="#2-3拥塞避免算法：" class="headerlink" title="2.3拥塞避免算法："></a><strong>2.3拥塞避免算法</strong>：</h5><p>让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的<strong>拥塞窗口cwnd加1</strong>，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</p>
<p>  无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把<strong>慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半</strong>（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。</p>
<p>  如下图，用具体数值说明了上述拥塞控制的过程。现在发送窗口的大小和拥塞窗口一样大。</p>
<img src="/2022/10/10/%E7%BD%91%E7%BB%9C/2010101120591634.jpg" class="">

<p>&lt;1&gt;. 当TCP连接进行初始化时，把拥塞窗口cwnd置为1。前面已说过，为了便于理解，图中的窗口单位不使用字节而使用报文段的个数。慢开始门限的初始值设置为16个报文段，即 cwnd &#x3D; 16 。</p>
<p>&lt;2&gt;. 在执行慢开始算法时，拥塞窗口 cwnd 的初始值为1。以后发送方每收到一个对新报文段的确认ACK，就把拥塞窗口值另1，然后开始下一轮的传输（图中横坐标为传输轮次）。因此拥塞窗口cwnd 随着传输轮次按指数规律增长。当拥塞窗口cwnd增长到慢开始门限值ssthresh时（即当cwnd&#x3D;16时），就改为执行拥塞控制算法，拥塞窗口按线 性规律增长。</p>
<p>&lt;3&gt;. 假定拥塞窗口的数值增长到24时，网络出现超时（这很可能就是网络发生拥塞了）。更新后的ssthresh值变为12（即变为出现超时时的拥塞窗口数值 24的一半），拥塞窗口再重新设置为1，并执行慢开始算法。当cwnd&#x3D;ssthresh&#x3D;12时改为执行拥塞避免算法，拥塞窗口按线性规律增长，每经过 一个往返时间增加一个MSS的大小。</p>
<p>强调：“拥塞避免”并非指完全能够避免了拥塞。利用以上的措施要完全避免网络拥塞还是不可能的。“拥塞避免”是说在拥塞避免阶段将拥塞窗口控制为按线性规律增长，<strong>使网络比较不容易出现拥塞。</strong></p>
<h4 id="3快重传和快恢复"><a href="#3快重传和快恢复" class="headerlink" title="3快重传和快恢复"></a>3快重传和快恢复</h4><p>  如果发送方设置的超时计时器时限已到但还没有收到确认，那么很可能是网络出现了拥塞，致使报文段在网络中的某处被丢弃。这时，TCP马上把拥塞窗口 cwnd 减小到1，并执行慢开始算法，同时把慢开始门限值ssthresh减半。这是不使用快重传的情况。</p>
<h5 id="3-1快重传算法："><a href="#3-1快重传算法：" class="headerlink" title="3.1快重传算法："></a>3.1快重传算法：</h5><p>首先要求接收方<strong>每收到一个失序的报文段后就立即发出重复确认</strong>（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。</p>
<img src="/2022/10/10/%E7%BD%91%E7%BB%9C/2010101122524670.jpg" class="">

<p>接收方收到了M1和M2后都分别发出了确认。现在假定接收方没有收到M3但接着收到了M4。显然，接收方不能确认M4，因为M4是收到的失序报文段。根据可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。但按照快重传算法的规定，接收方应及时发送对M2的重复确认，这样做可以让发送方及早知道报文段M3没有到达接收方。发送方接着发送了M5和M6。接收方收到这两个报文后，也还要再次发出对M2的重复确认。这样，发送方共收到了接收方的四个对M2的确认，其中后三个都是重复确认。<strong>快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待报文设置的重传计时器到期。</strong>由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。</p>
<h5 id="3-2快恢复算法："><a href="#3-2快恢复算法：" class="headerlink" title="3.2快恢复算法："></a>3.2快恢复算法：</h5><p>其过程有以下两个要点：</p>
<p>  &lt;1&gt;. 当发送方连续收到三个重复确认，就执行“乘法减小”算法，把<strong>慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半</strong>。这是为了预防网络发生拥塞。请注意：接下去不执行慢开始算法。</p>
<p>  &lt;2&gt;. 由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在<strong>不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为慢开始门限ssthresh修改后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。</strong></p>
<p>  下图给出了快重传和快恢复的示意图，并标明了“TCP Reno版本”。</p>
<p>  区别：新的 TCP Reno 版本在快重传之后采用快恢复算法而不是采用慢开始算法。</p>
<img src="/2022/10/10/%E7%BD%91%E7%BB%9C/2010101123101842.jpg" class=""> 

<p> 也有的快重传实现是把开始时的拥塞窗口cwnd值再增大一点，即等于 ssthresh + 3 X MSS 。这样做的理由是：既然发送方收到三个重复的确认，就表明有三个分组已经离开了网络。这三个分组不再消耗网 的资源而是停留在接收方的缓存中。可见现在网络中并不是堆积了分组而是减少了三个分组。因此可以适当把拥塞窗口扩大了些。</p>
<p><strong>补充</strong></p>
<p>  接收方根据自己的接收能力设定了接收窗口rwnd，并把这个窗口值写入TCP首部中的窗口字段，传送给发送方。因此，接收窗口又称为通知窗口。因此，从接收方对发送方的流量控制的角度考虑，发送方的发送窗口一定不能超过对方给出的接收窗口rwnd 。</p>
<p>  发送方窗口的上限值 &#x3D; Min [ rwnd, cwnd ]</p>
<p>  当rwnd &lt; cwnd 时，是接收方的接收能力限制发送方窗口的最大值。</p>
<p>  当cwnd &lt; rwnd 时，则是网络的拥塞限制发送方窗口的最大值。</p>
<h3 id="1-8-TCP中的缓存有什么作用？"><a href="#1-8-TCP中的缓存有什么作用？" class="headerlink" title="1.8  TCP中的缓存有什么作用？"></a>1.8  TCP中的缓存有什么作用？</h3><h4 id="TCP缓冲区是什么？"><a href="#TCP缓冲区是什么？" class="headerlink" title="TCP缓冲区是什么？"></a>TCP缓冲区是什么？</h4><p>每个 socket 被创建后，都会分配两个缓冲区，输入缓冲区和输出缓冲区。</p>
<h4 id="缓冲区的意义（作用）"><a href="#缓冲区的意义（作用）" class="headerlink" title="缓冲区的意义（作用）"></a>缓冲区的意义（作用）</h4><p> <strong>TCP的发送缓冲区是用来缓存应用程序的数据，发送缓冲区的每个字节都有序列号，被应答确认的序列号对应的数据会从发送缓冲区删除掉。</strong></p>
<img src="/2022/10/10/%E7%BD%91%E7%BB%9C/50D7F6CDDD9A36ED91D4F78DFABF1DF3.jpeg" class="">

<p>write()&#x2F;send() 并不立即向网络中传输数据，而是先将数据写入缓冲区中，再由TCP协议将数据从缓冲区发送到目标机器。</p>
<p><strong>一旦将数据写入到缓冲区，函数就可以成功返回，不管它们有没有到达目标机器</strong>，也不管它们何时被发送到网络，这些都是TCP协议负责的事情。   </p>
<p>TCP协议独立于 write()&#x2F;send() 函数，数据有可能刚被写入缓冲区就发送到网络，也可能在缓冲区中不断积压，多次写入的数据被一次性发送到网络，比如nagle算法，这取决于当时的网络情况、当前线程是否空闲等诸多因素，不由程序员控制。   </p>
<p>read()&#x2F;recv() 函数也是如此，也从输入缓冲区中读取数据，而不是直接从网络中读取。</p>
<h4 id="I-x2F-O缓冲区特性"><a href="#I-x2F-O缓冲区特性" class="headerlink" title="I&#x2F;O缓冲区特性"></a>I&#x2F;O缓冲区特性</h4><p>（1）I&#x2F;O缓冲区在每个TCP套接字中单独存在；</p>
<p>（2）I&#x2F;O缓冲区在创建套接字时自动生成；</p>
<p>（3）即使关闭套接字也会继续传送输出缓冲区中遗留的数据；</p>
<p>（4）关闭套接字将丢失输入缓冲区中的数据。</p>
<h3 id="1-9-tcp粘包、拆包的机制"><a href="#1-9-tcp粘包、拆包的机制" class="headerlink" title="1.9 tcp粘包、拆包的机制"></a>1.9 tcp粘包、拆包的机制</h3><h4 id="TCP粘包和拆包问题"><a href="#TCP粘包和拆包问题" class="headerlink" title="TCP粘包和拆包问题"></a><strong>TCP粘包和拆包问题</strong></h4><p>  TCP是一个“流”协议，所谓流，就是<strong>没有界限的一长串二进制数据</strong>。TCP作为传输层协议并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行数据包的划分，所以在业务上认为是一个完整的包，可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。</p>
<h4 id="产生TCP粘包和拆包的原因"><a href="#产生TCP粘包和拆包的原因" class="headerlink" title="产生TCP粘包和拆包的原因"></a><strong>产生TCP粘包和拆包的原因</strong></h4><p>  我们知道TCP是以流的方式传输数据的，传输的<strong>最小单位</strong>为一个报文段（Segment）。TCP Header中有个Options标识位。常见的标识位为MSS（Maximum Segment Size）指的是，连接层每次传输的数据有个最大限制MTU（Maximum Transmission Unit），一般是1500bit，超过这个量要分成多个报文段，MSS则是这个最大限制减去TCP的header，光是要传输的数据的大小，一般为1460bit。换算成字节，也就是180多字节。   TCP为提高性能，发送端会将需要发送的数据发送到缓冲区，等待缓冲区满了以后，再将缓冲中的数据发送到接收方。同理，接收方也有缓冲区这样的机制来接受数据。 发生TCP粘包、拆包主要是以下原因：   </p>
<ul>
<li>（1）应用程序写入数据大于套接字缓冲区大小，会发生拆包；   </li>
<li>（2）应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发送粘包；   </li>
<li>（3）进行MSS（最大报文长度）大小的TCP分段，当TCP报文长度——TCP header长度&gt;MSS 的时候会发生拆包；   </li>
<li>（4）接收方法不及时读取套接字缓冲区数据，这将发生粘包。</li>
</ul>
<h4 id="如何处理粘包和拆包"><a href="#如何处理粘包和拆包" class="headerlink" title="如何处理粘包和拆包"></a><strong>如何处理粘包和拆包</strong></h4><p><strong>处理拆包</strong>：http连接是短连接，请求之后，收到回答，立马断开连接，不会出现粘包。 拆包现象是有可能存在的。</p>
<p>（1）通过包头+包长+包体的协议形式，当服务器端获取到指定的包长时才说明获取完整。   </p>
<p>（2） 指定包的结束标识，这样当我们获取到指定的标识时，说明包获取完整。</p>
<pre><code> **处理粘包**：http的短连接协议不会出现粘包的现象，但是一旦建立了长连接，粘包还是有可能会发生的。
</code></pre>
<p><strong>处理粘包的方法如下：</strong></p>
<p>  （1）发送方对于发送方造成的粘包问题，可以通过关闭Nagle算法来解决，使用TCP_NODELAY选项来关闭算法。</p>
<p>  （2）接收方没有办法来处理粘包现象，只能将问题交给应用层来处理。应用层的解决办法简单可行，不仅能解决接收方的粘包问题，还可以解决发送方的粘包问题。解决办法：循环处理，应用程序从接收缓存中读取分组时，读完一条数据，就应该循环读取下一条数据，直到所有数据都被处理完成，判断每条数据的长度的方法有两种：</p>
<p>​    a. 格式化数据：每条数据有固定的格式（开始符，结束符），这种方法简单易行，但是选择开始符和结束符时一定要确保每条数据的内部不包含开始符和结束符。</p>
<p>​    b. 发送长度：发送每条数据时，将数据的长度一并发送，例如规定数据的前4位是数据的长度，应用层在处理时可以根据长度来判断每个分组的开始和结束位置。</p>
<h4 id="UDP会不会产生粘包问题呢？"><a href="#UDP会不会产生粘包问题呢？" class="headerlink" title="UDP会不会产生粘包问题呢？"></a><strong>UDP会不会产生粘包问题呢？</strong></h4><p>  TCP为了保证可靠传输并减少额外的开销（每次发包都要验证），采用了基于流的传输，基于流的传输不认为消息是一条一条的，是无保护消息边界的（保护消息边界：指传输协议把数据当做一条独立的消息在网上传输，接收端一次只能接受一条独立的消息）。UDP则是面向消息传输的，是有保护消息边界的，接收方一次只接受一条独立的信息，所以不存在粘包问题。</p>
<p>  举个例子：有三个数据包，大小分别为2k、4k、6k，如果采用UDP发送的话，不管接受方的接收缓存有多大，我们必须要进行至少三次以上的发送才能把数据包发送完，但是使用TCP协议发送的话，我们只需要接受方的接收缓存有12k的大小，就可以一次把这3个数据包全部发送完毕。</p>
<h2 id="4-长连接和短连接"><a href="#4-长连接和短连接" class="headerlink" title="4. 长连接和短连接"></a>4. 长连接和短连接</h2><p>在HTTP&#x2F;1.0中，默认使用的是<strong>短连接</strong>。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其 他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。 </p>
<p>从 HTTP&#x2F;1.1起，默认使用<strong>长连接</strong>，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码： Connection:keep-alive 在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长 连接要客户端和服务端都支持长连接。 </p>
<p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p>
<h2 id="5-如何让UDP可靠一些？"><a href="#5-如何让UDP可靠一些？" class="headerlink" title="5. 如何让UDP可靠一些？"></a>5. 如何让UDP可靠一些？</h2><ol>
<li><p><strong>为什么需要可靠的UDP</strong></p>
<p>在弱网（2G、3G、信号不好）环境下，使用 TCP 连接的延迟很高，影响体验。使用 UDP 是很好的解决方案，既然把 UDP 作为弱网里面的 TCP 来使用，就必须保证数据传输能像 TCP 一样可靠</p>
</li>
<li><p><strong>如何实现可靠的UDP</strong></p>
<p><del>UDP它不属于连接型协议，因而具有资源消耗小，处理速度快的优点，所以通常音频、视频和普通数据在传送时使用UDP较多，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</del></p>
<p>传输层无法保证数据的可靠传输，只能通过<strong>应用层</strong>来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。关键在于两点，从应用层角度考虑：</p>
<p>（1）提供超时重传，能避免数据报丢失。</p>
<p>（2）提供确认序列号，可以对数据报进行确认和排序。</p>
<p> <strong>本端</strong>：首先在UDP数据报定义一个首部，首部包含确认序列号和时间戳，时间戳是用来计算RTT(数据报传输的往返时间)，计算出合适的RTO(重传的超时时间)。然后以等-停的方式发送数据报，即收到对端的确认之后才发送下一个的数据报。当时间超时，本端重传数据报，同时RTO扩大为原来的两倍，重新开始计时。</p>
<p> <strong>对端</strong>：接受到一个数据报之后取下该数据报首部的时间戳和确认序列号，并添加本端的确认数据报首部之后发送给对端。根据此序列号对已收到的数据报进行排序并丢弃重复的数据报。</p>
</li>
</ol>
<h2 id="6-HTTP和HTTPS"><a href="#6-HTTP和HTTPS" class="headerlink" title="6. HTTP和HTTPS"></a>6. HTTP和HTTPS</h2><ul>
<li><strong>安全性和资源消耗</strong> ：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。<strong>HTTPS</strong>是运行在 SSL&#x2F;TLS 之上的 HTTP 协议，SSL&#x2F;TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</li>
<li><strong>端口号</strong> ：HTTP 默认是 80，HTTPS 默认是 443。</li>
<li><strong>URL 前缀</strong> ：HTTP 的 URL 前缀是 <code>http://</code>，HTTPS 的 URL 前缀是 <code>https://</code>。</li>
</ul>
<h3 id="HTTP和HTTPS的区别？"><a href="#HTTP和HTTPS的区别？" class="headerlink" title="HTTP和HTTPS的区别？"></a>HTTP和HTTPS的区别？</h3><p><strong>HTTP</strong></p>
<p>HTTP（Hypertext Transfer Protocol）全称是超文本传输协议，它是一个无状态协议，也就是说服务器不维护任何有关客户端过去所发请求的消息。HTTP 是<strong>应用层</strong>协议，它以 TCP（传输层）作为底层协议，默认端口为 80。HTTP扩展性强、速度快、跨平台支持性好。</p>
<p><strong>HTTPS</strong></p>
<p>HTTPS 协议（Hyper Text Transfer Protocol Secure），是 HTTP 的加强安全版本。HTTPS 是基于 HTTP 的，也是用 TCP 作为底层协议，并额外使用 SSL&#x2F;TLS 协议用作加密和安全认证。默认端口号是 443。</p>
<p>HTTPS 协议中，SSL 通道通常使用基于密钥的加密算法，密钥长度通常是 40 比特或 128 比特。HTTPS保密性好、信任度高。</p>
<h3 id="HTTP系列的区别"><a href="#HTTP系列的区别" class="headerlink" title="HTTP系列的区别"></a>HTTP系列的区别</h3><h4 id="HTTP1-0和HTTP1-1的区别"><a href="#HTTP1-0和HTTP1-1的区别" class="headerlink" title="HTTP1.0和HTTP1.1的区别?"></a>HTTP1.0和HTTP1.1的区别?</h4><p><strong>长连接</strong>：HTTP 1.1支持长连接（Persistent Connection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive ，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</p>
<p><strong>缓存处理</strong>：在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略，可供选择的缓存头来控制缓存策略。</p>
<p><strong>带宽优化及网络连接的使用</strong>：<strong>HTTP1.0</strong>中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且<strong>不支持断点续传</strong>功能，<strong>HTTP1.1</strong>则在请求头引入了range头域，它<strong>允许只请求资源的某个部分</strong>，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p>
<p><strong>错误通知的管理</strong>：在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p>
<p><strong>Host头处理</strong>：在<strong>HTTP1.0</strong>中认为每台服务器都绑定一个唯一的IP地址，因此，<strong>请求消息中的URL并没有传递主机名</strong>（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。<strong>HTTP1.1的请求消息和响应消息都应支持Host头域</strong>，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）</p>
<h4 id="HTTP1-1和-HTTP2-0的区别？"><a href="#HTTP1-1和-HTTP2-0的区别？" class="headerlink" title="HTTP1.1和 HTTP2.0的区别？"></a>HTTP1.1和 HTTP2.0的区别？</h4><p>HTTP2.0相比HTTP1.1支持的特性：</p>
<p><strong>新的二进制格式</strong>：HTTP1.1的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</p>
<p><strong>多路复用</strong>，即连接共享，即每一个request都是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</p>
<p><strong>头部压缩</strong>，HTTP1.1的头部（header）带有大量信息，而且每次都要重复发送；HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</p>
<p><strong>服务端推送</strong>：服务器除了对最初请求的响应外，服务器还可以额外的向客户端推送资源，而无需客户端明确的请求。</p>


<h3 id="HTTPS的秘钥交换过程"><a href="#HTTPS的秘钥交换过程" class="headerlink" title="HTTPS的秘钥交换过程"></a>HTTPS的秘钥交换过程</h3><p>  HTTPS的密钥交换过程如下：</p>
<ol>
<li><p>客户端要访问一个网站，向支持https的服务器发起请求。</p>
</li>
<li><p>客户端向服务器发送自己支持的秘钥交换算法列表。</p>
</li>
<li><p>服务器选取一种秘钥交换算法加上CA证书返回给客户端。</p>
</li>
<li><p>客户端验证服务器是否合法，并生成一个随机数然后用协商好的加密算法加密生成随机秘钥，并用刚才从CA证书中拿到的公钥对其加密后发送给服务器。</p>
</li>
<li><p>服务器收到后用自己的私钥解密（中间人没有服务器的私钥，所以没有办法看到传输的数据，另外确认秘钥交换算法是在第一步，中间人是不知道秘钥交换算法（中间人是无法在第一步做手脚的，那等同于它自己就是一个真实客户端发起了一个新的请求，唯一一种情况攻击人有一个合法CA下发的证书，且客户端（一般为安卓设备）没有对CA下发的证书中的内容网站地址和当前请求地址做对比校验），就算攻击者有公钥，因为不知道协商协议，所以做不出来随机秘钥，顶多就是在传输过程中将报文拦截下来，乱改，但是给到服务器后，私钥是解不开乱改之后的密文的）。</p>
</li>
<li><p>服务器私钥解密之后，拿到对称秘钥，并且用它再加密一个信息，返回给浏览器。</p>
<p><strong>注意：</strong>最关键的一步就是在客户端采用 <strong>RSA</strong> 或 Diffie-Hellman 等加密算法生成 Pre-master，这个随机秘钥是用来计算最终的对称秘钥的，用公钥加密之后攻击人是不知道这个这个随机秘钥的，只有服务器才能解的开。</p>
</li>
</ol>
<h3 id="为什么HTTPS用到了非对称-x2F-对称加密两种"><a href="#为什么HTTPS用到了非对称-x2F-对称加密两种" class="headerlink" title="为什么HTTPS用到了非对称&#x2F;对称加密两种"></a>为什么HTTPS用到了非对称&#x2F;对称加密两种</h3><ul>
<li><p>第一阶段的<strong>非对称加密</strong>，保证了对称密钥的<strong>安全</strong>性；</p>
</li>
<li><p>第二阶段的<strong>对称加密</strong>，可以提高加密&#x2F;解密处理的<strong>速度</strong>，提高数据传输的效率。</p>
</li>
</ul>
<p><strong>因为对称加密的保密性完全依赖于密钥的保密性。</strong>在双方通信之前，需要商量一个用于对称加密的密钥。而网络通信的信道是不安全的，传输报文对任何人是可见的，密钥的交换肯定不能直接在网络信道中传输。因此，使用非对称加密，对对称加密的密钥进行加密，保护该密钥不在网络信道中被窃听。这样，通信双方只需要一次非对称加密，交换对称加密的密钥，在之后的信息通信中，使用绝对安全的密钥，对信息进行对称加密，即可保证传输消息的保密性。</p>
<h3 id="HTTPS的证书认证过程"><a href="#HTTPS的证书认证过程" class="headerlink" title="HTTPS的证书认证过程"></a>HTTPS的证书认证过程</h3><p>  HTTPS的证书认证过程如下：</p>
<ol>
<li><p>浏览器将自己支持的一套加密规则发送给网站。</p>
</li>
<li><p>网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。</p>
</li>
<li><p>浏览器获得网站证书之后浏览器要做以下工作：</p>
<p>（1） 验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。 （2）如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。 （3）使用约定好的HASH算法计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。</p>
</li>
<li><p>网站接收浏览器发来的数据之后要做以下的操作：</p>
<p>（1） 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。 （2） 使用密码加密一段握手消息，发送给浏览器。</p>
</li>
<li><p>浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。</p>
</li>
</ol>
<h3 id="为什么要有CA？"><a href="#为什么要有CA？" class="headerlink" title="为什么要有CA？"></a><strong>为什么要有CA？</strong></h3><p><strong>为了非对称加密中公钥传输的信赖性问题，防止中间人攻击。</strong>	</p>
<p>CA 默认是受信任的第三方。CA 会给各个服务器颁发证书，证书存储在服务器上，并附有 CA 的<strong>电子签名</strong>。（为了防止郑虎被伪造，用到了数字签名。数字签名，是 CA 在给服务器颁发证书时，使用散列+加密的组合技术，在证书上盖个章，以此来提供验伪的功能。）</p>
<p><strong>PS</strong>：（CA 知道服务器的公钥，对该公钥采用散列技术生成一个摘要。CA 使用 CA 私钥对该摘要进行加密，并附在证书下方，发送给服务器。</p>
<p>现在服务器将该证书发送给客户端，客户端需要验证该证书的身份。客户端找到第三方机构 CA，获知 CA 的公钥，并用 CA 公钥对证书的签名进行解密，获得了 CA 生成的摘要。</p>
<p>客户端对证书数据（也就是服务器的公钥）做相同的散列处理，得到摘要，并将该摘要与之前从签名中解码出的摘要做对比，如果相同，则身份验证成功；否则验证失败。）</p>
<h3 id="SSL-x2F-STL"><a href="#SSL-x2F-STL" class="headerlink" title="SSL&#x2F;STL"></a>SSL&#x2F;STL</h3><p>SSL 指安全套接字协议（Secure Sockets Layer），TLS 是基于 SSL 之上的，但由于习惯叫法，通常把 HTTPS 中的核心加密协议混成为 SSL&#x2F;TLS。</p>
<p><strong>SSL&#x2F;STL的工作原理</strong></p>
<p>SSL&#x2F;TLS 的核心要素是<strong>非对称加密</strong>。非对称加密采用两个密钥——一个公钥，一个私钥。在通信时，私钥仅由解密者保存，公钥由任何一个想与解密者通信的发送者（加密者）所知。非对称加密的公钥和私钥需要采用一种复杂的数学机制生成（密码学认为，为了较高的安全性，尽量不要自己创造加密方案）。公私钥对的生成算法依赖于单向陷门函数。</p>
<p>使用 SSL&#x2F;TLS 进行通信的双方需要使用非对称加密方案来通信，但是非对称加密设计了较为复杂的数学算法，在实际通信过程中，计算的代价较高，效率太低，因此，<strong>SSL&#x2F;TLS 实际对消息的加密使用的是对称加密</strong>。（<strong>对称加密</strong>：通信双方共享唯一密钥 k，加解密算法已知，加密方利用密钥 k 加密，解密方利用密钥 k 解密，保密性依赖于密钥 k 的保密性。）</p>
<h2 id="7-HTTP状态码"><a href="#7-HTTP状态码" class="headerlink" title="7. HTTP状态码"></a>7. HTTP状态码</h2><table>
<thead>
<tr>
<th>分类</th>
<th>分类描述</th>
</tr>
</thead>
<tbody><tr>
<td>1**</td>
<td>信息，服务器收到请求，需要请求者继续执行操作</td>
</tr>
<tr>
<td>2**</td>
<td>成功，操作被成功接收并处理</td>
</tr>
<tr>
<td>3**</td>
<td>重定向，需要进一步的操作以完成请求</td>
</tr>
<tr>
<td>4**</td>
<td>客户端错误，请求包含语法错误或无法完成请求</td>
</tr>
<tr>
<td>5**</td>
<td>服务器错误，服务器在处理请求的过程中发生了错误</td>
</tr>
</tbody></table>
<p>常见状态码：</p>
<ul>
<li><p><strong>200</strong>：服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。</p>
</li>
<li><p><strong>201</strong>： 已创建。成功请求并创建了新的资源</p>
</li>
<li><p><strong>202</strong> (Accepted&#x2F;接受) (SC_ACCEPTED)告诉客户端请求正在被执行，但还没有处理完。</p>
</li>
<li><p>203：非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</p>
</li>
<li><p>204：无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</p>
</li>
<li><p>205：重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</p>
</li>
<li><p>206：部分内容。服务器成功处理了部分GET请求</p>
</li>
<li><p><strong>301</strong>： 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</p>
</li>
<li><p><strong>302</strong>：临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</p>
</li>
<li><p>303：查看其它地址。与301类似。使用GET和POST请求查看</p>
</li>
<li><p>304：未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</p>
</li>
<li><p>305：使用代理。所请求的资源必须通过代理访问</p>
</li>
<li><p>306：已经被废弃的HTTP状态码</p>
</li>
<li><p>307：临时重定向。与302类似。使用GET请求重定向</p>
</li>
<li><p><strong>400</strong> ：客户端请求的语法错误，服务器无法理解</p>
</li>
<li><p><strong>401</strong> (Unauthorized&#x2F;未授权)请求要求用户的身份认证</p>
<p>401 (SC_UNAUTHORIZED)表示客户端在授权头信息中没有有效的身份信息时访问受到密码保护的页面。这个响应必须包含一个WWW-Authenticate的授权信息头。</p>
</li>
<li><p><strong>403</strong> ：服务器理解请求客户端的请求，但是拒绝执行此请求</p>
</li>
<li><p><strong>404</strong> ：服务器无法根据客户端的请求找到资源（网页）。</p>
</li>
<li><p>405：客户端请求中的方法被禁止</p>
</li>
<li><p>406：服务器无法根据客户端请求的内容特性完成请求</p>
</li>
<li><p>407：请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</p>
</li>
<li><p>408：服务器等待客户端发送的请求时间过长，超时</p>
</li>
<li><p>409：服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</p>
</li>
<li><p>410：客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</p>
</li>
<li><p>411：服务器无法处理客户端发送的不带Content-Length的请求信息</p>
</li>
<li><p>412：客户端请求信息的先决条件错误</p>
</li>
<li><p>413：由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</p>
</li>
<li><p>414：请求的URI过长（URI通常为网址），服务器无法处理</p>
</li>
<li><p>415：服务器无法处理请求附带的媒体格式</p>
</li>
<li><p>416：客户端请求的范围无效</p>
</li>
<li><p>417：服务器无法满足Expect的请求头信息</p>
</li>
<li><p><strong>500</strong>： (服务器内部错误) 服务器遇到错误，无法完成请求。</p>
</li>
<li><p>501： 服务器不支持请求的功能，无法完成请求</p>
</li>
<li><p><strong>502</strong> (Bad Gateway&#x2F;错误的网关)作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</p>
</li>
<li><p><strong>503</strong> (Service Unavailable&#x2F;服务无法获得)由于超载或系统维护，服务器暂时的无法处理客户端的请求。<u>例如</u>，如果某些线程或数据库连接池已经没有空闲则servlet会返回这个头信息。服务器可提供一个Retry-After头信息告诉客户端什么时候可以在试一次。</p>
</li>
<li><p><strong>504</strong> (Gateway Timeout&#x2F;网关超时)充当网关或代理的服务器，未及时从远端服务器获取请求</p>
</li>
<li><p>505：服务器不支持请求的HTTP协议的版本，无法完成处理</p>
</li>
</ul>
<h2 id="8-DNS域名解析"><a href="#8-DNS域名解析" class="headerlink" title="8. DNS域名解析"></a>8. DNS域名解析</h2><ol>
<li>首先客户端位置是一台电脑或手机，在打开浏览器以后，比如输入<a href="http://www.zdns.cn的域名，它首先是由浏览器发起一个DNS解析请求，如果本地缓存服务器中找不到结果，则首先会向根服务器查询，根服务器里面记录的都是各个顶级域所在的服务器的位置，当向根服务器请求[http://www.zdns.cn]的时候，根服务器就会返回.cn服务器的位置信息；">http://www.zdns.cn的域名，它首先是由浏览器发起一个DNS解析请求，如果本地缓存服务器中找不到结果，则首先会向根服务器查询，根服务器里面记录的都是各个顶级域所在的服务器的位置，当向根服务器请求[http://www.zdns.cn]的时候，根服务器就会返回.cn服务器的位置信息；</a></li>
<li>递归服务器拿到.cn的权威服务器地址以后，就会寻问.cn的权威服务器，知不知道[<a href="http://www.zdns.cn]的位置。这个时候.cn权威服务器查找并返回[http://zdns.cn]服务器的地址；">http://www.zdns.cn]的位置。这个时候.cn权威服务器查找并返回[http://zdns.cn]服务器的地址；</a></li>
<li>继续向[<a href="http://zdns.cn]的权威服务器去查询这个地址，由[http://zdns.cn]的服务器给出了地址：202.173.11.10；">http://zdns.cn]的权威服务器去查询这个地址，由[http://zdns.cn]的服务器给出了地址：202.173.11.10；</a></li>
<li>最终进入http的链接，顺利访问网站；</li>
</ol>
<p><strong>补充说明</strong>：一旦递归服务器拿到解析记录以后，就会在本地进行缓存，如果下次客户端再请求本地的递归域名服务器相同域名的时候，就不会再这样一层一层查了，因为本地服务器里面已经有缓存了，这个时候就直接把[<a href="http://www.zdns.cn]的记录返回给客户端就可以了。">http://www.zdns.cn]的记录返回给客户端就可以了。</a></p>
<p><strong>一级&#x2F;二级&#x2F;三级域名什么区别？</strong></p>
<ul>
<li>一级域名：又叫顶级域名，一般分为国家顶级域名(如.cn、.us等)和国际顶级域名(如.net)</li>
<li>二级域名：在顶级域名之下的域名，可以按照不同类型(如.gov、.edu等)或者不同地域分(如省份)。</li>
<li>三级域名：这个域名是让网站的制作者自己起的，三级域名是由字母、大小写以及连接符号三个部分组成的，网站制作者可以根据自己网站的特点进行选择。</li>
</ul>
<h2 id="9-输入一条url经历的过程？"><a href="#9-输入一条url经历的过程？" class="headerlink" title="9. 输入一条url经历的过程？"></a>9. 输入一条url经历的过程？</h2><ul>
<li>客户端获取URL-&gt;封装HTTP请求 - &gt; DNS解析 - &gt; TCP连接 - &gt;发送HTTP请求 - &gt;服务器处理请求 - &gt;返回报文 - &gt;浏览器解析渲染页面 - &gt; TCP断开连接</li>
</ul>
<ol>
<li><p>解析URL </p>
<p>浏览器做的第⼀步就是解析 URL 得到⾥⾯的参数，将域名和需要请求的资源分离开来 </p>
<img src="/2022/10/10/%E7%BD%91%E7%BB%9C/image-20220719204933154.png" class="">
</li>
<li><p>封装HTTP请求 「封装」成⼀个 HTTP 请求报⽂发送。</p>
</li>
<li>
</li>
<li><p>DNS域名解析</p>
<p><strong>递归查询</strong>：浏览器DNS缓存—-&gt;操作系统DNS缓存—-&gt;本地host文件</p>
<p>当浏览器拿到输入的 <a href="https://link.zhihu.com/?target=http://www.baidu.com">http://www.baidu.com</a> 后，首先会去浏览器的 dns 缓存中去查询是否有对应记录，如果查询到记录就可以直接返回 ip 地址，完成解析。</p>
<p>如果浏览器没有缓存，那就再去查询操作系统的缓存，同样的，如果查询到记录就可以直接返回 ip 地址，完成解析。</p>
<p>如果操作系统也没有缓存，那就再去查看本地 host 文件，Windows 下 host 文件一般位于 “C:\Windows\System32\drivers\etc”。</p>
<p>如果本地 host 文件也没有相应记录，那就需要求助于本地 dns 服务器了，</p>
<p><strong>迭代查询</strong>：本地DNS服务器—-&gt;根域名服务器—-&gt;顶级域名服务器—-&gt;权限域名服务器</p>
<p>dns 域名服务器一般分三种，分别是根域名服务器 (.)、顶级域名服务器 (.com)、权限域名服务器 (<a href="https://link.zhihu.com/?target=http://baidu.com">http://baidu.com</a>) 。</p>


<p>建⽴TCP连接 </p>
<p>三次握手</p>
</li>
<li><p>准备发送请求（TCP）</p>
<p>TCP：HTTP报⽂——&gt;序号分割—–&gt;若⼲报⽂段+加上 TCP ⾸部 </p>
</li>
<li><p>数据传输（IP） </p>
<p>添加 IP ⾸部封装成 IP 数据报，数据分组+路由选择。</p>
</li>
<li><p>服务器响应请求 </p>
<ol>
<li>TCP：重组报⽂，解析数据 </li>
<li>HTTP:Web 映射获取请求资源</li>
</ol>
</li>
<li><p>数据返回，关闭连接</p>
<p>同样TCP&#x2F;IP协议传回 </p>
<p>假如不在传输数据，四次挥⼿</p>
</li>
<li><p>浏览器解析渲染 </p>
<p>根据响应码，进⾏响应，解码HTML⽂件 </p>
<ol>
<li>HTML解析器：解析JS，DOM，CSS  </li>
<li>异步请求css,图⽚等资源 （http2.0直接发送）</li>
<li>渲染</li>
</ol>
</li>
<li><p>如何客户端没有其他的请求，则通过四次挥手断开连接。</p>
</li>
</ol>
<h2 id="10-GET和POST的区别"><a href="#10-GET和POST的区别" class="headerlink" title="10.GET和POST的区别"></a>10.GET和POST的区别</h2><p>正常情况下</p>
<ul>
<li><p>GET在浏览器回退时是无害的，而POST会再次提交请求。</p>
</li>
<li><p>GET产生的URL地址可以被Bookmark，而POST不可以。</p>
</li>
<li><p>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</p>
</li>
<li><p>GET请求只能进行url编码，而POST支持多种编码方式。 </p>
</li>
<li><p>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</p>
</li>
<li><p>GET请求在URL中传送的参数是有长度限制的，而POST么有。</p>
</li>
<li><p>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</p>
</li>
<li><p>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</p>
</li>
<li><p>GET参数通过URL传递，POST放在Request body中。</p>
</li>
</ul>
<p>（本标准答案参考自w3schools）</p>
<h3 id="8-1是否幂等"><a href="#8-1是否幂等" class="headerlink" title="8.1是否幂等"></a>8.1是否幂等</h3><p>GET同来读取一个资源，可以对GET请求的数据做缓存，反复读取不应该对访问的数据有副作用。比如”GET一下，用户就下单了，返回订单已受理“。没有副作用被称为“幂等“（Idempotent)。</p>
<p>POST用于上传资源最明显的区别：GET把参数包含在URL中，在页面里<form> 标签会定义一个表单。点击其中的submit元素会发出一个POST请求让服务器做一件事。这件事往往是<strong>有副作用的，不幂等的</strong>。不幂等也就意味着不能随意多次执行。因此也就不能缓存，比如通过POST下一个单，服务器创建了新的订单，然后返回订单成功的界面。这个页面不能被缓存。试想一下，如果POST请求被浏览器缓存了，那么下单请求就可以不向服务器发请求，而直接返回本地缓存的“下单成功界面”，却又没有真的在服务器下单。</p>
<h3 id="8-2数据格式"><a href="#8-2数据格式" class="headerlink" title="8.2数据格式"></a>8.2数据格式</h3><p>GET和POST携带数据的格式也有区别。当浏览器发出一个GET请求时，就意味着要么是用户自己在浏览器的地址栏输入，要不就是点击了html里a标签的href中的url。所以其实<strong>并不是GET只能用url，而是</strong>浏览器直接发出的GET只能由一个url触发。所以没办法，GET上要在url之外带一些参数就只能依靠url上附带querystring。但是HTTP协议本身并没有这个限制。</p>
<p><strong>浏览器的POST请求都来自表单提交</strong>。每次提交，<strong>表单的数据被浏览器用编码到HTTP请求的body里</strong>。浏览器发出的POST请求的body主要有有两种格式，一种是application&#x2F;x-www-form-urlencoded用来传输简单的数据，大概就是”key1&#x3D;value1&amp;key2&#x3D;value2”这样的格式。另外一种是传文件，会采用multipart&#x2F;form-data格式。采用后者是因为application&#x2F;x-www-form-urlencoded的编码方式对于文件这种二进制的数据非常低效。</p>
<p>POST通过request body传 递参数。</p>
<h3 id="8-3关于安全性"><a href="#8-3关于安全性" class="headerlink" title="8.3关于安全性"></a>8.3关于安全性</h3><p>我们常听到GET不如POST安全，因为POST用body传输数据，而GET用url传输，更加容易看到。但是从攻击的角度，无论是GET还是POST都不够安全，因为HTTP本身是<strong>明文协议</strong>。<strong>每个HTTP请求和返回的每个byte都会在网络上明文传播，不管是url，header还是body</strong>。</p>
<p><strong>但是，实际上：GET和POST本质上没区别</strong></p>
<p>   HTTP的底层是TCP&#x2F;IP。所以GET和POST的底层也是TCP&#x2F;IP，也就是说，GET&#x2F;POST都是TCP链接。GET和POST能做的事情是一样一样的。</p>
<p>GET和POST还有一个<strong>重大区别</strong>，简单的说：</p>
<p>GET产生一个TCP数据包；POST产生两个TCP数据包。 </p>
<p>长的说：</p>
<p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p>
<p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p>
<h3 id="8-4关于编码"><a href="#8-4关于编码" class="headerlink" title="8.4关于编码"></a>8.4关于编码</h3><p><strong>常见的说法有，比如GET的参数只能支持ASCII，而POST能支持任意binary，包括中文。但其实从上面可以看到，GET和POST实际上都能用url和body。</strong>因此所谓编码确切地说应该是http中url用什么编码，body用什么编码。</p>
<p>url只能支持ASCII的说法源自于<a href="https://link.zhihu.com/?target=https://www.ietf.org/rfc/rfc1738.txt">RFC1738</a>。实际上这里规定的仅仅是一个ASCII的子集[a-zA-Z0-9$-_.+!*’(),]。它们是可以“不经编码”在url中使用。比如尽管空格也是ASCII字符，但是不能直接用在url里。</p>
<p>如果url有了特殊符号和中文怎么办呢？一种叫做percent encoding的编码方法就是干这个用的：但要特别注意，这个编码方式只管把字符转换成URL可用字符，但是却不管字符集编码（比如中文到底是用UTF8还是GBK）。</p>
<p>因此，这块早期一直都相当乱，也没有什么统一规范。<strong>对于同样一个带中文的url，如果有的浏览器一定要用GBK（比如老的IE8），有的一定要用UTF8（比如chrome）。后端就可能认不出来。对此常用的办法是避免让用户输入这种带中文的url。</strong>如果有这种形式的请求，都改成用户界面上输入，然后通过Ajax发出的办法。Ajax发出的编码形式开发者是可以100%控制的。</p>
<p>HTTP Body相对好些，因为有个Content-Type来比较明确的定义。比如：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST xxxxxx HTTP/1.1</span><br><span class="line">...</span><br><span class="line">Content-Type: application/x-www-form-urlencoded ; charset=UTF-8</span><br></pre></td></tr></table></figure>

<p>这里Content-Type会同时定义请求body的格式（application&#x2F;x-www-form-urlencoded）和字符编码（UTF-8）。</p>
<p>因此可见，<strong>body和url都可以提交中文数据给后端，但是POST的规范好一些，相对不容易出错，容易让开发者安心。</strong></p>
<h2 id="11-HTTP头部"><a href="#11-HTTP头部" class="headerlink" title="11.HTTP头部"></a>11.HTTP头部</h2><p>HTTP的头域包括通用头、请求头、响应头和实体头四个部分。每个头域由一个域名，冒号（:）和域值三部分组成。</p>
<p>　　通用头部：是客户端和服务器都可以使用的头部，可以在客户端、服务器和其他应用程序之间提供一些非常有用的通用功能，如Date头部。</p>
<p>　　请求头部：是请求报文特有的，它们为服务器提供了一些额外信息，比如客户端希望接收什么类型的数据，如Accept头部。</p>
<p>　　响应头部：便于客户端提供信息，比如，客服端在与哪种类型的服务器进行交互，如Server头部。</p>
<p>　　实体头部：指的是用于应对实体主体部分的头部，比如，可以用实体头部来说明实体主体部分的数据类型，如Content-Type头部。</p>
<h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><p>请求头用于说明是谁或什么在发送请求、请求源于何处，或者客户端的喜好及能力。</p>
<p>请求头域可能包含下列字段Accept、Accept-Charset、Accept- Encoding、Accept-Language、Authorization、From、Host、If-Modified-Since、If-Match、If-None-Match、If-Range、If-Range、If-Unmodified-Since、Max-Forwards、Proxy-Authorization、Range、Referer、User-Agent。对请求头域的扩展要求通讯双方都支持，如果存在不支持的请求头域，一般将会作为实体头域处理。</p>
<p>从HTTP协议的角度，“请求头”就是Method + URL（含querystring）+ Headers；再后边的都是请求体。</p>
<img src="/2022/10/10/%E7%BD%91%E7%BB%9C/1460000006760778.png" class="">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">请求行</span><br><span class="line">GET http://www.example.com/ HTTP/1.1</span><br><span class="line">请求头</span><br><span class="line">Accept:</span><br><span class="line">text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*</span><br><span class="line">;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9,en;q=0.8</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Host: www.example.com</span><br><span class="line">If-Modified-Since: Thu, 17 Oct 2019 07:18:26 GMT</span><br><span class="line">If-None-Match: &quot;3147526947+gzip&quot;</span><br><span class="line">Proxy-Connection: keep-alive</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 xxx</span><br><span class="line">空行</span><br><span class="line">请求体</span><br><span class="line">param1=1&amp;param2=2</span><br></pre></td></tr></table></figure>

<p>举例</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">1）请求(客户端-&gt;服务端[request]) </span><br><span class="line">    GET(请求的方式) /newcoder/hello.html(请求的目标资源) HTTP/1.1(请求采用的协议和版本号) </span><br><span class="line">    Accept: */*(客户端能接收的资源类型) </span><br><span class="line">    Accept-Language: en-us(客户端接收的语言类型) </span><br><span class="line">    Connection: Keep-Alive(维护客户端和服务端的连接关系) </span><br><span class="line">    Host: localhost:8080(连接的目标主机和端口号) </span><br><span class="line">    Referer: http://localhost/links.asp(告诉服务器我来自于哪里) </span><br><span class="line">    User-Agent: Mozilla/4.0(客户端版本号的名字) </span><br><span class="line">    Accept-Encoding: gzip, deflate(客户端能接收的压缩数据的类型) </span><br><span class="line">    If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT(缓存时间)  </span><br><span class="line">    Cookie(客户端暂存服务端的信息) </span><br><span class="line">    Date: Tue, 11 Jul 2000 18:23:51 GMT(客户端请求服务端的时间)</span><br><span class="line">    </span><br><span class="line">2）响应(服务端-&gt;客户端[response])</span><br><span class="line">    HTTP/1.1(响应采用的协议和版本号) 200(状态码) OK(描述信息)</span><br><span class="line">    Location: http://www.baidu.com(服务端需要客户端访问的页面路径) </span><br><span class="line">    Server:apache tomcat(服务端的Web服务端名)</span><br><span class="line">    Content-Encoding: gzip(服务端能够发送压缩编码类型) </span><br><span class="line">    Content-Length: 80(服务端发送的压缩数据的长度) </span><br><span class="line">    Content-Language: zh-cn(服务端发送的语言类型) </span><br><span class="line">    Content-Type: text/html; charset=GB2312(服务端发送的类型及采用的编码方式)</span><br><span class="line">    Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT(服务端对该资源最后修改的时间)</span><br><span class="line">    Refresh: 1;url=http://www.it315.org(服务端要求客户端1秒钟后，刷新，然后访问指定的页面路径)</span><br><span class="line">    Content-Disposition: attachment; filename=aaa.zip(服务端要求客户端以下载文件的方式打开该文件)</span><br><span class="line">    Transfer-Encoding: chunked(分块传递数据到客户端）  </span><br><span class="line">    Set-Cookie:SS=Q0=5Lb_nQ; path=/search(服务端发送到客户端的暂存数据)</span><br><span class="line">    Expires: -1//3种(服务端禁止客户端缓存页面数据)</span><br><span class="line">    Cache-Control: no-cache(服务端禁止客户端缓存页面数据)  </span><br><span class="line">    Pragma: no-cache(服务端禁止客户端缓存页面数据)   </span><br><span class="line">    Connection: close(1.0)/(1.1)Keep-Alive(维护客户端和服务端的连接关系)  </span><br><span class="line">    Date: Tue, 11 Jul 2000 18:23:51 GMT(服务端响应客户端的时间)</span><br></pre></td></tr></table></figure>

<h2 id="12-cookie-x2F-session"><a href="#12-cookie-x2F-session" class="headerlink" title="12. cookie &#x2F; session"></a>12. cookie &#x2F; session</h2><h3 id="什么是-Cookie"><a href="#什么是-Cookie" class="headerlink" title="什么是 Cookie"></a>什么是 Cookie</h3><p>HTTP Cookie（也叫 Web Cookie或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，客户端向服务器发起请求，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。</p>
<p>Cookie 使基于无状态的HTTP 协议记录稳定的状态信息成为了可能。</p>
<p><strong>Cookie 主要用于以下三个方面</strong>：</p>
<ul>
<li><strong>会话状态管理</strong>（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li><strong>个性化设置</strong>（如用户自定义设置、主题等）</li>
<li><strong>浏览器行为跟踪</strong>（如跟踪分析用户行为等）</li>
</ul>
<p>【PS：**Cookie 被禁用怎么办?**最常用的就是利用 URL 重写把 Session ID 直接附加在 URL 路径的后面】</p>
<h3 id="什么是-Session"><a href="#什么是-Session" class="headerlink" title="什么是 Session"></a>什么是 Session</h3><p>Session 代表着服务器和客户端一次会话的过程（会话指建立连接到断开连接中间发生的所有动作）。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。</p>
<h3 id="cookie和session是如何配合的？"><a href="#cookie和session是如何配合的？" class="headerlink" title="cookie和session是如何配合的？"></a>cookie和session是如何配合的？</h3><p>用户<strong>第一次请求</strong>服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session ，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。</p>
<p>当用户<strong>第二次访问</strong>服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</p>
<p>根据以上流程可知，<strong>SessionID</strong>是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。</p>
<h3 id="Cookie和Session的区别？"><a href="#Cookie和Session的区别？" class="headerlink" title="Cookie和Session的区别？"></a>Cookie和Session的区别？</h3><ul>
<li><strong>存储位置不同：</strong>Cookie 保存在客户端（浏览器），Session 保存在服务器端。</li>
<li><strong>存取方式的不同：</strong>Cookie 只能保存 ASCII，Session可以存任意数据类型，一般情况下我们可以在Session 中保持一些常用变量信息，比如说 UserId 等。</li>
<li><strong>有效期不同：</strong>Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。</li>
<li><strong>隐私策略不同：</strong>Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。</li>
<li><strong>存储大小不同：</strong> 单个Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。</li>
</ul>
<h2 id="13-分布式session"><a href="#13-分布式session" class="headerlink" title="13. 分布式session"></a>13. 分布式session</h2><p>一般会有以下几种解决方案：</p>
<ul>
<li><strong>客户端存储</strong>：直接将信息存储在cookie中，cookie是存储在客户端上的一小段数据，客户端通过http协议和服务器进行cookie交互，通常用来存储一些不敏感信息</li>
<li><strong>Nginx ip_hash 策略</strong>：服务端使用 Nginx 代理，每个请求按访问 IP 的 hash 分配，这样来自同一IP 固定访问一个后台服务器，避免了在服务器 A 创建 Session，第二次分发到服务器 B 的现象。</li>
<li><strong>Session 复制</strong>：任何一个服务器上的 Session 发生改变（增删改），该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点。</li>
<li><strong>共享 Session</strong>：服务端无状态化，将用户的 Session 等信息使用缓存中间件（如Redis）来统一管理，保障分发到每一个服务器的响应结果都一致。</li>
<li><strong>建议采用共享 Session的方案</strong>。</li>
</ul>
<h2 id="14-负载均衡算法有哪些？"><a href="#14-负载均衡算法有哪些？" class="headerlink" title="14. 负载均衡算法有哪些？"></a>14. 负载均衡算法有哪些？</h2><p>多台服务器以对称的方式组成一个服务器集合，每台服务器都具有等价的地位，能互相分担负载。</p>
<ul>
<li><strong>轮询法</strong>：将请求按照顺序轮流的分配到服务器上。大锅饭，不能发挥某些高性能服务器的优势。</li>
<li>随机法：随机获取一台，和轮询类似。</li>
<li>哈希法：通过ip地址哈希化来确定要选择的服务器编号。好处是,每次客户端访问的服务器都是同一个服务器，能很好地利用session或者cookie。</li>
<li><strong>加权轮询</strong>：根据服务器性能不同加权。</li>
</ul>
<h2 id="15-Telnet-x2F-SSH"><a href="#15-Telnet-x2F-SSH" class="headerlink" title="15. Telnet &#x2F; SSH"></a>15. <strong>Telnet &#x2F; SSH</strong></h2><p><strong>Telnet（远程登陆协议）</strong>通过一个终端登陆到其他服务器，建立在可靠的传输协议 TCP 之上。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用Telnet并被一种称为SSH的非常安全的协议所取代的主要原因。</p>
<p><strong>SSH（Secure Shell 安全的网络传输协议）</strong> 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 建立在可靠的传输协议 TCP 之上。</p>
<p><strong>Telnet 和 SSH 之间的主要区别在于 SSH 协议会对传输的数据进行加密保证数据安全性。</strong></p>
<h2 id="16-URI-和-URL-的区别是什么"><a href="#16-URI-和-URL-的区别是什么" class="headerlink" title="16. URI 和 URL 的区别是什么?"></a>16. <strong>URI 和 URL 的区别是什么?</strong></h2><ul>
<li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</li>
<li>URL(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</li>
</ul>
<p>URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p>
<h2 id="17-BIO、NIO、AIO的区别？"><a href="#17-BIO、NIO、AIO的区别？" class="headerlink" title="17.BIO、NIO、AIO的区别？"></a>17.BIO、NIO、AIO的区别？</h2><p><strong>BIO</strong>：<strong>同步阻塞</strong>，在服务器中实现的模式为<strong>一个<u>连接</u>一个线程</strong>。也就是说，<strong>客户端有连接请求的时候，服务器就需要启动一个线程进行处理</strong>，如果这个连接不做任何事情会造成不必要的线程开销。BIO一般适用于连接数目小且固定的架构，这种方式对于服务器资源要求比较高，而且并发局限于应用中，是JDK1.4之前的唯一选择，但好在程序直观简单，易理解。</p>
<p><strong>NIO</strong>：<strong>同步非阻塞</strong>，在服务器中实现的模式为<strong>一个<u>请求</u>一个线程</strong>，也就是说，客户端发送的连接请求都会注册到<strong>多路复用器</strong>上，<strong>多路复用器轮询到有连接IO请求时才会启动一个线程进行处理</strong>。NIO一般适用于连接数目多且连接比较短（轻操作）的架构，并发局限于应用中，编程比较复杂，从JDK1.4开始支持。</p>
<p><strong>AIO</strong>：<strong>异步非阻塞</strong>，在服务器中实现的模式为<strong>一个<u>有效请求</u>一个线程</strong>，也就是说，<strong>客户端的IO请求都是通过操作系统先完成之后，再通知服务器应用去启动线程进行处理</strong>。AIO一般适用于连接数目多且连接比较长（重操作）的架构，充分调用操作系统参与并发操作，编程比较复杂，从JDK1.7开始支持。</p>
<p><strong>应用场景：</strong></p>
<ul>
<li><p><strong>BIO</strong>适⽤于连接数⼩，对服务器资源要求⾼，因为线程要开很多。</p>
</li>
<li><p><strong>NIO</strong>适合于连接数多且数据连接⽐较短的架构，⽐如聊天服务器，弹幕系统等</p>
</li>
<li><p><strong>AIO</strong>适⽤于连接数多且连接⽐较长的架构。充分调⽤操作系统参与并发操作。</p>
</li>
</ul>
<h2 id="18-RPC"><a href="#18-RPC" class="headerlink" title="18.RPC"></a>18.RPC</h2><p>RPC（Remote Procedure Call）远程过程调用协议，一种通过网络从远程计算机上请求服务，而不需要了解底层网络技术的协议。RPC 是一种技术思想而非一种规范或协议。</p>
<h3 id="核心-RPC-框架的重要组成"><a href="#核心-RPC-框架的重要组成" class="headerlink" title="核心 RPC 框架的重要组成"></a>核心 RPC 框架的重要组成</h3><ul>
<li><strong>客户端（Client）：</strong>服务调用方。</li>
<li><strong>客户端存根（Client Stub）：</strong>存放服务端地址信息，将客户端的请求参数数据信息打包成网络消息，再通过网络传输发送给服务端。</li>
<li><strong>服务端存根（Server Stub）：</strong>接收客户端发送过来的请求消息并进行解包，然后再调用本地服务进行处理。</li>
<li><strong>服务端（Server）：</strong>服务的真正提供者。</li>
<li><strong>Network Service：</strong>底层传输，可以是 TCP 或 HTTP。</li>
</ul>
<p>RPC 的核心功能主要由 5 个模块组成，如果想要自己实现一个 RPC，最简单的方式要实现三个技术点，分别是：</p>
<ul>
<li><p><strong>服务寻址</strong></p>
<p>在本地调用中，函数体是直接通过函数指针来指定的，但是在远程调用中，函数指针是不行的，因为两个进程的地址空间是完全不一样的。</p>
<p>可以使用 Call ID 映射，每个函数拥有一个固定的ID，客户端和服务端分别维护一个Call ID和函数对应的表。</p>
<p><strong>实现方式：</strong>服务注册中心</p>
</li>
<li><p><strong>数据流的序列化和反序列化</strong></p>
<p>只有二进制数据才能在网络中传输，因此需要对数据进行序列化</p>
</li>
<li><p><strong>网络传输</strong></p>
<p>可以使用各种协议，只要完成传输过程就可以。</p>
</li>
</ul>
<h3 id="RPC和Http的区别"><a href="#RPC和Http的区别" class="headerlink" title="RPC和Http的区别"></a>RPC和Http的区别</h3><p>http是协议，rpc指的是远程调用，rpc可以用各种协议实现，可以使用http协议。</p>
<h3 id="为什么有了Rpc还要有Http"><a href="#为什么有了Rpc还要有Http" class="headerlink" title="为什么有了Rpc还要有Http"></a>为什么有了Rpc还要有Http</h3><p>RPC比HTTP出现的早，http最初应用于B&#x2F;S模式，rpc最初应用于C&#x2F;S模式，由于B与C的融合，S需要同时支持B和C，随着RESTFUL思潮的兴起，越来越多系统考虑用HTTP来提供服务，后端系统间调用如果能够采用和前端一样的技术栈，那无疑是维护成本最低的。因此逐渐使用了http</p>
<h2 id="19-重定向和请求转发有什么区别？"><a href="#19-重定向和请求转发有什么区别？" class="headerlink" title="19.重定向和请求转发有什么区别？"></a>19.重定向和请求转发有什么区别？</h2><p><strong>转发是服务器行为，重定向是客户端行为。</strong></p>
<h3 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a><strong>请求转发</strong></h3><p>​	客户首先发送一个请求到服务器端，服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器，整个流程都是在服务器端完成的，而且是在同一个请求里面完成的，客户端察觉不到这个动作，地址栏还是原来的地址。</p>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a><strong>重定向</strong></h3><p>​	是服务端根据逻辑，发送一个状态码，告诉浏览器重新去请求那个地址。所以地址栏显示的是新的URL。（服务器向浏览器发送一个302状态码以及一个location消息头，浏览器收到请求后会向再次根据重定向地址发出请求）</p>
<p><strong>二者区别</strong></p>
<p>（1）<strong>请求次数</strong>：重定向是浏览器向服务器发送一个请求并收到响应后再次向一个新地址发出请求，转发是服务器收到请求后完成响应；重定向至少请求两次，转发请求一次；</p>
<p>（2）<strong>地址栏不同</strong>：重定向地址栏会发生变化，转发地址栏不会发生变化；</p>
<p>（3）<strong>是否共享数据</strong>：重定向两次请求不共享数据，转发一次请求共享数据（在request级别使用信息共享，使用重定向必然出错）；</p>
<p>（4）<strong>跳转限制</strong>：重定向可以跳转到任意URL，转发只能跳转本站点资源；</p>
<p>（5）<strong>发生行为不同</strong>：重定向是客户端行为，转发是服务器端行为。</p>
<p>（6）<strong>效率：</strong>转发效率高，重定向效率低。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2022/10/10/%E7%BD%91%E7%BB%9C/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
    
      <a href="/2022/10/09/JVM/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">JVM</div>
      </a>
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022
        <i class="ri-heart-fill heart_icon"></i> pp-lv
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.png" alt="LPL&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">Categories</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">Tags</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">About</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i></p>
  <div class="reward-box">
    
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>