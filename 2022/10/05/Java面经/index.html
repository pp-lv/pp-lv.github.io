<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>java |  LPL&#39;s Blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-Java面经"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  java
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/10/05/Java%E9%9D%A2%E7%BB%8F/" class="article-date">
  <time datetime="2022-10-05T08:26:49.000Z" itemprop="datePublished">2022-10-05</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">168.1k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">604 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p>Java面经</p>
<h1 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h1><h2 id="1-为什么Java代码可以实现一次编写、到处运行？"><a href="#1-为什么Java代码可以实现一次编写、到处运行？" class="headerlink" title="1. 为什么Java代码可以实现一次编写、到处运行？"></a>1. 为什么Java代码可以实现一次编写、到处运行？</h2><p><strong>JVM</strong>。</p>
<p>在程序运行前，Java源代码（.java）需要经过编译器编译成字节码（.class）。在程序运行时，JVM负责将字节码翻译成特定平台下的机器码并运行，也就是说，只要在不同的平台上安装对应的JVM，就可以运行字节码文件。</p>
<p>同一份Java源代码在不同的平台上运行，它不需要做任何的改变，并且只需要编译一次。而编译好的字节码，是通过JVM这个中间的“桥梁”实现跨平台的，JVM是与平台相关的软件，它能将统一的字节码翻译成该平台的机器码。在程序运行前，Java源代码需要讲过编译成字节码(.class)。在程序运行时，JVM负责将字节码翻译成特定平台下的机器码并运行。</p>
<span id="more"></span>

<h2 id="2-Java的访问权限"><a href="#2-Java的访问权限" class="headerlink" title="2. Java的访问权限"></a>2. Java的访问权限</h2><p>在<strong>修饰成员变量&#x2F;成员方法</strong>时，该成员的四种访问权限的含义如下：</p>
<ul>
<li>private：该成员可以被该<strong>类内</strong>部成员访问；</li>
<li>default：该成员可以被该<strong>类内</strong>部成员访问，也可以被<strong>同一包</strong>下其他的类访问；</li>
<li>protected：该成员可以被该<strong>类内</strong>部成员访问，也可以被<strong>同一包</strong>下其他的类访问，还可以被它的<strong>子类</strong>访问；</li>
<li>public：该成员可以被<strong>任意包</strong>下，<strong>任意类</strong>的成员进行访问。</li>
</ul>
<p>在<strong>修饰类</strong>时，该类只有两种访问权限，对应的访问权限的含义如下：</p>
<ul>
<li>default：该类可以被<strong>同一包</strong>下其他的类访问；</li>
<li>public：该类可以被<strong>任意包</strong>下，<strong>任意的类</strong>所访问。</li>
</ul>
<h2 id="3-Java的数据类型"><a href="#3-Java的数据类型" class="headerlink" title="3. Java的数据类型"></a>3. Java的数据类型</h2><p>Java数据类型包括<strong>基本数据类型</strong>和<strong>引用数据类型</strong>两大类。</p>
<p><strong>基本数据类型</strong>有8个，可以分为4个小类：</p>
<ul>
<li>整型：byte&#x2F;short&#x2F;int&#x2F;long （默认值是0 &#x2F; 0L）</li>
<li>浮点类型：float&#x2F;double （0.0F &#x2F; 0.0）</li>
<li>字符类型：char （’\u0000‘）</li>
<li>布尔类型：boolean (false)</li>
</ul>
<p>引用类型就是对一个对象的引用，根据引用对象类型的不同，可以将引用类型分为3类，即数组、类、接口类型。引用类型本质上就是通过指针，指向堆中对象所持有的内存空间，只是Java语言不再沿用指针这个说法而已。</p>
<ul>
<li>引用类型：数组、类、接口等等</li>
</ul>
<p><strong>PS：数据范围：</strong></p>
<ul>
<li>byte：1字节（8位），数据范围是 -2^7 ~ 2^7-1。</li>
<li>short：2字节（16位），数据范围是 -2^15 ~ 2^15-1。</li>
<li>int：4字节（32位），数据范围是 -2^31 ~ 2^31-1。</li>
<li>long：8字节（64位），数据范围是 -2^63 ~ 2^63-1。</li>
<li>float：4字节（32位），数据范围大约是 -3.4<em>10^38 ~ 3.4</em>10^38。</li>
<li>double：8字节（64位），数据范围大约是 -1.8<em>10^308 ~ 1.8</em>10^308。</li>
<li>char：2字节（16位），数据范围是 \u0000 ~ \uffff。</li>
<li>boolean：Java规范没有明确的规定，不同的JVM有不同的实现机制。</li>
</ul>
<h2 id="4-成员变量与局部变量"><a href="#4-成员变量与局部变量" class="headerlink" title="4. 成员变量与局部变量"></a>4. 成员变量与局部变量</h2><ul>
<li>成员变量<ul>
<li>类的范围内定义的变量</li>
<li>有默认初始值</li>
<li>未被static修饰的成员变量叫实例变量，存储于堆内，生命周期与对象相同</li>
<li>被static修饰的成员变量叫类变量，存储于方法区，生命周期与当前类相同</li>
</ul>
</li>
<li>局部变量<ul>
<li>在方法里定义的变量</li>
<li>没有默认初始值</li>
<li>存储于栈中</li>
</ul>
</li>
</ul>
<h2 id="5-自动装箱、自动拆箱"><a href="#5-自动装箱、自动拆箱" class="headerlink" title="5. 自动装箱、自动拆箱"></a>5. 自动装箱、自动拆箱</h2><ul>
<li>自动装箱：把一个基本类型的数据直接赋值给对应的包装类型</li>
<li>自动拆箱：把一个包装类型的对象直接赋值给对应的基本类型</li>
<li>通过自动装箱、自动拆箱功能，可以大大简化基本类型变量和包装类对象之间的转换过程。比如，某个方法的参数类型为包装类型，调用时我们所持有的数据却是基本类型的值，则可以不做任何特殊的处理，直接将这个基本类型的值传入给方法即可。</li>
</ul>
<h3 id="为啥要有包装类？"><a href="#为啥要有包装类？" class="headerlink" title="为啥要有包装类？"></a>为啥要有包装类？</h3><p>Java语言是面向对象的语言，其设计理念是“一切皆对象”。但8种基本数据类型却出现了例外，它们不具备对象的特性。正是为了解决这个问题，<strong>Java为每个基本数据类型都定义了一个对应的引用类型，这就是包装类。</strong></p>
<h3 id="包装类型的缓存机制"><a href="#包装类型的缓存机制" class="headerlink" title="包装类型的缓存机制"></a>包装类型的缓存机制</h3><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p>
<p>如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p>
<p>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现缓存机制。</p>
<p><strong>PS：</strong>所有整型包装类对象之间值的比较，建议全部使用 equals 方法比较。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-int和Integer的区别？-x3D-x3D-时会得到什么结果？"><a href="#6-int和Integer的区别？-x3D-x3D-时会得到什么结果？" class="headerlink" title="6. int和Integer的区别？&#x3D;&#x3D;时会得到什么结果？"></a>6. int和Integer的区别？&#x3D;&#x3D;时会得到什么结果？</h2><p>基本数据类型 &#x2F; 包装类</p>
<p>&#x3D;&#x3D; 时，Integer会自动拆箱为int</p>
<h2 id="7-对面向对象的理解"><a href="#7-对面向对象的理解" class="headerlink" title="7. 对面向对象的理解"></a>7. 对面向对象的理解</h2><h3 id="Is-a："><a href="#Is-a：" class="headerlink" title="Is-a："></a><strong>Is-a：</strong></h3><p><strong>是a：A Is B：A是B（继承关系，继承）。</strong></p>
<h3 id="has-a："><a href="#has-a：" class="headerlink" title="has-a："></a><strong>has-a：</strong></h3><p><strong>有a：A has B：A有B（从属关系，聚合）。</strong></p>
<h3 id="like-a："><a href="#like-a：" class="headerlink" title="like-a："></a><strong>like-a：</strong></h3><p><strong>像a：A like B：A像B（组合关系，接口）。</strong></p>
<p>如果A,B是Is-a关系，那么应该使用继承，例：玻璃杯、塑料杯都是杯子。</p>
<p><strong>如果A,B是has-a关系，那么应该是用聚合，例：汽车由发动机，底盘，车身，电气设备等组成，那么应该把发动机，底盘这些类聚合成汽车。</strong></p>
<p>如果A,B是like-a关系，那么应该使用组合，例：空调继承于制冷机，但它同时有加热功能，那么你应该把让空调继承制冷机类，并实现加热接口。</p>
<p>基本思想是使用类、对象、继承、封装、消息等基本概念进行程序设计。它从现实世界中客观的事物触发来构造软件系统，强调直接以现实世界中的事物为中心来思考，把他们抽象地表示为系统中的类。</p>
<h3 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h3><ul>
<li><p>封装：是面向对象编程语言对客观世界的模拟，在客观世界里，对象的状态信息都被隐藏在对象内部，外界无法直接操作和修改。对一个类或对象实现良好的封装，可以实现以下目的：</p>
<ul>
<li>隐藏类的实现细节；</li>
<li>让使用者只能通过事先预定的方法来访问数据，从而可以在该方法里加入控制逻辑，限制对成员变量的不合理访问；</li>
<li>可进行数据检查，从而有利于保证对象信息的完整性；</li>
<li>便于修改，提高代码的可维护性。</li>
</ul>
</li>
<li><p>继承：当子类继承父类使，将直接获得父类的一些属性和方法。</p>
</li>
<li><p>多态：因为子类其实是一种特殊的父类，因此Java允许把一个子类对象直接赋给一个父类引用变量，无须任何类型转换，或者被称为向上转型，向上转型由系统自动完成。<strong>编译时是父类类型，运行时是子类类型</strong></p>
<p>当把一个子类对象直接赋给父类引用变量时，例如 BaseClass obj &#x3D; new SubClass();，这个obj引用变量的编译时类型是BaseClass，而运行时类型是SubClass，当运行时调用该引用变量的方法时，其方法行为总是表现出子类方法的行为特征，而不是父类方法的行为特征，这就可能出现：相同类型的变量、调用同一个方法时呈现出多种不同的行为特征，这就是多态。</p>
</li>
</ul>
<h3 id="多态的实现方式？"><a href="#多态的实现方式？" class="headerlink" title="多态的实现方式？"></a><strong>多态的实现方式？</strong></h3><p><strong>多态的实现离不开继承</strong>，在设计程序时，我们可以将参数的类型定义为父类型。在调用程序时，则可以根据实际情况，传入该父类型的某个子类型的实例，这样就实现了多态。对于父类型，可以有三种形式，即普通的类、抽象类、接口。对于子类型，则要根据它自身的特征，重写父类的某些方法，或实现抽象类&#x2F;接口的某些抽象方法。</p>
<h3 id="Java为什么不能多继承？"><a href="#Java为什么不能多继承？" class="headerlink" title="Java为什么不能多继承？"></a><strong>Java为什么不能多继承？</strong></h3><p>首先，Java是单继承的，指的是Java中一个类只能有一个直接的父类。Java不能多继承，则是说Java中一个类不能直接继承多个父类。</p>
<p>其次，Java在设计时借鉴了C++的语法，而C++是支持多继承的。Java语言之所以摒弃了多继承的这项特征，是因为<strong>多继承容易产生混淆</strong>。比如，两个父类中包含相同的方法时，子类在调用该方法或重写该方法时就会迷惑。</p>
<p>准确来说，Java是可以实现”多继承”的。因为尽管一个类只能有一个直接父类，但是却可以有任意多个间接的父类。这样的设计方式，避免了多继承时所产生的混淆。</p>
<h2 id="8-Object类"><a href="#8-Object类" class="headerlink" title="8. Object类"></a>8. Object类</h2><p>Object 类是一个特殊的类，<strong>是所有类的父类</strong>。</p>
<p><strong>Object类提供了如下几个常用方法：</strong></p>
<ul>
<li>Class&lt;?&gt; <strong>getClass</strong>()：返回该对象的运行时类。</li>
<li>boolean <strong>equals</strong>(Object obj)：判断指定对象与该对象是否相等。</li>
<li>int <strong>hashCode</strong>()：返回该对象的hashCode值。在默认情况下，Object类的hashCode()方法根据该对象的地址来计算。但很多类都重写了Object类的hashCode()方法，不再根据地址来计算其hashCode()方法值。</li>
<li>String <strong>toString</strong>()：返回该对象的字符串表示，当程序使用System.out.println()方法输出一个对象，或者把某个对象和字符串进行连接运算时，系统会自动调用该对象的toString()方法返回该对象的字符串表示。Object类的toString()方法返回 运行时类名@十六进制hashCode值 格式的字符串，但很多类都重写了Object类的toString()方法，用于返回可以表述该对象信息的字符串。</li>
</ul>
<p>另外，Object类还提供了<strong>wait</strong>()、<strong>notify</strong>()、<strong>notifyAll</strong>()这几个方法，通过这几个方法可以控制线程的暂停和运行。Object类还提供了一个clone()方法，该方法用于帮助其他对象来实现“自我克隆”，所谓“自我克隆”就是得到一个当前对象的副本，而且二者之间完全隔离。由于该方法使用了protected修饰，因此它只能被子类重写或调用。</p>
<p><strong>扩展阅读</strong></p>
<p>Object类还提供了一个<strong>finalize</strong>()方法，当系统中没有引用变量引用到该对象时，垃圾回收器调用此方法来清理该对象的资源。并且，针对某一个对象，垃圾回收器最多只会调用它的finalize()方法一次。</p>
<p>注意，finalize()方法何时调用、是否调用都是不确定的，我们也不要主动调用finalize()方法。从JDK9开始，这个方法被标记为不推荐使用的方法。</p>
<h2 id="9-hashCode-和equals-的关系"><a href="#9-hashCode-和equals-的关系" class="headerlink" title="9. hashCode()和equals()的关系"></a>9. hashCode()和equals()的关系</h2><p>hashCode()用于获取哈希码，equals()用于比较两个对象是否相等：</p>
<ul>
<li>如果两个对象相等，则他们必须有相同的哈希码</li>
<li>如果他们两个对象有相同的哈希码，则它们未必相等，（比如set查找时）</li>
</ul>
<p><strong>PS：</strong>在Java中，Set接口代表无序的、元素不可重复的集合，HashSet则是Set接口的典型实现。</p>
<p>当向HashSet中加入一个元素时，它需要判断集合中是否已经包含了这个元素，从而避免重复存储。由于这个判断十分的频繁，所以要讲求效率，绝不能采用遍历集合逐个元素进行比较的方式。实际上，HashSet是通过获取对象的哈希码，以及调用对象的equals()方法来解决这个判断问题的。</p>
<p>HashSet首先会调用对象的hashCode()方法获取其哈希码，并通过哈希码确定该对象在集合中存放的位置。假设这个位置之前已经存了一个对象，则HashSet会调用equals()对两个对象进行比较。若相等则说明对象重复，此时不会保存新加的对象。若不等说明对象不重复，但是它们存储的位置发生了碰撞，此时HashSet会采用链式结构在同一位置保存多个对象，即将新加对象链接到原来对象的之后。之后，再有新添加对象也映射到这个位置时，就需要与这个位置中所有的对象进行equals()比较，若均不相等则将其链到最后一个对象之后。</p>
<h3 id="1）介绍一下hashCode"><a href="#1）介绍一下hashCode" class="headerlink" title="1）介绍一下hashCode()"></a>1）介绍一下hashCode()</h3><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数。</p>
<h3 id="2）为什么要有hashCode"><a href="#2）为什么要有hashCode" class="headerlink" title="2）为什么要有hashCode"></a>2）为什么要有hashCode</h3><p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。</p>
<p>但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p>
<h3 id="3）hashcode和equals的区别"><a href="#3）hashcode和equals的区别" class="headerlink" title="3）hashcode和equals的区别"></a>3）hashcode和equals的区别</h3><h4 id="hashcode"><a href="#hashcode" class="headerlink" title="hashcode"></a>hashcode</h4><p> Object 中的 hashCode 方法求的是对象的散列值，例如在set中，通过散列值去定位要存放的位置，两个相同对象的散列值一定相同，而散列值相同的对象不一定相等。可以通过hashcode可以初步判断两个对象是否相等。</p>
<h4 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h4><p>Object 类中的 equals 方法用于检测一个对象是否等于另外一个对象。在 Object 类中，这个方法将判断两个对象是否具有相同的引用。如果两个对象具有相同的引用，它们一定是相等的。</p>
<p>equals 方法的实现源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在大多数情况下这样的比较是没有意义的，因为对象的引用一般不相等，即使值相等。例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">u1.setName(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">u1.setAge(<span class="number">18</span>);</span><br><span class="line">		</span><br><span class="line"><span class="type">Person</span> <span class="variable">u2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">u1.setName(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">u1.setAge(<span class="number">18</span>);</span><br></pre></td></tr></table></figure>

<p>因此<strong>通常情况下，我们要判断两个对象是否相等，一定要重写 equals 方法</strong>。</p>
<h4 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h4><ul>
<li>如果两个对象 equals，Java 运行时环境会认为他们的 hashCode 一定相等。</li>
<li>如果两个对象不 equals，他们的 hashCode 有可能相等。</li>
<li>如果两个对象 hashCode 相等，他们不一定 equals。</li>
<li>如果两个对象 hashCode 不相等，他们一定不 equals</li>
</ul>
<h3 id="4）为什么重写equals方法必须要重写hashCode-方法？"><a href="#4）为什么重写equals方法必须要重写hashCode-方法？" class="headerlink" title="4）为什么重写equals方法必须要重写hashCode()方法？"></a>4）为什么重写equals方法必须要重写hashCode()方法？</h3><p><strong>判断的时候先根据hashcode进行的判断，相同的情况下再根据equals()方法进行判断。如果只重写了equals方法，而不重写hashcode的方法，会造成hashcode的值不同，直接跳过equals方法，而equals()方法判断出来的结果为true。</strong>例如我们在判断两个对象时，会根据对象的属性去判断是否相等，因此会修改equals方法，而在执行equals之前会先通过hashcode判断对象是否相等，对象通常是不相等的，那么就直接返回false，不会再执行equals了，所以我们也得修改haskcode方法，让其根据对象的属性去生成散列值。如下：对象1和对象2应该是相等的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 对象 1</span></span><br><span class="line"><span class="type">Persion</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Persion</span>();</span><br><span class="line">p1.setName(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">p1.setAge(<span class="number">18</span>);</span><br><span class="line"><span class="comment">// 对象 2</span></span><br><span class="line"><span class="type">Persion</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Persion</span>();</span><br><span class="line">p2.setName(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">p2.setAge(<span class="number">18</span>);</span><br></pre></td></tr></table></figure>

<p>重写两个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 引用相等返回 true</span></span><br><span class="line">        <span class="comment">// 如果等于 null，或者对象类型不同返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 强转为自定义 Persion 类型</span></span><br><span class="line">        <span class="type">Persion</span> <span class="variable">persion</span> <span class="operator">=</span> (Persion) o;</span><br><span class="line">        <span class="comment">// 如果 age 和 name 都相等，就返回 true</span></span><br><span class="line">        <span class="keyword">return</span> age == persion.age &amp;&amp;</span><br><span class="line">                Objects.equals(name, persion.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 对比 name 和 age 是否相等</span></span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="5）-x3D-x3D-和equals"><a href="#5）-x3D-x3D-和equals" class="headerlink" title="5）&#x3D;&#x3D; 和equals()"></a>5）&#x3D;&#x3D; 和equals()</h3><p><strong>&#x3D;&#x3D;运算符</strong>：</p>
<ul>
<li>作用于基本数据类型时，是比较两个数值是否相等；</li>
<li>作用于引用数据类型时，是比较两个对象的内存地址是否相同，即判断它们是否为同一个对象；</li>
</ul>
<p><strong>equals()方法</strong>：</p>
<ul>
<li>没有重写时，Object默认以 &#x3D;&#x3D; 来实现，即比较两个对象的内存地址是否相同；</li>
<li>进行重写后，一般会按照对象的内容来进行比较，若两个对象内容相同则认为对象相等，否则认为对象不等。</li>
</ul>
<h2 id="10-String、StringBuilder和StringBuffer的区别？"><a href="#10-String、StringBuilder和StringBuffer的区别？" class="headerlink" title="10. String、StringBuilder和StringBuffer的区别？"></a>10. <strong>String、StringBuilder和StringBuffer的区别？</strong></h2><ul>
<li><p><strong>String类</strong>是不可变类，即一旦一个String对象被创建以后，包含在这个对象中的字符序列是<strong>不可改变</strong>的，直至这个对象被销毁。</p>
<ul>
<li>字符串数组保存，不可变类，一旦创建，其值不可改变；常量，<strong>线程安全</strong>。</li>
<li><u>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。</u></li>
<li>字符串对象<strong>通过“+”的字符串拼接</strong>方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</li>
</ul>
</li>
<li><p><strong>StringBuffer</strong>对象则代表一个字符序列<strong>可变</strong>的字符串，当一个StringBuffer被创建以后，通过StringBuffer提供的append()、insert()、reverse()、setCharAt()、setLength()等方法可以改变这个字符串对象的字符序列。</p>
<ul>
<li><code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。</li>
<li><code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，StringBuffer是<strong>线程安全</strong>的。</li>
<li>一旦通过StringBuffer生成了最终想要的字符串，就可以调用它的toString()方法将其转换为一个String对象。</li>
</ul>
</li>
<li><p><strong>StringBuffer</strong>、<strong>StringBuilder</strong>都代表可变的字符串对象，它们有共同的父类 AbstractStringBuilder，并且两个类的构造方法和成员方法也基本相同。</p>
<ul>
<li>StringBuilder是<strong>非线程安全</strong>的，所以StringBuilder性能略高。</li>
<li>一般情况下，要创建一个内容可变的字符串，建议优先考虑<strong>StringBuilder</strong>类。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</li>
</ul>
</li>
<li><p><strong>对于三者使用的总结：</strong></p>
<ul>
<li>操作少量的数据: 适用 <code>String</code></li>
<li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li>
<li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li>
</ul>
</li>
<li><p><strong>String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？</strong></p>
<p>会创建 <strong>1 或 2</strong> 个字符串对象。</p>
<ul>
<li>如果字符串常量池中不存在字符串对象“abc”的引用，那么会在堆中创建 1 个字符串对象“abc”，常量池中创建一个对象“abc”。</li>
<li>如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”</li>
</ul>
</li>
<li><p><strong>intern 方法有什么作用?</strong></p>
<p><code>String.intern()</code> 是一个 native（本地）方法，其作用是<strong>将指定的字符串对象的引用保存在字符串常量池中</strong>，可以简单分为两种情况：</p>
<ul>
<li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</li>
<li>如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。</li>
</ul>
</li>
</ul>
<h2 id="11-接口和抽象类"><a href="#11-接口和抽象类" class="headerlink" title="11. 接口和抽象类"></a>11. 接口和抽象类</h2><ul>
<li><strong>接口</strong>体现的是一种规范。接口规定了实现者必须向外提供哪些服务，以及如何调用这些服务。一个程序中使用接口时，接口是多个模块间的耦合标准；当在多个应用程序之间使用接口时，接口是多个程序之间的通信标准。<ul>
<li>接口中只能包含静态常量、方法（抽象实例方法、类方法、默认方法或私有方法）、内部类（包括内部类、枚举）。</li>
</ul>
</li>
<li><strong>抽象类</strong>体现的是一种模板式设计。</li>
</ul>
<p><strong>区别：</strong></p>
<ul>
<li>接口不能含有普通方法；抽象类可以。</li>
<li>接口只能定义静态常量；抽象类可以非静态，也可以定义静态。</li>
<li>接口不能含有构造器；抽象类可以有，但是目的是让其子类调用构造器来完成抽象类的初始化操作。</li>
<li>抽象类最多只能有一个父类；但一个类可以直接实现多个接口，通过实现多个接口可以弥补单继承的不足。</li>
</ul>
<p><strong>共同点：</strong></p>
<ul>
<li>都不能被实例化，都位于继承树的顶端</li>
<li>都可以包含<strong>抽象方法</strong>。</li>
<li>都可以有默认实现的方法（Java 8 可以用 <code>default</code> 关键在接口中定义默认方法）。</li>
</ul>
<h4 id="抽象类是否可以继承实体类"><a href="#抽象类是否可以继承实体类" class="headerlink" title="抽象类是否可以继承实体类"></a>抽象类是否可以继承实体类</h4><p>可以继承</p>
<h4 id="抽象类是否可以实现接口"><a href="#抽象类是否可以实现接口" class="headerlink" title="抽象类是否可以实现接口"></a>抽象类是否可以实现接口</h4><p>​	但是<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%8A%BD%E8%B1%A1%E7%B1%BB&spm=1001.2101.3001.7020">抽象类</a>实现接口，可以完全覆盖&#x2F;重写 接口中的方法，也可只重写接口中的某几个方法</p>
<p>​	子类在继承抽象类时，子类重写的方法即为抽象类中未重写接口中的方法。</p>
<pre><code> 在Java中，使用抽象类来实现接口，并不是毫无作用。相反，有时间有很大的作用。
</code></pre>
<p>   当你只想实现接口中的个别方法（不是所有方法）时，你可以先写一个抽象类来实现该接口，并实现除了你想要的方法之外的所有方法（方法体为空）。接着再用你的类继承这个抽象类，这个类中就只用实现你需要的方法了，这样就可以达到你的需要了。但是，如果你直接实现接口的话，你就需要实现接口的所有方法。</p>
<h2 id="12-Java的异常机制"><a href="#12-Java的异常机制" class="headerlink" title="12. Java的异常机制"></a>12. Java的异常机制</h2><ul>
<li>异常处理：try，catch，finally</li>
<li>抛出异常 throw：系统会自动抛出异常。也可以主动抛出异常。</li>
<li>异常跟踪栈：异常机制会导致异常在方法之间传播。</li>
<li>异常接口：<ul>
<li>Error：错误。无法恢复、不可捕获。</li>
<li>Exception：异常。<ul>
<li>Cheched异常。——都是可以被处理的异常</li>
<li>Runtime异常。——所有RuntimeException类及其子类的实例都称为Runtime异常，其他都是Checked异常。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1）Error-和-Exception-区别是什么？"><a href="#1）Error-和-Exception-区别是什么？" class="headerlink" title="1）Error 和 Exception 区别是什么？"></a>1）Error 和 Exception 区别是什么？</h3><p>Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。 Throwable 类有两个<br>重要的子类 Exception（异常）和 Error（错误）。</p>
<p>Exception 和 Error 二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p>
<ul>
<li><strong>Exception</strong> ：程序本身可以处理的异常，可以通过 catch 来进行捕获，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。 Exception 又可以分为运行时异常(RuntimeException, 又叫非受检查异常)和非运行时异常(又叫受检查异常) 。</li>
<li><strong>Error</strong> ：属于程序无法处理的错误 ，我们没办法通过 catch 来进行捕获 。例如，系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复。</li>
</ul>
<p>![Untitled](E:\学习笔记\图片\Untitled 1.png)</p>
<h3 id="2）非受检查异常-运行时异常-和受检查异常-非运行时异常-的区别？"><a href="#2）非受检查异常-运行时异常-和受检查异常-非运行时异常-的区别？" class="headerlink" title="2）非受检查异常(运行时异常)和受检查异常(非运行时异常)的区别？"></a>2）非受检查异常(运行时异常)和受检查异常(非运行时异常)的区别？</h3><p><strong>区别</strong>：<strong>是否强制要求调用者必须处理此异常</strong>，如果强制要求调用者必须进行处理，那么就使用一般异常，否则就选择运行时异常。</p>
<p><strong>运行时异常</strong>：包括 RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。 Java 编译器不会检查运行时异常。例如： NullPointException(空指针) 、 NumberFormatException（字符串转换为数字） 、 IndexOutOfBoundsException(数组越界) 、 ClassCastException(类转换异常) 、ArrayStoreException(数据存储异常，操作数组时类型不一致) 等。</p>
<p><strong>非运行时异常</strong>：是Exception 中除 RuntimeException 及其子类之外的异常。 Java 编译器会检查受检查异常。常见的受检查异常有： IO 相关的异常、 ClassNotFoundException 、 SQLException 等。</p>
<h3 id="3）throw-和-throws-的区别是什么？"><a href="#3）throw-和-throws-的区别是什么？" class="headerlink" title="3）throw 和 throws 的区别是什么？"></a>3）throw 和 throws 的区别是什么？</h3><p>Java 中的异常处理除了包括捕获异常和处理异常之外，还包括声明异常和拋出异常，可以通过 throws关键字在方法上声明该方法要拋出的异常，或者在方法内部通过 throw 拋出异常对象。</p>
<p><strong>在使用上的几点区别如下</strong>：</p>
<ul>
<li><strong>throw</strong> 关键字用在方法内部，只能用于抛出一种异常，用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。</li>
<li><strong>throws</strong> 关键字用在方法声明上，可以抛出多个异常，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。</li>
</ul>
<h3 id="4）NoClassDefFoundError-和ClassNotFoundException-区别？"><a href="#4）NoClassDefFoundError-和ClassNotFoundException-区别？" class="headerlink" title="4）NoClassDefFoundError 和ClassNotFoundException 区别？"></a>4）NoClassDefFoundError 和ClassNotFoundException 区别？</h3><p><strong>NoClassDefFoundError</strong> 是一个 Error 类型的异常，是由 JVM 引起的，不应该尝试捕获这个异常。引起该异常的原因是 JVM 或 ClassLoader 尝试加载某类时在内存中找不到该类的定义，该动作发生在运行期间，即编译时该类存在，但是在运行时却找不到了，可能是变异后被删除了等原因导致。</p>
<p><strong>ClassNotFoundException</strong> 是一个受检查异常，需要显式地使用 try-catch 对其进行捕获和处理，或在方法签名中用 throws 关键字进行声明。当使用 Class.forName, ClassLoader.loadClass 或<br>ClassLoader.findSystemClass 动态加载类到内存的时候，通过传入的类路径参数没有找到该类，就会抛出该异常；另一种抛出该异常的可能原因是某个类已经由一个类加载器加载至内存中，另一个加载器又尝试去加载它。</p>
<h3 id="5）JVM是如何处理异常的？"><a href="#5）JVM是如何处理异常的？" class="headerlink" title="5）JVM是如何处理异常的？"></a>5）JVM是如何处理异常的？</h3><p>在一个方法中如果发生异常，这个方法会创建一个异常对象，并转交给 JVM，（该异常对象包含异常名称，异常描述以及异常发生时应用程序的状态）。创建异常对象并转交给 JVM 的过程称为<strong>抛出异常</strong>。可能有一系列的方法调用，最终才进入抛出异常的方法，这一系列方法调用的有序列表叫做<strong>调用栈</strong>。</p>
<p>JVM 会顺着调用栈去查找看是否有可以处理异常的代码，如果有，则调用异常处理代码。当 JVM 发现可以处理异常的代码时，会把发生的异常传递给它。如果 JVM 没有找到可以处理该异常的代码块，JVM 就会将该异常转交给默认的异常处理器（默认处理器为 JVM 的一部分），默认异常处理器打印出异常信息并终止应用程序。</p>
<h2 id="13-泛型"><a href="#13-泛型" class="headerlink" title="13. 泛型"></a>13. 泛型</h2><p>把一个对象丢进Java集合之后，集合会忘记这个对象的数据类型，再取出来时该对象就变成了Object类型。有这么两个缺点：1）每次使用时都需要强制转换成想要的类型；2）在编译时编译器并不知道类型转换是否正常，运行时才知道，不安全。</p>
<p>Java5开始，就引入了“参数化类型”的概念，允许程序在创建集合是时指定集合元素的类型，Java的参数化类型被称为“泛型”。</p>
<ul>
<li>泛型擦除：把一个具有泛型信息的对象赋给另一个没有泛型信息的变量时，所有尖括号之间的类型信息都会被扔掉。</li>
</ul>
<h2 id="14-Java反射机制"><a href="#14-Java反射机制" class="headerlink" title="14. Java反射机制"></a>14. Java反射机制</h2><p>Java程序中的对象在运行时可以表现出两种类型：编译时类型和运行时类型。</p>
<p>有时，程序在运行时接收到外部传入的一个对象，该对象编译时类型是Object，但程序又需要调用该对象的运行时类型的方法。这就要求程序需要在运行时发现对象和类的真实信息，有两个办法：</p>
<ul>
<li>第一种做法是加上在编译时和运行时都完全知道类型的具体信息，可以先使用instanceof判断，然后进行强制类型转换。</li>
<li>否则就必须要使用<strong>反射</strong>。<strong>反射赋予了我们在运行时分析类以及执行类中方法的能力。</strong>通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。<del>程序运行时，通过反射获得一个类的Clsaa对象，也可以通过反射机制生成类的动态代理对象&#x2F;类。</del></li>
</ul>
<h3 id="1）反射的应用场景："><a href="#1）反射的应用场景：" class="headerlink" title="1）反射的应用场景："></a>1）反射的应用场景：</h3><ul>
<li>JDBC时，创建数据库的连接，需要先通过反射机制加载数据库的驱动程序。</li>
<li>框架的注解&#x2F;XML配置，从配置中解析出的时字符串，需要利用反射机制实例化。</li>
<li>AOP。在运行时创建目标对象的代理类。</li>
</ul>
<h3 id="2）获取-Class-对象的四种方式"><a href="#2）获取-Class-对象的四种方式" class="headerlink" title="2）获取 Class 对象的四种方式"></a>2）获取 Class 对象的四种方式</h3><p><strong>1. 知道具体类的情况下可以使用：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass</span> <span class="operator">=</span> TargetObject.class;</span><br></pre></td></tr></table></figure>

<p>但是我们一般是不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象，通过此方式获取 Class 对象不会进行初始化</p>
<p><strong>2. 通过 <code>Class.forName()</code>传入类的全路径获取：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>3. 通过对象实例<code>instance.getClass()</code>获取：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TargetObject</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TargetObject</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass2</span> <span class="operator">=</span> o.getClass();</span><br></pre></td></tr></table></figure>

<p><strong>4. 通过类加载器<code>xxxClassLoader.loadClass()</code>传入类路径获取:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> ClassLoader.loadClass(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>通过类加载器获取 Class 对象不会进行初始化，意味着不进行包括初始化等一系列步骤，静态代码块和静态对象不会得到执行。</p>
<h2 id="15-Java的代理模式"><a href="#15-Java的代理模式" class="headerlink" title="15. Java的代理模式"></a>15. Java的代理模式</h2><p>使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</p>
<p>代理模式有<strong>静态代理</strong>和<strong>动态代理</strong>两种实现方式。</p>
<h3 id="1）静态代理"><a href="#1）静态代理" class="headerlink" title="1）静态代理"></a>1）静态代理</h3><p>从 JVM 层面来说， 静态代理在<strong>编译时</strong>就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。</p>
<p><strong>静态代理实现步骤:</strong></p>
<ol>
<li>定义一个接口及其实现类；</li>
<li>创建一个代理类同样实现这个接口</li>
<li>将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</li>
</ol>
<h3 id="2）动态代理"><a href="#2）动态代理" class="headerlink" title="2）动态代理"></a>2）动态代理</h3><p>从 JVM 角度来说，动态代理是在<strong>运行时</strong>动态生成类字节码，并加载到 JVM 中的。</p>
<h4 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="- JDK 动态代理"></a>- JDK 动态代理</h4><p>​	在 Java 动态代理机制中 <code>InvocationHandler</code> 接口和 <code>Proxy</code> 类是核心。只能代理实现了接口的类。</p>
<p><strong>步骤：</strong></p>
<ol>
<li>定义一个接口及其实现类；</li>
<li>自定义 <code>InvocationHandler</code> 并重写<code>invoke</code>方法，在 <code>invoke</code> 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；</li>
<li>通过 <code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code> 方法创建代理对象；</li>
</ol>
<h4 id="CGLIB-动态代理"><a href="#CGLIB-动态代理" class="headerlink" title="- CGLIB 动态代理"></a>- CGLIB 动态代理</h4><p>JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。</p>
<p>在 CGLIB 动态代理机制中 <code>MethodInterceptor</code> 接口和 <code>Enhancer</code> 类是核心。</p>
<p><strong>步骤：</strong></p>
<ol>
<li>定义一个类；</li>
<li>自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法，和 JDK 动态代理中的 <code>invoke</code> 方法类似；</li>
<li>通过 <code>Enhancer</code> 类的 <code>create()</code>创建代理类；</li>
</ol>
<h4 id="JDK代理和CGLib代理的区别"><a href="#JDK代理和CGLib代理的区别" class="headerlink" title="- JDK代理和CGLib代理的区别"></a>- JDK代理和CGLib代理的区别</h4><ol>
<li><strong>JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。</strong> 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</li>
<li>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</li>
</ol>
<h3 id="3）静态代理和动态代理的对比"><a href="#3）静态代理和动态代理的对比" class="headerlink" title="3）静态代理和动态代理的对比"></a>3）静态代理和动态代理的对比</h3><ol>
<li><strong>灵活性</strong> ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</li>
<li><strong>JVM 层面</strong> ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</li>
</ol>
<h2 id="16-序列化与反序列化"><a href="#16-序列化与反序列化" class="headerlink" title="16. 序列化与反序列化"></a>16. 序列化与反序列化</h2><p>序列化机制可以将对象转换成字节序列，这些字节序列可以保存在磁盘上，也可以在网络中传输，并允许程序将这些字节序列再次恢复成原来的对象。</p>
<p>对象的<strong>序列化</strong>是指 将数据结构或对象转换成二进制字节流的过程。</p>
<p>对象的<strong>反序列化</strong>是指 将在序列化过程中所生成的二进制字节流的过程转换成数据结构或者对象的过程。</p>
<p>如果对象要支持序列化机制，则它的类需要实现Serializable接口，该接口是一个标记接口，并没有提供任何方法，只是标明该类是可以序列化的。如果要实现序列化，则需要使用对象流的一些方法。</p>
<p><strong>两种序列化方式</strong>：</p>
<p><img src="E:\学习笔记\图片\Untitled.png" alt="Untitled"></p>
<p><strong>SerialVersionUID代表序列化的版本</strong>，通过定义类的序列化版本。Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。</p>
<h3 id="1）为什么要显示指定serialVersionUID的值？"><a href="#1）为什么要显示指定serialVersionUID的值？" class="headerlink" title="1）为什么要显示指定serialVersionUID的值？"></a>1）为什么要显示指定serialVersionUID的值？</h3><p>如果不显示指定serialVersionUID, JVM在序列化时会根据属性自动生成一个serialVersionUID, 然后与属性一起序列化, 再进行持久化或网络传输. 在反序列化时, JVM会再根据属性自动生成一个新版serialVersionUID, 然后将这个新版serialVersionUID与序列化时生成的旧版serialVersionUID进行比较,如果相同则反序列化成功, 否则报错。</p>
<p>如果显示指定了, JVM在序列化和反序列化时仍然都会生成一个serialVersionUID, 但值为我们显示指定的值, 这样在反序列化时新旧版本的serialVersionUID就一致了.</p>
<p><strong>在实际开发中, 不显示指定serialVersionUID的会导致什么问题?</strong> 如果我们的类写完后不再修改, 那当然不会有问题, 但这在实际开发中是不可能的, 我们的类会不断迭代, 一旦类被修改了, 那旧对象反序列化就会报错. 所以在实际开发中, 我们都会显示指定一个serialVersionUID, 值是多少无所谓, 只要不变就行。</p>
<h3 id="2）Java序列化中如果有的字段不想进行序列化，怎么办？"><a href="#2）Java序列化中如果有的字段不想进行序列化，怎么办？" class="headerlink" title="2）Java序列化中如果有的字段不想进行序列化，怎么办？"></a>2）Java序列化中如果有的字段不想进行序列化，怎么办？</h3><p>对于不想进行序列化的变量，使用 <strong>transient</strong> 关键字修饰。<br>transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后， transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。transient 只能修饰变量，不能修饰类和方法。</p>
<h3 id="3）静态变量会被序列化吗"><a href="#3）静态变量会被序列化吗" class="headerlink" title="3）静态变量会被序列化吗?"></a>3）静态变量会被序列化吗?</h3><p><strong>不会</strong>。因为<strong>序列化是针对对象</strong>而言的, 而静态变量优先于对象存在, 随着类的加载而加载, 所以不会被序列化。<br>看到这个结论, 是不是有人会问, **serialVersionUID也被static修饰, 为什么serialVersionUID会被序列化?**其实serialVersionUID属性并没有被序列化, JVM在序列化对象时会自动生成一个serialVersionUID, 然后将我们显示指定的serialVersionUID属性值赋给自动生成的serialVersionUID。</p>
<h3 id="4）实际开发中有哪些用到序列化和反序列化的场景？"><a href="#4）实际开发中有哪些用到序列化和反序列化的场景？" class="headerlink" title="4）实际开发中有哪些用到序列化和反序列化的场景？"></a>4）实际开发中有哪些用到序列化和反序列化的场景？</h3><ul>
<li><p>对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</p>
</li>
<li><p>将对象存储到文件中的时候需要进行序列化，将对象从文件中读取出来需要进行反序列化。</p>
</li>
<li><p>将对象存储到缓存数据库（如 Redis）时需要用到序列化，将对象从缓存数据库中读取出来需要反序列化</p>
</li>
</ul>
<h2 id="17-Java-中-IO-流"><a href="#17-Java-中-IO-流" class="headerlink" title="17. Java 中 IO 流"></a>17. Java 中 IO 流</h2><ul>
<li><p>分类</p>
<ul>
<li><p>按照流的流向分，可以分为输入流和输出流；</p>
</li>
<li><p>按照操作单元划分，可以划分为字节流和字符流；</p>
</li>
<li><p>按照流的角色划分为节点流和处理流。</p>
</li>
</ul>
</li>
<li><p>Java IO 流的 40 多个类都是从4 个抽象类基类中派生出来的。</p>
<ul>
<li>InputStream &#x2F; Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li>OutputStream &#x2F; Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
</li>
</ul>
<h3 id="既然有了字节流-为什么还要有字符流"><a href="#既然有了字节流-为什么还要有字符流" class="headerlink" title="既然有了字节流,为什么还要有字符流?"></a>既然有了字节流,为什么还要有字符流?</h3><p><del>（问题本质想问：<strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I&#x2F;O 流操作要分为字节流操作和字符流操作呢？</strong>）</del></p>
<p><strong>回答</strong>：字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I&#x2F;O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p>
<p><strong>按操作方式分类结构图：</strong></p>
<p><img src="E:\学习笔记\图片\IO-操作方式分类.png" alt="IO-操作方式分类"></p>
<p>按操作对象分类结构图：</p>
<p><img src="E:\学习笔记\图片\IO-操作对象分类.png" alt="IO-操作对象分类"></p>
<h2 id="18-String类有哪些方法？"><a href="#18-String类有哪些方法？" class="headerlink" title="18. String类有哪些方法？"></a>18. String类有哪些方法？</h2><ul>
<li>char charAt(int index)：返回指定索引处的字符；</li>
<li>String substring(int beginIndex, int endIndex)：从此字符串中截取出一部分子字符串；</li>
<li>String[] split(String regex)：以指定的规则将此字符串分割成数组；</li>
<li>String trim()：删除字符串前导和后置的空格；</li>
<li>int indexOf(String str)：返回子串在此字符串首次出现的索引；</li>
<li>int lastIndexOf(String str)：返回子串在此字符串最后出现的索引；</li>
<li>boolean startsWith(String prefix)：判断此字符串是否以指定的前缀开头；</li>
<li>boolean endsWith(String suffix)：判断此字符串是否以指定的后缀结尾；</li>
<li>String toUpperCase()：将此字符串中所有的字符大写；</li>
<li>String toLowerCase()：将此字符串中所有的字符小写；</li>
<li>String replaceFirst(String regex, String replacement)：用指定字符串替换第一个匹配的子串；</li>
<li>String replaceAll(String regex, String replacement)：用指定字符串替换所有的匹配的子串。</li>
</ul>
<h3 id="String可以被继承吗？"><a href="#String可以被继承吗？" class="headerlink" title="String可以被继承吗？"></a>String可以被继承吗？</h3><p>String类由final修饰，所以不能被继承。</p>
<p>在Java中，String类被设计为不可变类，主要表现在它保存字符串的成员变量是final的。</p>
<ul>
<li>Java 9之前字符串采用char[]数组来保存字符，即 private final char[] value；</li>
<li>Java 9做了改进，采用byte[]数组来保存字符，即 private final byte[] value；</li>
</ul>
<p>之所以要把String类设计为不可变类，主要是出于安全和性能的考虑，可归纳为如下4点。</p>
<ul>
<li>由于字符串无论在任何 Java 系统中都广泛使用，会用来存储敏感信息，如账号，密码，网络路径，文件处理等场景里，保证字符串 String 类的安全性就尤为重要了，如果字符串是可变的，容易被篡改，那我们就无法保证使用字符串进行操作时，它是安全的，很有可能出现 SQL 注入，访问危险文件等操作。</li>
<li>在多线程中，只有不变的对象和值是线程安全的，可以在多个线程中共享数据。由于 String 天然的不可变，当一个线程”修改“了字符串的值，只会产生一个新的字符串对象，不会对其他线程的访问产生副作用，访问的都是同样的字符串数据，不需要任何同步操作。</li>
<li>字符串作为基础的数据结构，大量地应用在一些集合容器之中，尤其是一些散列集合，在散列集合中，存放元素都要根据对象的 hashCode() 方法来确定元素的位置。由于字符串 hashcode 属性不会变更，保证了唯一性，使得类似 HashMap，HashSet 等容器才能实现相应的缓存功能。由于 String 的不可变，避免重复计算 hashcode，只要使用缓存的 hashcode 即可，这样一来大大提高了在散列集合中使用 String 对象的性能。</li>
<li>当字符串不可变时，字符串常量池才有意义。字符串常量池的出现，可以减少创建相同字面量的字符串，让不同的引用指向池中同一个字符串，为运行时节约很多的堆内存。若字符串可变，字符串常量池失去意义，基于常量池的 String.intern() 方法也失效，每次创建新的字符串将在堆内开辟出新的空间，占据更多的内存。</li>
</ul>
<p>因为要保证String类的不可变，那么将这个类定义为final的就很容易理解了。如果没有final修饰，那么就会存在String的子类，这些子类可以重写String类的方法，强行改变字符串的值，这便违背了String类设计的初衷。</p>
<h2 id="19-深拷贝、浅拷贝、引用拷贝？"><a href="#19-深拷贝、浅拷贝、引用拷贝？" class="headerlink" title="19. 深拷贝、浅拷贝、引用拷贝？"></a>19. 深拷贝、浅拷贝、引用拷贝？</h2><ul>
<li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说<strong>拷贝对象和原对象共用同一个内部对象</strong>。</li>
<li><strong>深拷贝</strong> ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。拷贝对象和原对象已经不是同一个对象。</li>
<li><strong>引用拷贝</strong>：引用拷贝就是两个不同的引用指向同一个对象。</li>
</ul>
<img src="E:/面试/myJava.assets/image-20220505234633568.png" alt="image-20220505234633568" style="zoom:50%;" />

<h3 id="碰到的具体例子"><a href="#碰到的具体例子" class="headerlink" title="碰到的具体例子"></a>碰到的具体例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lists.add(list)和lists.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>＜＞(list))</span><br><span class="line">res.add(list)为浅拷贝，res中添加的都是list这个内存地址的引用，后续list内容的变化会导致res的变化，在原来地址改变数据，内容肯定会被改变</span><br><span class="line">res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(list))为深拷贝，每次添加lisi，都为list对象开辟一个新地址，存放的内容为list链表，所以后续不会被影响。    </span><br></pre></td></tr></table></figure>



<h2 id="20-面向对象的原则"><a href="#20-面向对象的原则" class="headerlink" title="20.面向对象的原则"></a>20.面向对象的原则</h2><p>单一职责原则（SRP） 、开放封闭原则（OCP）  、里氏替换原则（LSP）、  依赖倒置原则（DIP）、  接口隔离原则（ISP）、迪米特法则（Law Of Demeter）、组合&#x2F;聚合复用原则（Composite&#x2F;Aggregate Reuse Principle CARP）</p>
<p><strong>1. 单一职责原则（Single Responsibility Principle）</strong></p>
<p>每一个类应该专注于做一件事情。可以降低类的复杂度，一个类只负责一项职责。</p>
<p><strong>2. 里氏替换原则（Liskov Substitution Principle）</strong></p>
<p>超类存在的地方，子类是可以替换的。在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</p>
<p>使用里氏替换原则时需要注意，子类必须实现父类中声明的所有方法。尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。</p>
<p>从大局看Java的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%A4%9A%E6%80%81&spm=1001.2101.3001.7020">多态</a>就属于这个原则。</p>
<p><strong>3. 依赖倒置原则（Dependence Inversion Principle）</strong></p>
<p>实现尽量依赖抽象，不依赖具体实现。具体依赖抽象，上层依赖下层。假设B是较A低的模块，但B需要使用到A的功能，这个时候，B不应当直接使用A中的具体类；而应当由B定义一抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口；这样就达到了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。</p>
<p>采用<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99&spm=1001.2101.3001.7020">依赖倒置原则</a>可以减少类间的耦合性，提高系统的稳定性，减少并行开发引起的风险，提高代码的可读性和可维护性。</p>
<p>从大局看Java的多态就属于这个原则。</p>
<p><strong>4. 接口隔离原则（Interface Segregation Principle）</strong></p>
<p>应当为客户端提供尽可能小的单独的接口，而不是提供大的总的接口。也就是要为各个类建立专用的接口，否则类在实现接口时，会实现一些用不到的方法。</p>
<p><strong>5. 迪米特法则（Law Of Demeter）</strong></p>
<p>又叫最少知识原则，一个软件实体应当尽可能少的与其他实体发生相互作用。在一个类里，能少用多少其他类就少用多少。</p>
<p><strong>6. 开闭原则（Open Close Principle）</strong></p>
<p>面向扩展开放，面向修改关闭。意味着有新的需求或变化时，不需要修改源代码，可以对现有代码进行扩展，以适应新的情况。</p>
<p><strong>7. 组合&#x2F;聚合复用原则（Composite&#x2F;Aggregate Reuse Principle CARP）</strong></p>
<p>尽量使用合成&#x2F;聚合达到复用，尽量少用继承。原则： 一个类中有另一个类的对象。</p>
<h2 id="21-子类能否可以重写父类中的静态方法"><a href="#21-子类能否可以重写父类中的静态方法" class="headerlink" title="21.子类能否可以重写父类中的静态方法"></a>21.子类能否可以重写父类中的静态方法</h2><p>不可以，子类重写的方法不会覆盖父类的方法，二者之间仍然独立。</p>
<p>Fu a &#x3D; new Zi();</p>
<p>通过a调用的方法还是父类的方法。</p>
<p>静态方法属于类，在编译阶段类被加载时，类的静态方法或者属性就会被分配内存，存储到类所在的内存中（堆内存的方法区中）；而类的非静态方法却是属于对象的，每个对象都有一份非静态方法的引用，并且若方法被重写，引用的就是子类重写的方法，且这是在运行时创建；</p>
<p>因此：</p>
<p><strong>一个父类的变量，指向子类的对象，调用一个被子类重写的静态方法时，由于这是一个父类的变量，并且静态方法属于类，所以在调用时，JVM会去父类所在的内存中寻找这个方法，所以最终的结果就是调用父类的方法，而不是子类重写的方法。</strong></p>
<h2 id="22-I-x2F-O"><a href="#22-I-x2F-O" class="headerlink" title="22.I&#x2F;O"></a>22.I&#x2F;O</h2><h3 id="1-何为-I-x2F-O"><a href="#1-何为-I-x2F-O" class="headerlink" title="1.何为 I&#x2F;O?"></a>1.何为 I&#x2F;O?</h3><p>I&#x2F;O（<strong>I</strong>nput&#x2F;<strong>O</strong>utpu） 即<strong>输入／输出</strong> 。</p>
<p><strong>我们先从计算机结构的角度来解读一下 I&#x2F;O。</strong></p>
<p>根据冯.诺依曼结构，计算机结构分为 5 大部分：运算器、控制器、存储器、输入设备、输出设备。</p>
<p><img src="E:\学习笔记\图片\20190624122126398.jpeg" alt="冯诺依曼体系结构"></p>
<p>输入设备（比如键盘）和输出设备（比如显示器）都属于外部设备。网卡、硬盘这种既可以属于输入设备，也可以属于输出设备。</p>
<p>输入设备向计算机输入数据，输出设备接收计算机输出的数据。</p>
<p><strong>从计算机结构的视角来看的话， I&#x2F;O 描述了计算机系统与外部设备之间通信的过程。</strong></p>
<p><strong>我们再先从应用程序的角度来解读一下 I&#x2F;O。</strong></p>
<p>根据大学里学到的操作系统相关的知识：为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 <strong>用户空间（User space）</strong> 和 <strong>内核空间（Kernel space ）</strong> 。</p>
<p>像我们平常运行的应用程序都是运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如文件管理、进程通信、内存管理等等。也就是说，我们想要进行 IO 操作，一定是要依赖内核空间的能力。</p>
<p>并且，用户空间的程序不能直接访问内核空间。</p>
<p>当想要执行 IO 操作时，由于没有执行这些操作的权限，只能发起系统调用请求操作系统帮忙完成。</p>
<p>因此，用户进程想要执行 IO 操作的话，必须通过 <strong>系统调用</strong> 来间接访问内核空间</p>
<p>我们在平常开发过程中接触最多的就是 <strong>磁盘 IO（读写文件）</strong> 和 <strong>网络 IO（网络请求和响应）</strong>。</p>
<p><strong>从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。</strong></p>
<p>当应用程序发起 I&#x2F;O 调用后，会经历两个步骤：</p>
<ol>
<li>内核等待 I&#x2F;O 设备准备好数据</li>
<li>内核将数据从内核空间拷贝到用户空间。</li>
</ol>
<h3 id="Java-中-3-种常见-IO-模型"><a href="#Java-中-3-种常见-IO-模型" class="headerlink" title="Java 中 3 种常见 IO 模型"></a>Java 中 3 种常见 IO 模型</h3><h3 id="BIO-Blocking-I-x2F-O"><a href="#BIO-Blocking-I-x2F-O" class="headerlink" title="BIO (Blocking I&#x2F;O)"></a>BIO (Blocking I&#x2F;O)</h3><p><strong>BIO 属于同步阻塞 IO 模型</strong> 。</p>
<p>同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。</p>
<p><img src="E:\学习笔记\图片\6a9e704af49b4380bb686f0c96d33b81_tplv-k3u1fbpfcp-watermark.image" alt="图源：《深入拆解Tomcat &amp; Jetty》"></p>
<p>在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I&#x2F;O 处理模型来应对更高的并发量。</p>
<h3 id="NIO-Non-blocking-x2F-New-I-x2F-O"><a href="#NIO-Non-blocking-x2F-New-I-x2F-O" class="headerlink" title="NIO (Non-blocking&#x2F;New I&#x2F;O)"></a>NIO (Non-blocking&#x2F;New I&#x2F;O)</h3><p>Java 中的 NIO 于 Java 1.4 中引入，对应 <code>java.nio</code> 包，提供了 <code>Channel</code> , <code>Selector</code>，<code>Buffer</code> 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它是支持面向缓冲的，基于通道的 I&#x2F;O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。</p>
<p>Java 中的 NIO 可以看作是 <strong>I&#x2F;O 多路复用模型</strong>。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。</p>
<p><strong>同步非阻塞 IO 模型</strong>。</p>
<p><img src="E:\学习笔记\图片\bb174e22dbe04bb79fe3fc126aed0c61_tplv-k3u1fbpfcp-watermark.image" alt="图源：《深入拆解Tomcat &amp; Jetty》"></p>
<p>同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</p>
<p>相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。</p>
<p>但是，这种 IO 模型同样存在问题：<strong>应用程序不断进行 I&#x2F;O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</strong></p>
<p>这个时候，<strong>I&#x2F;O 多路复用模型</strong> 就上场了。</p>
<p><img src="E:\学习笔记\图片\88ff862764024c3b8567367df11df6ab_tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
<p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -&gt; 用户空间）还是阻塞的。</p>
<blockquote>
<p>目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，目前几乎在所有的操作系统上都有支持。</p>
<ul>
<li><strong>select 调用</strong> ：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。</li>
<li><strong>epoll 调用</strong> ：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。</li>
</ul>
</blockquote>
<p><strong>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。</strong></p>
<p>Java 中的 NIO ，有一个非常重要的<strong>选择器 ( Selector )</strong> 的概念，也可以被称为 <strong>多路复用器</strong>。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。</p>
<h3 id="AIO-Asynchronous-I-x2F-O"><a href="#AIO-Asynchronous-I-x2F-O" class="headerlink" title="AIO (Asynchronous I&#x2F;O)"></a>AIO (Asynchronous I&#x2F;O)</h3><p>AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。</p>
<p>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p>
<p><img src="E:\学习笔记\图片\3077e72a1af049559e81d18205b56fd7_tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
<p>总结</p>
<p><img src="E:\学习笔记\图片\33b193457c928ae02217480f994814b6.png" alt="img"></p>
<h2 id="23-NIO的零拷贝"><a href="#23-NIO的零拷贝" class="headerlink" title="23.NIO的零拷贝"></a>23.NIO的零拷贝</h2><h2 id="传统IO"><a href="#传统IO" class="headerlink" title="传统IO"></a>传统IO</h2><p>传统IO读取数据并通过网络发送的流程，如下图</p>
<p><img src="E:\学习笔记\图片\640.jfif" alt="图片"></p>
<p>磁盘到内核空间属于DMA拷贝，用户空间与内核空间之间的数据传输并没有类似DMA这种可以不需要CPU参与的传输方式，因此用户空间与内核空间之间的数据传输是需要CPU全程参与的。</p>
<ol>
<li>read()调用导致上下文从用<strong>户态切换到内核态</strong>。内核通过sys_read()（或等价的方法）从文件读取数据。DMA引擎执行第一次拷贝：<strong>从文件读取数据并存储到内核空间的缓冲区</strong>。（<strong>第一次上下文切换和拷贝</strong>）</li>
<li>请求的数据<strong>从内核的读缓冲区拷贝到用户缓冲区</strong>，然后read()方法返回。read()方法返回导致上下文从<strong>内核态切换到用户态</strong>。现在待读取的数据已经存储在用户空间内的缓冲区。至此，完成了一次IO的读取过程。（<strong>第二次上下文切换和拷贝</strong>）</li>
<li>send()调用导致上下文从<strong>用户态切换到内核态</strong>。第三次拷贝数据从<strong>用户空间重新拷贝到内核空间缓冲区</strong>。但是，这一次，数据被写入一个不同的缓冲区，一个与目标套接字相关联的缓冲区。（<strong>第三次上下文切换和拷贝</strong>）</li>
<li>send()系统调用返回导致第四次上下文切换。当DMA引擎将数据<strong>从内核缓冲区传输到协议引擎缓冲区</strong>时，第四次拷贝是独立且异步的。（<strong>第四次上下文切换和拷贝</strong>）</li>
</ol>
<h2 id="NIO的零拷贝"><a href="#NIO的零拷贝" class="headerlink" title="NIO的零拷贝"></a>NIO的零拷贝</h2><p>NIO的零拷贝由transferTo方法实现。transferTo方法将数据从FileChannel对象传送到可写的字节通道（如Socket Channel等）。在transferTo方法内部实现中，由native方法transferTo0来实现，它依赖底层操作系统的支持。在UNIX和Linux系统中，调用这个方法会引起sendfile()系统调用，实现了数据直接从内核的读缓冲区传输到套接字缓冲区，避免了用户态(User-space) 与内核态(Kernel-space) 之间的数据拷贝。</p>
<p><img src="E:\学习笔记\图片\640-1663641836963.jfif" alt="图片"></p>
<p>使用NIO零拷贝，流程简化为两步：</p>
<ol>
<li>transferTo方法调用触发DMA引擎将文件上下文信息拷贝到内核读缓冲区，接着内核将数据从内核缓冲区拷贝到与套接字相关联的缓冲区。</li>
<li>DMA引擎将数据从内核套接字缓冲区传输到协议引擎（第三次数据拷贝）。</li>
</ol>
<p>相比传统IO，使用NIO零拷贝后改进的地方：</p>
<ol>
<li>将上下文切换次数从4次减少到了2次；</li>
<li>将数据拷贝次数从4次减少到了3次（其中只有1次涉及了CPU，另外2次是DMA直接存取）。</li>
</ol>
<h2 id="24-this和super的区别"><a href="#24-this和super的区别" class="headerlink" title="24.this和super的区别"></a>24.this和super的区别</h2><p>1、super()主要是对父类构造函数的调用，this()是对重载构造函数的调用<br>2、super()主要是在子类中调用父类的构造方法，在不同的类中使用；this()主要是在同一类中调用其他方法</p>
<p>3.this()和super()不能出现在同一个构造函数中</p>
<p>相同点：<br>1、super()和this()都必须在构造函数的第一行进行调用，否则就是错误的</p>
<p>2.this()和super()都指的是对象，不可以在static环境中使用，包括static变量、方法、代码块。</p>
<h2 id="25-Java8新特性"><a href="#25-Java8新特性" class="headerlink" title="25.Java8新特性"></a>25.Java8新特性</h2><h3 id="1-lambda表达式"><a href="#1-lambda表达式" class="headerlink" title="1.lambda表达式"></a>1.lambda表达式</h3><p>Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）</p>
<h3 id="2-函数式接口"><a href="#2-函数式接口" class="headerlink" title="2.函数式接口"></a>2.函数式接口</h3><p>指的是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口，这样的接口可以隐式转换为 Lambda 表达式</p>
<h3 id="3-方法引用"><a href="#3-方法引用" class="headerlink" title="3.方法引用"></a>3.方法引用</h3><p>可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用</p>
<h3 id="4-默认方法"><a href="#4-默认方法" class="headerlink" title="4.默认方法"></a>4.默认方法</h3><p>默认方法就是一个在接口里面有了一个实现的方法</p>
<h3 id="5-Stream-API"><a href="#5-Stream-API" class="headerlink" title="5.Stream API"></a>5.Stream API</h3><p>对数据集合进行操作。</p>
<p>注意点：</p>
<p>（1）、Stream自己不会存储元素。</p>
<p>（2）、Stream不会改变源对象。相反，他们会返回一个持有结果的新Stream。</p>
<p>（3）、Stream操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</p>
<p> skip(n) ——跳过元素，返回一个扔掉了前 n 个元素的流。</p>
<p>distinct——筛选，去除重复</p>
<p>map-接收Lambda，将元素转换成其他形式或提取信息。接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</p>
<p>sorted()—自然排序（Comparable）</p>
<h3 id="6-Optional类"><a href="#6-Optional类" class="headerlink" title="6.Optional类"></a>6.Optional类</h3><p>Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。</p>
<h3 id="7-Date-TimeAPI"><a href="#7-Date-TimeAPI" class="headerlink" title="7.Date TimeAPI"></a>7.<strong>Date TimeAPI</strong></h3><p>加强对日期与时间的处理。</p>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="1-Java集合框架图"><a href="#1-Java集合框架图" class="headerlink" title="1.Java集合框架图"></a>1.Java集合框架图</h2><p>![Untitled](E:\学习笔记\图片\Untitled 2.png)</p>
<h2 id="2-HashMap"><a href="#2-HashMap" class="headerlink" title="2.HashMap"></a>2.HashMap</h2><h3 id="HashMap的底层数据结构"><a href="#HashMap的底层数据结构" class="headerlink" title="HashMap的底层数据结构"></a>HashMap的底层数据结构</h3><p>JDK1.7中，由“<strong>数组+链表</strong>”组成，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。</p>
<p>在JDK1.8 中，由“<strong>数组+链表+红黑树</strong>”组成。当链表过长，则会严重影响 HashMap 的性能，红黑树搜索时间复杂度是 O(logn)，而链表是糟糕的 O(n)。因此，JDK1.8 对数据结构做了进一步的优化，引入了红黑树，链表和红黑树在达到一定条件会进行转换：</p>
<ul>
<li>当链表超过 8 且数组大小超过 64 才会转红黑树。</li>
<li>将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树，以减少搜索时间。</li>
</ul>
<h3 id="HashMap的put流程"><a href="#HashMap的put流程" class="headerlink" title="HashMap的put流程"></a>HashMap的put流程</h3><ul>
<li>首先根据 key 的值计算 hash 值，找到该元素在数组中存储的下标；</li>
<li>如果数组是空的，则调用 resize 进行初始化；</li>
<li>如果没有哈希冲突直接放在对应的数组下标里；</li>
<li>如果冲突了，且 key 已经存在，就覆盖掉 value；</li>
<li>如果冲突后，发现该节点是红黑树，就将这个节点挂在树上；</li>
<li>如果冲突后是链表，判断该链表是否大于 8 ，如果大于 8 并且数组容量小于 64，就进行扩容；如果链表节点大于 8 并且数组的容量大于 64，则将这个结构转换为红黑树；否则，链表插入键值对，若 key 存在，就覆盖掉 value。</li>
</ul>
<h3 id="HashMap为什么用红黑树不用B树？"><a href="#HashMap为什么用红黑树不用B树？" class="headerlink" title="HashMap为什么用红黑树不用B树？"></a>HashMap为什么用红黑树不用B树？</h3><p>如果用B&#x2F;B+树的话，在数据量不多的情况下，数据都会“挤在”一个节点里面，这样就退化成了链表。</p>
<h3 id="为什么不直接用红黑树，而是先选择用链表？"><a href="#为什么不直接用红黑树，而是先选择用链表？" class="headerlink" title="为什么不直接用红黑树，而是先选择用链表？"></a>为什么不直接用红黑树，而是先选择用链表？</h3><p>因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡，而单链表不需要。当元素小于 8 个的时候，此时做查询操作，链表结构已经能保证查询性能。当元素大于 8 个的时候， 红黑树搜索时间复杂度是 O(logn)，而链表是 O(n)，此时需要红黑树来加快查询速度，但是新增节点的效率变慢了。</p>
<p>因此，如果一开始就用红黑树结构，元素太少，新增效率又比较慢，无疑这是浪费性能的。</p>
<h3 id="为什么不用平衡二叉树"><a href="#为什么不用平衡二叉树" class="headerlink" title="为什么不用平衡二叉树"></a>为什么不用平衡二叉树</h3><p>红黑树的插入和删除，旋转操作最多三次就可以完成，而平衡树可能需要logN，且红黑树不要严格的的平衡，可能引发更少的旋转操作。</p>
<h3 id="HashMap为什么线程不安全？"><a href="#HashMap为什么线程不安全？" class="headerlink" title="HashMap为什么线程不安全？"></a>HashMap为什么线程不安全？</h3><ul>
<li><p><strong>1）多线程下扩容死循环</strong>。<strong>JDK1.7</strong>中的 HashMap 使用<strong>头插法</strong>插入元素，在多线程的环境下，扩容的时候有可能导致<strong>环形链表</strong>的出现，形成死循环。因此，JDK1.8使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题。</p>
<ul>
<li>在多线程的情况下，当重新调整HashMap大小的时候，就会存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历。如果条件竞争发生了，那么就会产生死循环了。</li>
</ul>
</li>
<li><p><strong>2）多线程的put可能导致元素的丢失</strong>。多线程同时执行 put 操作，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失。此问题在JDK 1.7和 JDK 1.8 中都存在。</p>
</li>
<li><p><strong>3）put和get并发时，可能导致get为null</strong>。线程1执行put时，因为元素个数超出hreshold而导致rehash，线程2此时执行get，有可能导致这个问题。此问题在JDK 1.7和 JDK 1.8 中都存在。</p>
</li>
</ul>
<h3 id="HashMap的扩容方式"><a href="#HashMap的扩容方式" class="headerlink" title="HashMap的扩容方式"></a>HashMap的扩容方式</h3><p>HashMap 在容量超过负载因子所定义的容量之后，就会扩容。Java 里的数组是无法自动扩容的，方法是<strong>将 HashMap 的大小扩大为原来数组的两倍</strong>，并将原来的对象放入新的数组中。</p>
<p>扩容之后，JDK1.7需要重新计算索引；而JDK1.8不需要像 JDK1.7 的实现那样重新计算hash，只需要看看原来的 hash 值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引 + oldCap ”。</p>
<p>JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置（头插法）。JDK1.8不会倒置，使用尾插法。</p>
<ol>
<li>数组的初始容量为16，而容量是以2的次方扩充的，一是为了提高性能使用足够大的数组，二是为了能使用位运算代替取模预算(据说提升了5~8倍)。</li>
<li>数组是否需要扩充是通过负载因子判断的，如果当前元素个数为数组容量的0.75时，就会扩充数组。这个0.75就是默认的负载因子，可由构造器传入。我们也可以设置大于1的负载因子，这样数组就不会扩充，牺牲性能，节省内存。</li>
<li>为了解决碰撞，数组中的元素是单向链表类型。当链表长度到达一个阈值时（7或8），会将链表转换成红黑树提高性能。而当链表长度缩小到另一个阈值时（6），又会将红黑树转换回单向链表提高性能。</li>
<li>对于第三点补充说明，检查链表长度转换成红黑树之前，还会先检测当前数组数组是否到达一个阈值（64），如果没有到达这个容量，会放弃转换，先去扩充数组。所以上面也说了链表长度的阈值是7或8，因为会有一次放弃转换的操作。</li>
</ol>
<h3 id="HashMap-的长度为什么是-2-的幂次方"><a href="#HashMap-的长度为什么是-2-的幂次方" class="headerlink" title="HashMap 的长度为什么是 2 的幂次方"></a>HashMap 的长度为什么是 2 的幂次方</h3><p>“取余(%)操作中如果<strong>除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作</strong>（也就是说 hash%length&#x3D;&#x3D;hash&amp;(length-1)的前提是 length 是 2 的 n 次方；）。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率。</p>
<h3 id="HashMap-中-key-的存储索引的计算方式"><a href="#HashMap-中-key-的存储索引的计算方式" class="headerlink" title="HashMap 中 key 的存储索引的计算方式"></a>HashMap 中 key 的存储索引的计算方式</h3><p>取key的 hashCode 值、根据 hashcode 计算出hash值、通过取模计算下标。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK 1.8</span></span><br><span class="line"><span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<h3 id="一般用什么作为HashMap的Key"><a href="#一般用什么作为HashMap的Key" class="headerlink" title="一般用什么作为HashMap的Key?"></a>一般用什么作为HashMap的Key?</h3><p>一般用Integer、String 这种不可变类当 HashMap 当 key，而且 String 最为常用。</p>
<ul>
<li>因为字符串是不可变的，所以在它创建的时候 hashcode 就被缓存了，不需要重新计算。这就是HashMap 中的键往往都使用字符串的原因。</li>
<li>因为获取对象的时候要用到 equals() 和 hashCode() 方法，那么键对象正确的重写这两个方法是非常重要的,这些类已经很规范的重写了 hashCode() 以及 equals() 方法。</li>
</ul>
<h2 id="3-HashMap和HashTable的区别？"><a href="#3-HashMap和HashTable的区别？" class="headerlink" title="3.HashMap和HashTable的区别？"></a>3.HashMap和HashTable的区别？</h2><ol>
<li><strong>线程是否安全：</strong> <code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,因为 <code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）；</li>
<li><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰，不要在代码中使用它；</li>
<li><strong>对 Null key 和 Null value 的支持：</strong> <code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。</li>
<li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ① 创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</li>
<li><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li>
</ol>
<h3 id="HashMap-和-HashSet-区别"><a href="#HashMap-和-HashSet-区别" class="headerlink" title="HashMap 和 HashSet 区别"></a>HashMap 和 HashSet 区别</h3><p><code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的。（<code>HashSet</code> 的源码非常非常少，因为除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code>是 <code>HashSet</code> 自己不得不实现之外，其他方法都是直接调用 <code>HashMap</code> 中的方法。</p>
<img src="E:/面试/myJava.assets/image-20220504020551691.png" alt="image-20220504020551691" style="zoom:40%;" />

<h3 id="HashMap-和-TreeMap-区别"><a href="#HashMap-和-TreeMap-区别" class="headerlink" title="HashMap 和 TreeMap 区别"></a>HashMap 和 TreeMap 区别</h3><p><code>TreeMap</code> 和<code>HashMap</code> 都继承自<code>AbstractMap</code> ，</p>
<p>但是<code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code> 接口。</p>
<ul>
<li>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力。</li>
<li>实现<code>SortedMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。</li>
</ul>
<p><strong>相比于<code>HashMap</code>来说 <code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</strong></p>
<h3 id="HashSet-如何检查重复"><a href="#HashSet-如何检查重复" class="headerlink" title="HashSet 如何检查重复"></a>HashSet 如何检查重复</h3><p>当你把对象加入<code>HashSet</code>时，<code>HashSet</code> 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code>相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p>
<h2 id="4-ConcurrentHashMap的实现"><a href="#4-ConcurrentHashMap的实现" class="headerlink" title="4. ConcurrentHashMap的实现"></a>4. ConcurrentHashMap的实现</h2><p>JDK1.7是 <strong>Segment数据结构</strong>和<strong>HashEntry数组结构</strong>组成<strong>。采用分段锁保证安全性。</strong></p>
<ul>
<li><p>ConcurrentHashMap是由 Segment 数组结构和 HashEntry 数组结构（数组+链表实现）组成，即ConcurrentHashMap 把哈希桶切分成小数组（Segment ），每个小数组有 n 个HashEntry 组成。</p>
</li>
<li><p>ConcurrentHashMap有3个参数：</p>
<ol>
<li>initialCapacity：初始总容量，默认16</li>
<li>loadFactor：加载因子，默认0.75</li>
<li>concurrencyLevel：并发级别，默认16</li>
</ol>
<p><strong>其中并发级别控制了Segment的个数，在一个ConcurrentHashMap创建后Segment的个数是不能变的，扩容过程过改变的是每个Segment的大小。</strong></p>
</li>
<li><p>Segment 继承了 ReentrantLock，所以 Segment 是一种可重入锁，扮演锁的角色；HashEntry用于存储键值对数据。</p>
<p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问，能够实现真正的并发访问。</p>
</li>
</ul>
<img src="E:/面试/myJava.assets/image-20220504030830009.png" alt="image-20220504030830009" style="zoom:33%;" />

<p>JDK1.8中，摒弃了Segment的概念，直接用<strong>Node数组+链表+红黑树</strong>。并发控制使用Synchronized和CAS实现更加低粒度的锁。将锁的级别控制在了更细粒度的哈希桶元素级别，也就是说只需要锁住这个链表头结点（红黑树的根节点），就不会影响其他的哈希桶元素的读写，大大提高了并发度。</p>
<img src="E:/面试/myJava.assets/image-20220504030905643.png" alt="image-20220504030905643" style="zoom:33%;" />

<h3 id="为什么JDK1-8要弃用segment"><a href="#为什么JDK1-8要弃用segment" class="headerlink" title="为什么JDK1.8要弃用segment"></a>为什么JDK1.8要弃用segment</h3><p><strong>1. 锁的粒度</strong><br>首先锁的粒度并没有变粗，甚至变得更细了。每当扩容一次，ConcurrentHashMap的并发度就扩大一倍，而1.7中，并发数由segment个数决定，一旦确定就不改变。<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升。<br><strong>2. Hash冲突</strong><br>JDK1.7中，ConcurrentHashMap通过二次hash的方式（Segment -&gt; HashEntry）能够快速的找到查找的元素。在1.8中通过链表加红黑树的形式弥补了put、get时的性能差距。<br><strong>3. 扩容</strong><br>JDK1.8中，在ConcurrentHashmap进行扩容时，其他线程可以通过检测数组中的节点决定是否对这条链表（红黑树）进行扩容，减小了扩容的粒度，提高了扩容的效率。</p>
<h3 id="为什么是synchronized，而不是可重入锁"><a href="#为什么是synchronized，而不是可重入锁" class="headerlink" title="为什么是synchronized，而不是可重入锁"></a>为什么是synchronized，而不是可重入锁</h3><p><strong>1. 减少内存开销</strong><br>假设使用可重入锁来获得同步支持，那么每个节点都需要通过继承AQS来获得同步支持。但并不是每个节点都需要获得同步支持的，只有链表的头节点（红黑树的根节点）需要同步，这无疑带来了巨大内存浪费。<br><strong>2. 获得JVM的支持</strong><br>可重入锁毕竟是API这个级别的，后续的性能优化空间很小。<br>synchronized则是JVM直接支持的，JVM能够在运行时作出相应的优化措施：锁粗化、锁消除、锁自旋等等。这就使得synchronized能够随着JDK版本的升级而不改动代码的前提下获得性能上的提升。</p>
<h3 id="ConcurrentHashMap-的-put-方法执行逻辑是什么？"><a href="#ConcurrentHashMap-的-put-方法执行逻辑是什么？" class="headerlink" title="ConcurrentHashMap 的 put 方法执行逻辑是什么？"></a>ConcurrentHashMap 的 put 方法执行逻辑是什么？</h3><p><strong>JDK1.7</strong>。首先，会尝试获取锁，如果获取失败，利用自旋获取锁；如果自旋重试的次数超过 64 次，则改为阻塞获取锁。获取到锁后：</p>
<ul>
<li>1 将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry。</li>
<li>2 遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的value。</li>
<li>3 不为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容。</li>
<li>4 释放 Segment 的锁。</li>
</ul>
<p><strong>JDK1.8</strong>。</p>
<ul>
<li>1 根据 key 计算出 hash值。</li>
<li>2 判断是否需要进行初始化。</li>
<li>3 定位到 Node，拿到首节点 f，判断首节点 f：<ul>
<li>如果为 null ，则通过cas的方式尝试添加。</li>
<li>如果为 f.hash &#x3D; MOVED &#x3D; -1 ，说明其他线程在扩容，参与一起扩容。</li>
<li>如果都不满足 ，synchronized 锁住 f 节点，判断是链表还是红黑树，遍历插入。</li>
</ul>
</li>
<li>4 当在链表长度达到8的时候，数组扩容或者将链表转换为红黑树。</li>
</ul>
<h3 id="JDK1-7-和-JDK1-8的ConcurrentHashMap实现有什么不同？"><a href="#JDK1-7-和-JDK1-8的ConcurrentHashMap实现有什么不同？" class="headerlink" title="JDK1.7 和 JDK1.8的ConcurrentHashMap实现有什么不同？"></a>JDK1.7 和 JDK1.8的ConcurrentHashMap实现有什么不同？</h3><ul>
<li><strong>线程安全实现方式</strong> ：JDK 1.7 采用 <code>Segment</code> 分段锁来保证安全， <code>Segment</code> 是继承自 <code>ReentrantLock</code>。JDK1.8 放弃了 <code>Segment</code> 分段锁的设计，采用 <code>Node + CAS + synchronized</code> 保证线程安全，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点。</li>
<li><strong>Hash 碰撞解决方法</strong> : JDK 1.7 采用拉链法，JDK1.8 采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。</li>
<li><strong>并发度</strong> ：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</li>
</ul>
<h3 id="ConcurrentHashMap-和-Hashtable-的区别"><a href="#ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别"></a>ConcurrentHashMap 和 Hashtable 的区别</h3><p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同。</p>
<ul>
<li><strong>底层数据结构：</strong> JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，数组+链表&#x2F;红黑二叉树。<code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li>
<li><strong>实现线程安全的方式（重要）：</strong> ① <strong>在 JDK1.7 的时候，<code>ConcurrentHashMap</code>（分段锁）</strong> 对整个桶数组进行了分割分段(<code>Segment</code>)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 <strong>到了 JDK1.8 的时候已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。（JDK1.6 以后 对 <code>synchronized</code> 锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② <strong><code>Hashtable</code>(同一把锁)</strong> :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>
</ul>
<h3 id="5）扩容机制"><a href="#5）扩容机制" class="headerlink" title="5）扩容机制"></a>5）扩容机制</h3><p><strong>transfer</strong>方法主要就是完成将扩容任务分配给多个线程去处理，根据了CPU核心数和集合 length 计算每个核一轮处理桶的个数。</p>
<p>然后每个线程处理的最小单位只能是一个数组的位置，这个时候扩容之后，和HashMap 一样，其实只有原位置或者 原位置+数组长度 的位置，因为仍然有可能多个线程操作之间发生哈希冲突，用到了 synchronized。</p>
<ul>
<li>根据操作系统的 CPU 核数和集合 length 计算每个核一轮处理桶的个数，最小是16</li>
<li>修改 transferIndex 标志位，每个线程领取完任务就减去多少，比如初始大小是transferIndex &#x3D; table.length &#x3D; 64，每个线程领取的桶个数是16，第一个线程领取完任务后transferIndex &#x3D; 48，也就是说第二个线程这时进来是从第 48 个桶开始处理，再减去16，依次类推，这就是多线程协作处理的原理</li>
<li>领取完任务之后就开始处理，如果桶为空就设置为 ForwardingNode ,如果不为空就加锁拷贝，只有这里用到了 synchronized 关键字来加锁，为了防止拷贝的过程有其他线程在put元素进来。拷贝完成之后也设置为 ForwardingNode节点。</li>
<li>如果某个线程分配的桶处理完了之后，再去申请，发现 transferIndex &#x3D; 0，这个时候就说明所有的桶都领取完了，但是别的线程领取任务之后有没有处理完并不知道，该线程会将 sizeCtl 的值减1，然后判断是不是所有线程都退出了，如果还有线程在处理，就退出</li>
<li>直到最后一个线程处理完，发现 sizeCtl &#x3D; rs&lt;&lt; RESIZE_STAMP_SHIFT 也就是标识符左移 16 位，才会将旧数组干掉，用新数组覆盖，并且会重新设置 sizeCtl 为新数组的扩容点。</li>
</ul>
<p><strong>以上过程总的来说分成两个部分：</strong></p>
<ul>
<li>分配任务：这部分其实很简单，就是把一个大的数组给切分，切分多个小份，然后每个线程处理其中每一小份，当然可能就只有1个或者几个线程在扩容，那就一轮一轮的处理，一轮处理一份</li>
<li>处理任务：复制部分主要有两点，第一点就是加锁，第二点就是处理完之后置为ForwardingNode来占位标识这个位置被迁移过了。</li>
</ul>
<h2 id="5-LinkedHashMap"><a href="#5-LinkedHashMap" class="headerlink" title="5. LinkedHashMap"></a>5. LinkedHashMap</h2><p>继承自HashMap，在HashMap的基础上，使用<strong>双向链表</strong>来维护k&#x2F;v对的顺序，顺序与插入顺序一致。</p>
<h2 id="6-TreeMap"><a href="#6-TreeMap" class="headerlink" title="6. TreeMap"></a>6. TreeMap</h2><p>基于<strong>红黑树</strong>实现，映射根据键的自然顺序进行排序，或者根据创建时提供的Comparator进行排序。</p>
<h2 id="7-ArraryList和LinkedList的异同点"><a href="#7-ArraryList和LinkedList的异同点" class="headerlink" title="7. ArraryList和LinkedList的异同点"></a>7. ArraryList和LinkedList的异同点</h2><ul>
<li><strong>是否保证线程安全</strong>： ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li>
<li><strong>底层数据结构</strong>： Arraylist 底层使用的是Object数组；LinkedList 底层使用的是双向循环链表数据结构；</li>
<li><strong>插入和删除是否受元素位置的影响</strong>： ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行 add(E e) 方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话(add(int index, E element))时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位&#x2F;向前移一位的操作。LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似 O(1)而数组为近似 O(n)。</li>
<li><strong>是否支持快速随机访问</strong>： LinkedList 不支持高效的随机元素访问，而ArrayList 实现了RandmoAccess 接口，所以有随机访问功能。快速随机访问就是通过元素的序号快速获取元素对象(对应于 get(int index) 方法)。</li>
<li><strong>内存空间占用</strong>： ArrayList的空间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。</li>
</ul>
<h2 id="8-ArrayList与Vector的区别？"><a href="#8-ArrayList与Vector的区别？" class="headerlink" title="8.ArrayList与Vector的区别？"></a>8.ArrayList与Vector的区别？</h2><ul>
<li>Vector是线程安全的，ArrayList不是线程安全的。其中，Vector在关键性的方法前面都加了synchronized关键字，来保证线程的安全性。如果有多个线程会访问到集合，那最好是使用Vector，因为不需要我们自己再去考虑和编写线程安全的代码。</li>
<li>ArrayList在底层数组不够用时在原来的基础上扩展0.5倍，Vector是扩展1倍，这样ArrayList就有利于节约内存空间。</li>
<li>底层都使用 <code>Object[ ]</code>存储</li>
</ul>
<h2 id="9-Array和ArrayList的区别"><a href="#9-Array和ArrayList的区别" class="headerlink" title="9.Array和ArrayList的区别"></a>9.Array和ArrayList的区别</h2><ul>
<li>Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。</li>
<li>Array 大小是固定的，ArrayList 的大小是动态变化的。</li>
<li>ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator() 等等。</li>
</ul>
<h3 id="ArrayList的扩容机制"><a href="#ArrayList的扩容机制" class="headerlink" title="ArrayList的扩容机制"></a>ArrayList的扩容机制</h3><p>ArrayList扩容的本质就是计算出新的扩容数组的size后实例化，并将原有数组内容复制到新数组中去。默认情况下，新的容量会是<strong>原容量的1.5倍</strong>。</p>
<p>PS：ArrayList的容量上限是<strong>Integer.MAX_VALUE - 8 字节。(8B是用来表示数组大小的)</strong></p>
<h2 id="10-CopyOnWriteArrayList的原理"><a href="#10-CopyOnWriteArrayList的原理" class="headerlink" title="10. CopyOnWriteArrayList的原理"></a>10. CopyOnWriteArrayList的原理</h2><p>是Java并发包的并发类，简单说是一个线程安全且读操作无锁的ArrayList。</p>
<p>在写操作时会复制一份新的List，在新的list上写，然后再将原因用指向新的list。写的时候是上锁的 ，读的是旧的list。</p>
<h2 id="11-TreeSet和HashSet"><a href="#11-TreeSet和HashSet" class="headerlink" title="11. TreeSet和HashSet"></a>11. TreeSet和HashSet</h2><p>都不能重复，都是线程不安全。</p>
<ul>
<li>HashSet底层是HashMap，不保证元素的排列顺序，元素可以是null</li>
<li>TreeSet中底层是采用红黑树，支持自然排序、定制排序，元素不能是null</li>
</ul>
<h2 id="12-BlockingQueue"><a href="#12-BlockingQueue" class="headerlink" title="12. BlockingQueue"></a>12. BlockingQueue</h2><p><strong>阻塞队列。是一个接口。</strong></p>
<p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。 这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。</p>
<ul>
<li><strong>实现类：</strong><ul>
<li>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。</li>
<li>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。 </li>
<li>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。 </li>
<li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。 </li>
<li>SynchronousQueue：一个不存储元素的阻塞队列。（）</li>
<li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。 </li>
<li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。（无界）</li>
</ul>
</li>
</ul>
<p>它们的区别主要体现在存储结构上或对元素操作上的不同，但是对于put与take操作的原理是类似的。</p>
<ul>
<li><strong>原理：</strong></li>
</ul>
<p>下面以ArrayBlockingQueue为例，来说明BlockingQueue的实现原理。</p>
<p><strong>ArrayBlockingQueue</strong>的构造函数，它初始化了put和take函数中用到的关键成员变量，这两个变量的类型分别是ReentrantLock和Condition。ReentrantLock是AbstractQueuedSynchronizer（AQS）的子类，它的newCondition函数返回的Condition实例，是定义在AQS类内部的ConditionObject类，该类可以直接调用AQS相关的函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity, <span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.items = <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull = lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>put函数</strong>会在队列末尾添加元素，如果队列已经满了，无法添加元素的话，就一直阻塞等待到可以加入为止。函数的源码如下所示。我们会发现put函数使用了wait&#x2F;notify的机制。与一般生产者-消费者的实现方式不同，同步队列使用ReentrantLock和Condition相结合的机制，即先获得锁，再等待，而不是synchronized和wait的机制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length) </span><br><span class="line">            notFull.await();</span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>take函数</strong>在队列为空时会被阻塞，一直到阻塞队列加入了新的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) </span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>await操作：</strong></p>
<p>ArrayBlockingQueue并没有使用Object.wait，而是使用的<strong>Condition.await</strong>，这是为什么呢？Condition对象可以提供和Object的wait和notify一样的行为，但是后者必须先获取synchronized这个内置的monitor锁才能调用，而Condition则必须先获取ReentrantLock。这两种方式在阻塞等待时都会将相应的锁释放掉，但是Condition的等待可以中断，这是二者唯一的区别。</p>
<p>我们先来看一下Condition的await函数。<strong>await函数主要有三个步骤</strong>，</p>
<ul>
<li>一是调用addConditionWaiter函数，在condition wait queue队列中添加一个节点，代表当前线程在等待一个消息。</li>
<li>然后调用fullyRelease函数，将持有的锁释放掉，调用的是AQS的函数。</li>
<li>最后一直调用isOnSyncQueue函数判断节点是否被转移到sync queue队列上，也就是AQS中等待获取锁的队列。如果没有，则进入阻塞状态，如果已经在队列上，则调用acquireQueued函数重新获取锁。</li>
</ul>
<img src="E:/面试/myJava.assets/image-20220504030600266.png" alt="image-20220504030600266" style="zoom:50%;" />
</li>
<li><p><strong>signal操作：</strong></p>
<p>signal函数将condition wait queue队列中队首的线程节点转移等待获取锁的sync queue队列中。这样的话，await函数中调用isOnSyncQueue函数就会返回true，导致await函数进入最后一步重新获取锁的状态。</p>
<p>我们这里来详细解析一下condition wait queue和sync queue两个队列的设计原理。condition wait queue是等待消息的队列，因为阻塞队列为空而进入阻塞状态的take函数操作就是在等待阻塞队列不为空的消息。而sync queue队列则是等待获取锁的队列，take函数获得了消息，就可以运行了，但是它还必须等待获取锁之后才能真正进行运行状态。</p>
<p>signal函数其实就做了一件事情，就是不断尝试调用transferForSignal函数，将condition wait queue队首的一个节点转移到sync queue队列中，直到转移成功。因为一次转移成功，就代表这个消息被成功通知到了等待消息的节点。</p>
</li>
</ul>
<img src="E:/面试/myJava.assets/image-20220504030711959.png" alt="image-20220504030711959" style="zoom:50%;" />

<p><strong>扩展阅读</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>抛异常</th>
<th>特定值</th>
<th>阻塞</th>
<th>超时</th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e, time, unit)</td>
</tr>
<tr>
<td>移除</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time, unit)</td>
</tr>
<tr>
<td>检查</td>
<td>element()</td>
<td>peek()</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>四组不同的行为方式含义如下：</strong></p>
<ul>
<li><strong>抛异常</strong>：如果操作无法立即执行，则抛一个异常；</li>
<li><strong>特定值</strong>：如果操作无法立即执行，则返回一个特定的值(一般是 true &#x2F; false)。</li>
<li><strong>阻塞</strong>：如果操作无法立即执行，则该方法调用将会发生阻塞，直到能够执行；</li>
<li><strong>超时</strong>：如果操作无法立即执行，则该方法调用将会发生阻塞，直到能够执行。但等待时间不会超过给定值，并返回一个特定值以告知该操作是否成功(典型的是true &#x2F; false)。</li>
</ul>
<h2 id="13-红黑树"><a href="#13-红黑树" class="headerlink" title="13. 红黑树"></a>13. 红黑树</h2><p><strong>红黑树作为一种平衡树，和AVL相比，在没有损失太多时间复杂度的前提下，大大的简化了实现的难度，通过几个规则的定义保证了最长的路径不超过最短路径的两倍。</strong></p>
<p><strong>红黑树特点</strong> :</p>
<ol>
<li>每个节点非红即黑；</li>
<li>根节点总是黑色的；</li>
<li>每个叶子节点都是黑色的空节点（NIL节点）；</li>
<li>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；</li>
<li>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。</li>
</ol>
<p><strong>红黑树的应用</strong> ：TreeMap、TreeSet以及JDK1.8的HashMap底层都用到了红黑树。</p>
<h2 id="14-集合框架底层数据结构总结"><a href="#14-集合框架底层数据结构总结" class="headerlink" title="14. 集合框架底层数据结构总结"></a>14. <strong>集合框架底层数据结构总结</strong></h2><p>先来看一下 <code>Collection</code> 接口下面的集合。</p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a><strong>List</strong></h3><ul>
<li><code>Arraylist</code>： <code>Object[]</code> 数组</li>
<li><code>Vector</code>：<code>Object[]</code> 数组</li>
<li><code>LinkedList</code>： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a><strong>Set</strong></h3><ul>
<li><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素</li>
<li><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。有点类似于我们之前说的 <code>LinkedHashMap</code> 其内部是基于 <code>HashMap</code> 实现一样，不过还是有一点点区别的</li>
<li><code>TreeSet</code>(有序，唯一): 红黑树(自平衡的排序二叉树)</li>
</ul>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a><strong>Queue</strong></h3><ul>
<li><code>PriorityQueue</code>: <code>Object[]</code> 数组来实现二叉堆</li>
<li><code>ArrayQueue</code>: <code>Object[]</code> 数组 + 双指针</li>
</ul>
<p>再来看看 <code>Map</code> 接口下面的集合。</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a><strong>Map</strong></h3><ul>
<li><code>HashMap</code>： JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li>
<li><code>LinkedHashMap</code>： <code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：**<a target="_blank" rel="noopener" href="https://www.imooc.com/article/22931">《LinkedHashMap 源码详细分析（JDK1.8）》open in new window</a>**</li>
<li><code>Hashtable</code>： 数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的</li>
<li><code>TreeMap</code>： 红黑树（自平衡的排序二叉树）</li>
</ul>
<h2 id="15-comparable-和-Comparator-的区别"><a href="#15-comparable-和-Comparator-的区别" class="headerlink" title="15. comparable 和 Comparator 的区别"></a>15. <strong>comparable 和 Comparator 的区别</strong></h2><ul>
<li><code>comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</li>
<li><code>comparator</code>接口实际上是出自 java.util 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li>
</ul>
<p>一般我们需要对一个集合使用自定义排序时，我们就要重写<code>compareTo()</code>方法或<code>compare()</code>方法，当我们需要对某一个集合实现两种排序方式，比如一个 song 对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写<code>compareTo()</code>方法和使用自制的<code>Comparator</code>方法或者以两个 Comparator 来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 <code>Collections.sort()</code>.</p>
<h2 id="16-无序性和不可重复性的含义是什么"><a href="#16-无序性和不可重复性的含义是什么" class="headerlink" title="16. 无序性和不可重复性的含义是什么"></a>16. <strong>无序性和不可重复性的含义是什么</strong></h2><p>1、什么是无序性？无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。</p>
<p>2、什么是不可重复性？不可重复性是指添加的元素按照 equals()判断时 ，返回 false，需要同时重写 equals()方法和 HashCode()方法。</p>
<h2 id="17-比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#17-比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="17. 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>17. <strong>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</strong></h2><ul>
<li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li>
<li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li>
<li>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</li>
</ul>
<h2 id="18-Collection-子接口之-Queue"><a href="#18-Collection-子接口之-Queue" class="headerlink" title="18. Collection 子接口之 Queue"></a>18. <strong>Collection 子接口之 Queue</strong></h2><h3 id="Queue-与-Deque-的区别"><a href="#Queue-与-Deque-的区别" class="headerlink" title="Queue 与 Deque 的区别"></a><strong>Queue 与 Deque 的区别</strong></h3><p><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</p>
<p><code>Queue</code> 扩展了 <code>Collection</code> 的接口，根据 <strong>因为容量问题而导致操作失败后处理方式的不同</strong> 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</p>
<img src="E:/面试/myJava.assets/image-20220504020808146.png" alt="image-20220504020808146" style="zoom:50%;" />

<p><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素。</p>
<p><code>Deque</code> 扩展了 <code>Queue</code> 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p>
<img src="E:/面试/myJava.assets/image-20220504020828592.png" alt="image-20220504020828592" style="zoom:50%;" />

<p>事实上，<code>Deque</code> 还提供有 <code>push()</code> 和 <code>pop()</code> 等其他方法，可用于模拟栈。</p>
<h3 id="ArrayDeque-与-LinkedList-的区别"><a href="#ArrayDeque-与-LinkedList-的区别" class="headerlink" title="ArrayDeque 与 LinkedList 的区别"></a><strong>ArrayDeque 与 LinkedList 的区别</strong></h3><p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能，但两者有什么区别呢？</p>
<ul>
<li><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</li>
<li><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</li>
<li><code>ArrayDeque</code> 是在 JDK1.6 才被引入的，而<code>LinkedList</code> 早在 JDK1.2 时就已经存在。</li>
<li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li>
</ul>
<p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈。</p>
<h3 id="说一说-PriorityQueue"><a href="#说一说-PriorityQueue" class="headerlink" title="说一说 PriorityQueue"></a><strong>说一说 PriorityQueue</strong></h3><p><code>PriorityQueue</code> 是在 JDK1.5 中被引入的, 其与 <code>Queue</code> 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</p>
<p>这里列举其相关的一些要点：</p>
<ul>
<li><code>PriorityQueue</code> 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</li>
<li><code>PriorityQueue</code> 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</li>
<li><code>PriorityQueue</code> 是非线程安全的，且不支持存储 <code>NULL</code> 和 <code>non-comparable</code> 的对象。</li>
<li><code>PriorityQueue</code> 默认是小顶堆，但可以接收一个 <code>Comparator</code> 作为构造参数，从而来自定义元素优先级的先后。</li>
</ul>
<p><code>PriorityQueue</code> 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第K大的数、带权图的遍历等，所以需要会熟练使用才行</p>
<h2 id="19-DelayQueue"><a href="#19-DelayQueue" class="headerlink" title="19. DelayQueue"></a>19. DelayQueue</h2><ul>
<li><p>DelayQueue是一个无界阻塞的队列，<strong>队列中的每个元素都有一个过期时间</strong>，当要从队列中取出数据时，<strong>只有过期元素才会出队</strong>。</p>
</li>
<li><p>DelayQueue内部使用<strong>PriorityQueue</strong>存放元素，又用<strong>ReentrantLock</strong>实现线程同步。</p>
</li>
<li><p>因为DelayQueue内部要获取元素的剩余时间，所以我们的数据类需要继承<strong>Delayed</strong>接口，Delayed又继承<strong>Comparable</strong>接口，实现<strong>排序</strong>，而自身只有一个<strong>getDelay()</strong><u>方法，用来获取元素的剩余时间</u>，如果getDelay()返回 &lt;&#x3D;0 的值，则表示这个元素过期，通过take()方法即可取出他，如果没有过期值，则take()会一直阻塞。</p>
</li>
</ul>
<p>（DelayQueue类涉及到TimeUnit，是在java.util.concurrent包下的一个枚举类，可以非常方便实现时间单位的转化。）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DelayQueue的主要成员属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayQueue</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Delayed</span>&gt; <span class="keyword">extends</span> <span class="title class_">AbstractQueue</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">BlockingQueue</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">// 持有内部重入锁。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">// 优先级队列，存放工作任务。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;E&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;E&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Thread</span> <span class="variable">leader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 依赖于重入锁的condition。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">available</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>入队</strong></p>
<p><strong>首先获取独占锁</strong>，<strong>然后添加元素到优先级队列</strong>，由于q是优先级队列，所以添加完元素后，peek()方法返回的并不一定是刚才添加的元素，如果判断为true，说明当前元素e的优先级最小也就是即将过期的，这时候激活avaliable变量条件队列里面的线程，通知它们队列里面有元素了。</p>
</li>
<li><p><strong>从队列中取元素</strong></p>
<p>有两个方法可以取元素（都是取队头），poll()方法取队头当队头元素没过期时返回null，take()方法取队头当队头元素没过期时会一直等待。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">//获取到重入锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        q.offer(e);</span><br><span class="line">        <span class="comment">//添加成功元素</span></span><br><span class="line">        <span class="keyword">if</span> (q.peek() == e) &#123;</span><br><span class="line">            leader = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 将等待队列中的头节点移动到同步队列。</span></span><br><span class="line">            available.signal();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>总结<ul>
<li>DelayQueue是一个内部依靠AQS队列同步器所实现的无界延迟阻塞队列。</li>
<li>延迟对象需要覆盖 getDelay()与compareTo()方法，并且要注意 getDelay()的时间单位的统一，compareTo()根据业务逻辑进行合理的比较逻辑重写。</li>
<li>DelayQueue中内聚的重入锁是非公平的。</li>
<li>DelayQueue是实现定时任务的关键，ScheduledThreadPoolExecutor中就用到了DelayQueue。</li>
</ul>
</li>
</ul>
<h2 id="20-集合的快速失败"><a href="#20-集合的快速失败" class="headerlink" title="20.集合的快速失败"></a>20.集合的快速失败</h2><p>在使用迭代器对集合对象进行遍历的时候，如果 A 线程正在对集合进行遍历，此时 B 线程对集合进行修改（增加、删除、修改），或者 A 线程在遍历过程中对集合进行修改，都会导致 A 线程抛出 ConcurrentModificationException 异常。</p>
<p><strong>快速失败相对于安全失败：</strong></p>
<p>安全失败概念：采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</p>
<p>fail-fast 机制是java集合(Collection)中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。</p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="1-SQL考察"><a href="#1-SQL考察" class="headerlink" title="1.SQL考察"></a>1.SQL考察</h2><p><img src="E:\学习笔记\图片\sql-join.png" alt="img"></p>
<h3 id="SQL-语法顺序"><a href="#SQL-语法顺序" class="headerlink" title="SQL 语法顺序"></a>SQL 语法顺序</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">SELECT</span> </span><br><span class="line"><span class="number">2.</span> <span class="keyword">DISTINCT</span> <span class="operator">&lt;</span>select_list<span class="operator">&gt;</span></span><br><span class="line"><span class="number">3.</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>left_table<span class="operator">&gt;</span></span><br><span class="line"><span class="number">4.</span> <span class="operator">&lt;</span>join_type<span class="operator">&gt;</span> <span class="keyword">JOIN</span> <span class="operator">&lt;</span>right_table<span class="operator">&gt;</span></span><br><span class="line"><span class="number">5.</span> <span class="keyword">ON</span> <span class="operator">&lt;</span>join_condition<span class="operator">&gt;</span></span><br><span class="line"><span class="number">6.</span> <span class="keyword">WHERE</span> <span class="operator">&lt;</span>where_condition<span class="operator">&gt;</span></span><br><span class="line"><span class="number">7.</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>group_by_list<span class="operator">&gt;</span></span><br><span class="line"><span class="number">8.</span> <span class="keyword">HAVING</span> <span class="operator">&lt;</span>having_condition<span class="operator">&gt;</span></span><br><span class="line"><span class="number">9.</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>order_by_condition<span class="operator">&gt;</span></span><br><span class="line"><span class="number">10.</span>LIMIT <span class="operator">&lt;</span>limit_number<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="SQL-执行顺序"><a href="#SQL-执行顺序" class="headerlink" title="SQL 执行顺序"></a>SQL 执行顺序</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span>  <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> # 笛卡尔积</span><br><span class="line"><span class="keyword">ON</span>  <span class="operator">&lt;</span>筛选条件<span class="operator">&gt;</span> # 对笛卡尔积的虚表进行筛选</span><br><span class="line"><span class="keyword">JOIN</span> <span class="operator">&lt;</span><span class="keyword">join</span>, <span class="keyword">left</span> <span class="keyword">join</span>, <span class="keyword">right</span> join...<span class="operator">&gt;</span>  <span class="operator">&lt;</span><span class="keyword">join</span>表<span class="operator">&gt;</span> # 指定<span class="keyword">join</span>，用于添加数据到<span class="keyword">on</span>之后的虚表中，例如<span class="keyword">left</span> <span class="keyword">join</span>会将左表的剩余数据添加到虚表中</span><br><span class="line"><span class="keyword">WHERE</span>  <span class="operator">&lt;</span><span class="keyword">where</span>条件<span class="operator">&gt;</span> # 对上述虚表进行筛选</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span>  <span class="operator">&lt;</span>分组条件<span class="operator">&gt;</span> # 分组</span><br><span class="line"><span class="operator">&lt;</span><span class="built_in">SUM</span>()等聚合函数<span class="operator">&gt;</span> # 用于<span class="keyword">having</span>子句进行判断，在书写上这类聚合函数是写在<span class="keyword">having</span>判断里面的</span><br><span class="line"><span class="keyword">HAVING</span>  <span class="operator">&lt;</span>分组筛选<span class="operator">&gt;</span> # 对分组后的结果进行聚合筛选</span><br><span class="line"><span class="keyword">SELECT</span>  <span class="operator">&lt;</span>返回数据列表<span class="operator">&gt;</span> # 返回的单列必须在<span class="keyword">group</span> <span class="keyword">by</span>子句中，聚合函数除外</span><br><span class="line"><span class="keyword">DISTINCT</span>  # 数据除重</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span>  <span class="operator">&lt;</span>排序条件<span class="operator">&gt;</span> # 排序</span><br><span class="line">LIMIT  <span class="operator">&lt;</span>行数限制<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><img src="E:\学习笔记\图片\image-20220803203353623.png" alt="image-20220803203353623"></p>
<p><img src="E:\学习笔记\图片\image-20220803203411571.png" alt="image-20220803203411571"></p>
<p><img src="E:\学习笔记\图片\image-20220803203422069.png" alt="image-20220803203422069"></p>
<h3 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> student;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span></span><br><span class="line">   student</span><br><span class="line">    (</span><br><span class="line">        id <span class="type">bigint</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  code <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;学生编码&#x27;</span>,</span><br><span class="line">        name <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;学生名称&#x27;</span>,</span><br><span class="line">        dr <span class="type">bigint</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;逻辑删除标志&#x27;</span>,</span><br><span class="line">        <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">    )</span><br><span class="line">ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;001&#x27;</span>, <span class="string">&#x27;张军&#x27;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;002&#x27;</span>, <span class="string">&#x27;李浩&#x27;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="string">&#x27;003&#x27;</span>, <span class="string">&#x27;王明宇&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">&#x27;004&#x27;</span>, <span class="string">&#x27;秦成&#x27;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span> (<span class="number">5</span>, <span class="string">&#x27;005&#x27;</span>, <span class="string">&#x27;李浩&#x27;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> exam;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span></span><br><span class="line">   exam</span><br><span class="line">    (</span><br><span class="line">        id <span class="type">bigint</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">        student_id <span class="type">bigint</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;学生id&#x27;</span>,</span><br><span class="line">        course <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;课程&#x27;</span>,</span><br><span class="line">        score  <span class="type">SMALLINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;分数&#x27;</span>,</span><br><span class="line">        dr <span class="type">bigint</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;逻辑删除标志&#x27;</span>,</span><br><span class="line">        <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">    )</span><br><span class="line">ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> exam <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;数学&#x27;</span>, <span class="string">&#x27;94&#x27;</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> exam <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="number">1</span>, <span class="string">&#x27;语文&#x27;</span>, <span class="string">&#x27;92&#x27;</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> exam <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="number">1</span>, <span class="string">&#x27;英语&#x27;</span>, <span class="string">&#x27;96&#x27;</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> exam <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="number">2</span>, <span class="string">&#x27;数学&#x27;</span>, <span class="string">&#x27;82&#x27;</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> exam <span class="keyword">VALUES</span> (<span class="number">5</span>, <span class="number">2</span>, <span class="string">&#x27;语文&#x27;</span>, <span class="string">&#x27;76&#x27;</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> exam <span class="keyword">VALUES</span> (<span class="number">6</span>, <span class="number">2</span>, <span class="string">&#x27;英语&#x27;</span>, <span class="string">&#x27;72&#x27;</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> exam <span class="keyword">VALUES</span> (<span class="number">7</span>, <span class="number">3</span>, <span class="string">&#x27;数学&#x27;</span>, <span class="string">&#x27;52&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> exam <span class="keyword">VALUES</span> (<span class="number">8</span>, <span class="number">3</span>, <span class="string">&#x27;语文&#x27;</span>, <span class="string">&#x27;59&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> exam <span class="keyword">VALUES</span> (<span class="number">9</span>, <span class="number">3</span>, <span class="string">&#x27;英语&#x27;</span>, <span class="string">&#x27;43&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> exam <span class="keyword">VALUES</span> (<span class="number">10</span>, <span class="number">4</span>, <span class="string">&#x27;数学&#x27;</span>, <span class="string">&#x27;88&#x27;</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> exam <span class="keyword">VALUES</span> (<span class="number">11</span>, <span class="number">4</span>, <span class="string">&#x27;语文&#x27;</span>, <span class="string">&#x27;82&#x27;</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> exam <span class="keyword">VALUES</span> (<span class="number">12</span>, <span class="number">4</span>, <span class="string">&#x27;英语&#x27;</span>, <span class="string">&#x27;83&#x27;</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> exam <span class="keyword">VALUES</span> (<span class="number">13</span>, <span class="number">5</span>, <span class="string">&#x27;数学&#x27;</span>, <span class="string">&#x27;90&#x27;</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> exam <span class="keyword">VALUES</span> (<span class="number">14</span>, <span class="number">5</span>, <span class="string">&#x27;语文&#x27;</span>, <span class="string">&#x27;92&#x27;</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> exam <span class="keyword">VALUES</span> (<span class="number">15</span>, <span class="number">5</span>, <span class="string">&#x27;英语&#x27;</span>, <span class="string">&#x27;93&#x27;</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h3 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CODE,NAME,totalscore,</span><br><span class="line"><span class="keyword">CASE</span> </span><br><span class="line"><span class="keyword">WHEN</span> totalscore<span class="operator">&gt;=</span><span class="number">280</span> <span class="keyword">THEN</span> <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">WHEN</span> totalscore<span class="operator">&lt;</span><span class="number">280</span> <span class="keyword">AND</span> totalscore<span class="operator">&gt;=</span><span class="number">250</span> <span class="keyword">THEN</span> <span class="string">&#x27;B&#x27;</span> </span><br><span class="line"><span class="keyword">WHEN</span> totalscore<span class="operator">&lt;</span><span class="number">250</span> <span class="keyword">AND</span> totalscore<span class="operator">&gt;=</span><span class="number">220</span> <span class="keyword">THEN</span> <span class="string">&#x27;C&#x27;</span></span><br><span class="line"><span class="keyword">WHEN</span> totalscore<span class="operator">&lt;</span><span class="number">220</span> <span class="keyword">AND</span> totalscore<span class="operator">&gt;=</span><span class="number">180</span> <span class="keyword">THEN</span> <span class="string">&#x27;D&#x27;</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="string">&#x27;E&#x27;</span> </span><br><span class="line"><span class="keyword">END</span> <span class="keyword">AS</span> LEVEL</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">(</span><br><span class="line"> <span class="keyword">SELECT</span> CODE,NAME,<span class="built_in">SUM</span>(score) <span class="keyword">AS</span> totalscore</span><br><span class="line"> <span class="keyword">FROM</span> exam e,student s</span><br><span class="line"> <span class="keyword">WHERE</span> e.student_id <span class="operator">=</span> s.id  <span class="keyword">AND</span> e.dr <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> e.student_id</span><br><span class="line">)t </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> CODE</span><br></pre></td></tr></table></figure>

<h2 id="2-数据库事务"><a href="#2-数据库事务" class="headerlink" title="2.数据库事务"></a>2.数据库事务</h2><p>事务由一条或多条SQL语句组成。在事务中的操作，要么都执行修改，要么都不执行。</p>
<p>事务由四个特性：ACID</p>
<ul>
<li>A：原子性。</li>
<li>C：一致性。是指事务将数据库将一种状态变为另一种一致的状态。在事务开始之前和事务结束之后，数据库的完整性约束没有被破坏。</li>
<li>I：隔离性。要求每个读写事务的对象与其他事务的操作对象能相互分离。</li>
<li>D：持久化。事务一旦提交，其结果就是永久性的。即使发生宕机等故障，数据库也能将数据恢复。（高可靠）</li>
</ul>
<p>事务分类：</p>
<ul>
<li>扁平事务、带有保存节点的扁平事务、链事务、嵌套事务、分布式事务</li>
</ul>
<p>PS：事务可以嵌套，但是MySQL数据库不支持嵌套事务。</p>
<h3 id="事务的ACID是怎么实现的？"><a href="#事务的ACID是怎么实现的？" class="headerlink" title="事务的ACID是怎么实现的？"></a>事务的ACID是怎么实现的？</h3><ul>
<li>原子性：关键是当事务回滚时撤销所有已经成功执行的sql语句。回滚靠的是<strong>undo log</strong>。当事务对数据库进行修改时，InnoDB会生成对应的ubdo log。如果事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。</li>
<li>持久性：引入了<strong>redo log</strong>被引入。当数据修改时，除了修改缓存中的数据，还会在redo log记录这次操作，redo log是预写式日志，所有修改先写入日志，再更新缓冲。当事务提交时，会对redo log进行刷盘。如果MySQL宕机了，重启时可以读取redo log中的数据，对数据进行恢复。</li>
<li>隔离性：<ul>
<li>一个事务写操作对另一个事务的写操作的影响：锁机制保证隔离性。</li>
<li>一个事务写操作对另一个事务读操作的影响：MVCC保证隔离性。InnoDB默认的隔离级别是RR（可重复读），RR解决脏读、不可重复读、幻读等，使用的是MVCC。</li>
</ul>
</li>
<li>一致性：前面的ACI都是为了保证数据库状态的一致性。还在应用层面保障一致性。</li>
</ul>
<h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><ul>
<li><strong>读未提交</strong><ul>
<li>通过Record Lock实现了行锁。但是允许读未提交的数据，所以存在脏读。</li>
</ul>
</li>
<li><strong>读已提交</strong><ul>
<li>通过Record Lock实现了行锁。允许读提交的数据，不会脏读，但存在不可重复读。</li>
</ul>
</li>
<li><strong>可重复读（默认的隔离级别）</strong><ul>
<li>MVCC解决了可重复读。并且InnoDB使用了Next-key Lock也解决了幻读。</li>
</ul>
</li>
<li><strong>串行化</strong><ul>
<li>对每个select语句后加上Lock in share mode，即为每个读取操作加一个<strong>共享锁</strong>。因此在这个事务隔离级别下，读占用了锁，不再支持对一致性的非锁定读。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>读已提交</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>可重复读</td>
<td>√</td>
<td>√</td>
<td>InnoDB可以解决</td>
</tr>
<tr>
<td>串行化</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<p>脏读：当前事务读到其他事务未提交的数据。</p>
<p>不可重复读：同一个事务先后两次读同一个数据，两次读取的结果不一样。</p>
<p>幻读：同一事务按照同一条件的两次查询结果的条数不一致。</p>
<h2 id="3-数据库优化"><a href="#3-数据库优化" class="headerlink" title="3.数据库优化"></a>3.数据库优化</h2><p>MySQL数据库的优化是多方面的的，原则上是减少系统的瓶颈，减少资源的占用，增加系统的反应速度。</p>
<p>例如，通过优化文件系统，提高磁盘IO的读写速度；通过优化操作系统调度策略，提高MySQL在高负荷情况下的负载能力；优化表结构、索引、查询语句等使查询相应更快。</p>
<ul>
<li>针对查询。通过使用引用、连接代替子查询的方式提高查询速度。</li>
<li>针对慢查询。通过分析慢查询日志，来发现引起慢查询的原因，从而有针对性的进行优化。</li>
<li>针对插入。通过禁用索引、检查等方式提高插入速度，在插入之后再启用索引和检查。</li>
<li>针对数据库。通过将字段很多的表拆成多张表、增加中间表、增加冗余字段等进行优化。</li>
</ul>
<h2 id="4-如何插入数据更高效"><a href="#4-如何插入数据更高效" class="headerlink" title="4. 如何插入数据更高效"></a>4. 如何插入数据更高效</h2><ul>
<li>禁用唯一性检查</li>
<li>禁用外键检查</li>
<li>禁用自动提交</li>
</ul>
<p>就是在插入数据前禁用，插入数据结束后，再启用。</p>
<h2 id="5-几千万条数据的表"><a href="#5-几千万条数据的表" class="headerlink" title="5. 几千万条数据的表"></a>5. 几千万条数据的表</h2><p>按照如下顺序进行优化：</p>
<ul>
<li>优化SQL索引</li>
<li>增加缓存，如redis</li>
<li>读写分离，可以采用主从复制，也可以采用主主复制</li>
<li>使用MySQL自带的分区表？？？</li>
<li>做垂直拆分</li>
<li>做水平拆分</li>
</ul>
<h2 id="6-慢查询优化"><a href="#6-慢查询优化" class="headerlink" title="6. 慢查询优化"></a>6. 慢查询优化</h2><p><code>explain</code></p>
<ul>
<li>id：select序列号</li>
<li><strong>select_type</strong>：查询表连接类型</li>
<li>table：查询的表</li>
<li>possible_keys：给出搜索记录时可选用的各个索引</li>
<li><strong>key</strong>：实际选用的索引</li>
<li><strong>key_len</strong>：索引按字节计算的长度，key_len数值越小，表示越快</li>
<li>ref：关联关系中另一个表里数据列名</li>
<li><strong>rows</strong>：预计需要扫描的记录数</li>
<li>Extra：与关联表操作有关的信息</li>
</ul>
<h2 id="7-三大范式"><a href="#7-三大范式" class="headerlink" title="7. 三大范式"></a>7. 三大范式</h2><ul>
<li><strong>第一范式</strong>：每一列都是原子的、不可分割的。</li>
<li><strong>第二范式</strong>：在1NF的基础上，非码属性完全依赖候选码（消除了部分依赖）。</li>
<li><strong>第三范式</strong>：在2NF的基础上，任何非主属性不依赖于其他非主属性（消除了传递依赖）。</li>
</ul>
<h2 id="8-存储引擎"><a href="#8-存储引擎" class="headerlink" title="8.存储引擎"></a>8.存储引擎</h2><p>MySQL 5.5.5 之前，MyISAM 是 MySQL 的默认存储引擎。5.5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。</p>
<h3 id="MyISAM-和-InnoBD区别："><a href="#MyISAM-和-InnoBD区别：" class="headerlink" title="MyISAM 和 InnoBD区别："></a>MyISAM 和 InnoBD区别：</h3><table>
<thead>
<tr>
<th></th>
<th><strong>MyISAM</strong></th>
<th><strong>InnoDB</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>主键</strong></td>
<td>允许没有任何索引和主键的表存在，myisam的索引都是保存行的地址。</td>
<td>如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)innodb的数据是主索引的一部分，其他索引保存的是主索引的值。</td>
</tr>
<tr>
<td><strong>事务处理上方面:</strong></td>
<td>MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快，但是不提供事务支持、不支持外键</td>
<td>InnoDB提供事务支持事务，外部键（foreign key）等高级数据库功能</td>
</tr>
<tr>
<td><strong>DML操作</strong></td>
<td>如果执行大量的SELECT，MyISAM是更好的选择</td>
<td><strong>1.<strong>如果你的数据执行大量的</strong>INSERT</strong>或<strong>UPDATE</strong>，出于性能方面的考虑，应该使用InnoDB表 2. <strong>DELETE  FROM table</strong>时，InnoDB不会重新建立表，而是一行一行的删除。</td>
</tr>
<tr>
<td>自动增长</td>
<td>myisam引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，他可以根据前面几列进行排序后递增。</td>
<td>innodb引擎的自动增长必须是索引，如果是组合索引也必须是组合索引的第一列。</td>
</tr>
<tr>
<td>count()函数</td>
<td>myisam保存有表的总行数，如果select count(*) from table;会直接取出出该值</td>
<td>innodb没有保存表的总行数，如果使用select count(*) from table；就会遍历整个表，消耗相当大，但是在加了wehre 条件后，myisam和innodb处理的方式都一样。</td>
</tr>
<tr>
<td><strong>锁</strong></td>
<td>表锁</td>
<td>提供行锁，另外，InnoDB表的行锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表， 例如update table set num&#x3D;1 where name like “%aaa%”</td>
</tr>
</tbody></table>
<h2 id="9-索引"><a href="#9-索引" class="headerlink" title="9.索引"></a>9.索引</h2><h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><ol>
<li><strong>唯一索引(Unique Key)</strong> ：唯一索引也是一种约束。<strong>唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。</strong> 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</li>
<li><strong>普通索引(Index)</strong> ：也称为辅助索引。<strong>普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。</strong></li>
<li><strong>前缀索引(Prefix)</strong> ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。</li>
<li><strong>全文索引(Full Text)</strong> ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。</li>
</ol>
<p><strong>根据索引文件的存储形式，分为聚簇索引和非聚簇索引（辅助索引，二级索引）</strong></p>
<ul>
<li>聚簇索引：将<strong>数据存储与索引放到了一块</strong>，找到索引也就找到了数据。<strong>InnoDB用的是聚簇索引。</strong>表数据按照索引的顺序来存储的，也就是说索引项的顺序与表中记录的物理顺序一致。对于聚集索引，叶子结点即存储了真实的数据行，不再有另外单独的数据页。 <strong>在一张表上最多只能创建一个聚集索引</strong>，因为真实数据的物理顺序只能有一种。<strong>对于 InnoDB 引擎表来说，该表的索引(B+树)的每 个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</strong></li>
<li>非聚簇索引：<strong>索引和数据分开存储</strong>。<strong>MYISAM 的索引是非聚集索引。</strong>表数据存储顺序与索引顺序无关。对于非聚集索引，索引的 data 域存储相应记录主键的值而不是地址，根据主键再进行回表查询。</li>
</ul>
<p><img src="E:\学习笔记\图片\1620" alt="img"></p>
<h3 id="聚簇索引的优势"><a href="#聚簇索引的优势" class="headerlink" title="聚簇索引的优势"></a>聚簇索引的优势</h3><ol>
<li>由于<strong>行数据和叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，已经把页加载到了Buffer中，再次访问的时候，会在内存中完成访问</strong>，不必访问磁盘。这样<strong>主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回</strong>了，<strong>如果按照主键Id来组织数据，获得数据更快</strong>。</li>
<li><strong>辅助索引使用主键作为”指针”而不是使用地址值作为指针的好处</strong>是，<strong>减少了当出现行移动或者数据页分裂时辅助索引的维护工作</strong>，**使用主键值当作指针会让辅助索引占用更多的空间，换来的好处是InnoDB在移动行时无须更新辅助索引中的这个”指针”**。</li>
<li>聚簇索引适合用在排序的场合，非聚簇索引不适合</li>
<li>取出一定范围数据的时候，使用聚簇索引</li>
<li>可以把<strong>相关数据保存在一起</strong>。例如实现电子邮箱时，可以根据用户 ID 来聚集数据，这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件。</li>
</ol>
<h3 id="聚簇索引的劣势"><a href="#聚簇索引的劣势" class="headerlink" title="聚簇索引的劣势"></a><strong>聚簇索引的劣势</strong></h3><ol>
<li><strong>维护索引很昂贵，特别是插入新行或者主键被更新导致要分页(page split)的时候</strong>。</li>
<li>表因为使用UUId（随机ID）作为主键，使数据存储稀疏，这就会出现聚簇索引有可能有比全表扫描更慢，所以建议使用int的auto_increment作为主键</li>
<li>如果主键比较大的话，那辅助索引将会变的更大，因为<strong>辅助索引的叶子存储的是主键值；过长的主键值，会导致非叶子节点占用占用更多的物理空间</strong></li>
</ol>
<h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>联合索引指的是同时对多列创建的索引，创建联合索引后，叶子节点会同时包含每个索引列的值，并且同时根据多列排序，</p>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。</p>
<h3 id="索引的底层数据结构"><a href="#索引的底层数据结构" class="headerlink" title="索引的底层数据结构"></a>索引的底层数据结构</h3><h3 id="Hash表"><a href="#Hash表" class="headerlink" title="Hash表"></a>Hash表</h3><p>哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 O（1））。</p>
<p><strong>为何能够通过 key 快速取出 value呢？</strong> 原因在于 <strong>哈希算法</strong>（也叫散列算法）。通过哈希算法，我们可以快速找到 key 对应的 index，找到了 index 也就找到了对应的 value。</p>
<p>但是！哈希算法有个 <strong>Hash 冲突</strong> 问题，也就是说多个不同的 key 最后得到的 index 相同。通常情况下，我们常用的解决办法是 <strong>链地址法</strong>。链地址法就是将哈希冲突数据存放在链表中。就比如 JDK1.8 之前 <code>HashMap</code> 就是通过链地址法来解决哈希冲突的。不过，JDK1.8 以后<code>HashMap</code>为了减少链表过长的时候搜索时间过长引入了<strong>红黑树</strong>。</p>
<h3 id="为什么不用hash表"><a href="#为什么不用hash表" class="headerlink" title="为什么不用hash表"></a>为什么不用hash表</h3><p><strong>1.Hash 冲突问题</strong> ：我们上面也提到过Hash 冲突了，不过对于数据库来说这还不算最大的缺点。</p>
<p><strong>2.Hash 索引不支持顺序和范围查询(Hash 索引不支持顺序和范围查询是它最大的缺点：</strong> 假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。</p>
<h3 id="B树-amp-B-树"><a href="#B树-amp-B-树" class="headerlink" title="B树&amp;B+树"></a>B树&amp;B+树</h3><p><strong>B 树&amp; B+树两者有何异同呢？</strong></p>
<ul>
<li>B 树的所有节点既存放键(key) 也存放 数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</li>
<li>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li>
<li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li>
</ul>
<p>在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 <strong>B+Tree 作为索引结构</strong>，但是，两者的实现方式不太一样。</p>
<h3 id="为什么不用B树"><a href="#为什么不用B树" class="headerlink" title="为什么不用B树"></a>为什么不用B树</h3><ul>
<li>IO次数较B+树多</li>
</ul>
<p>一般来说索引非常大，尤其是关系性数据库这种数据量大的索引能达到亿级别，所以为了减少<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>的占用，索引也会被存储在磁盘上。B-树&#x2F;B+树 的特点就是每层节点数目非常多，层数很少，<strong>目的就是为了就少磁盘IO次数</strong>，但是B-树的每个节点都有data域（指针），这无疑增大了节点大小，说白了增加了磁盘IO次数（磁盘IO一次读出的数据量大小是固定的，单个数据变大，每次读出的就少，IO次数增多，一次IO多耗时），而<strong>B+树除了叶子节点其它节点并不存储数据，节点小，磁盘IO次数就少</strong>。<strong>这是优点之一。</strong></p>
<ul>
<li>不支持范围查询</li>
</ul>
<p>B+树所有的Data域在叶子节点，一般来说都会进行一个优化，就是<strong>将所有的叶子节点用指针串起来</strong>。这样<strong>遍历</strong>叶子节点就能获得全部数据，这样就能进行区间访问啦。在数据库中基于范围的查询是非常频繁的，而B树不支持这样的遍历操作。<strong>B+树更适合外部存储。由于内节点无 data 域，每个节点能索引的范围更大更精确</strong>。</p>
<h3 id="为什么不用红黑树和平衡二叉树"><a href="#为什么不用红黑树和平衡二叉树" class="headerlink" title="为什么不用红黑树和平衡二叉树"></a>为什么不用红黑树和平衡二叉树</h3><p><strong>页是 InnoDB存储引擎管理数据库的最小磁盘单位。</strong>一个页中包括很多数据行。</p>
<p><strong>一个父节点只有 2 个子节点，并不能填满一个页上的所有内容</strong>啊？那多余的内容岂不是要浪费了？我们怎么才能把浪费的这部分内容利用起来呢？哈哈，答案就是 B+ 树，<strong>让一个父节点有多个子节点就可以</strong>了。</p>
<p><strong>并且由于 B+ 树分支比二叉树更多，所以相同数量的内容，B+ 树的深度更浅，深度代表什么？代表磁盘 io 次数啊！</strong></p>
<p>所以，涉及到磁盘上查询的数据结构，一般都用 B+ 树。</p>
<h3 id="为什么主键通常建议使用自增id"><a href="#为什么主键通常建议使用自增id" class="headerlink" title="为什么主键通常建议使用自增id"></a><strong>为什么主键通常建议使用自增id</strong></h3><p><strong>聚簇索引的数据的物理存放顺序与索引顺序是一致的</strong>，即：<strong>只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的</strong>。如果主键不是自增id，那么可以想象，它会干些什么，不断地调整数据的物理地址、分页。</p>
<h3 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h3><p>执行计划可以分析SQL语句具体执行的情况，用来辅助实现SQL优化</p>
<h4 id="抓取执行计划"><a href="#抓取执行计划" class="headerlink" title="抓取执行计划"></a><strong>抓取执行计划</strong></h4><p>desc + SQL语句 或者 explain + SQL语句</p>
<h4 id="执行计划中字段解释"><a href="#执行计划中字段解释" class="headerlink" title="执行计划中字段解释"></a>执行计划中字段解释</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>  employee <span class="keyword">where</span> id <span class="operator">=</span><span class="number">76</span>) table1 ) table2 ;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+--------+---------------+---------+---------+-------+---</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>      <span class="operator">|</span> type   <span class="operator">|</span> possible_keys <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+--------+---------------+---------+---------+-------+---</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>     <span class="operator">|</span> <span class="operator">&lt;</span>derived2<span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">system</span> <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> DERIVED     <span class="operator">|</span> <span class="operator">&lt;</span>derived3<span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">system</span> <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> DERIVED     <span class="operator">|</span> mcc_inform <span class="operator">|</span> const  <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">8</span>       <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+--------+---------------+---------+---------+-------+---</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>id字段</strong>：select查询的标识符. 每个select都会自动分配一个唯一的标识符，id数值越大的优先执行，id相同的从上往下顺序执行。</p>
<p><strong>select_type</strong>：select查询的类型，当没有子查询或union查询时为simple，有子查询或union查询时，有几种情况，后面会详细介绍。</p>
<p><strong>table</strong>：标识查询的是哪个表，显示这一行的数据是关于哪张表的，有时不是真实的表名字,看到的是derived（n是个数字，为id字段）</p>
<p><strong>type</strong>：数据访问、读取操作类型，对性能影响比较大。</p>
<p><strong>possible_keys</strong>：此次查询中可能选用的索引，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用。</p>
<p><strong>key</strong>：此次查询中实际使用到的索引，如果没有选择索引，键是NULL。</p>
<p><strong>key_len</strong>：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况 下,长度越短越好。</p>
<p><strong>ref</strong>: 显示索引的哪一列被使用了。</p>
<p><strong>rows</strong>: 此查询一共扫描了多少行，这个是一个估计值。</p>
<p><strong>filtered</strong>: 表示此查询条件所过滤的数据的百分比。</p>
<p><strong>extra</strong>: 额外的信息，出现Using filesort、Using temporary 意味着不能使用索引,效率会受到重大影响。</p>
<h4 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h4><h4 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a><strong>select_type</strong></h4><h5 id="SIMPLE"><a href="#SIMPLE" class="headerlink" title="SIMPLE"></a>SIMPLE</h5><p>简单select，不使用union或子查询等:</p>
<p>mysql&gt; explain select * from employee where id &#x3D;1 ;</p>
<h5 id="PRIMARY"><a href="#PRIMARY" class="headerlink" title="PRIMARY"></a>PRIMARY</h5><p>如果是复杂查询，表示是最外层的select：</p>
<p>mysql&gt; explain <strong>select * from</strong> (select * from employee where id &#x3D;1) a ;</p>
<h5 id="UNION-amp-UNION-RESULT"><a href="#UNION-amp-UNION-RESULT" class="headerlink" title="UNION &amp; UNION RESULT"></a>UNION &amp; UNION RESULT</h5><p>UNION中的第二个或后面的SELECT语句，UNION RESULT为UNION的结果：</p>
<p>mysql&gt; explain select * from employee where id &#x3D;1 <strong>union all select * from employee where id&#x3D;2;</strong></p>
<h5 id="DERIVED"><a href="#DERIVED" class="headerlink" title="DERIVED"></a>DERIVED</h5><p>派生表的SELECT，FROM子句的子查询：</p>
<p>mysql&gt; explain select * from <strong>(select * from employee where id &#x3D;1)</strong> a ;</p>
<h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>type表示数据访问&#x2F;读取的操作类型，显示了连接使用了哪种类别,有无使用索引，它提供了判断查询是否高效的重要依据依据。索引type从优到差：<strong>NULL–&gt;System–&gt;const–&gt;eq_ref–&gt;ref–&gt;ref_or_null–&gt;index_merge–&gt;unique_subquery–&gt;index_subquery–&gt;range–&gt;index–&gt;all.</strong></p>
<p>NULL:不用访问表或者索引就能直接得到结果</p>
<p>system:  表仅有一行。这是 const 连接类型的一个特例。</p>
<p>const:  const 用于用常数值比较 PRIMARY KEY 时。</p>
<p>eq_ref: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果.</p>
<p>ref:  通过索引关键字可能查找到多个符合条件的行。</p>
<p>ref_or_null:  如同 ref, 但是 MySQL 必须在初次查找的结果里找出 null 条目,然后进行二次查找。</p>
<p>index_merge: 说明索引合并优化被使用了。where中可能有多个条件(或者join)涉及到多个字段，它们之间进行 AND 或者 OR，那么此时就有可能会使用到 index merge 技术。index_merge 技术如果简单的说，其实就是：对多个索引分别进行条件扫描，然后将它们各自的结果进行合并(intersect&#x2F;union)。</p>
<p>(不常见)unique_subquery:  在某些 IN 查询中使用此种类型,而不是常规的 ref:valueIN (SELECT primary_key FROM single_table WHERE some_expr)</p>
<p>(不常见)index_subquery:  在 某 些 IN 查 询 中 使 用 此 种 类 型 , 与unique_subquery 类似,但是查询的是非唯一 性索引</p>
<p>range:  表示使用索引范围查询。当使用 &lt;&gt;、&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;、BETWEEN 或者 IN 操作符时,会使用到range。</p>
<p>index:  全表扫描,和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据。主要优点就是避免了排序, 但是开销仍然非常大。</p>
<p>all: 最坏的情况,从头到尾全表扫描。</p>
<h4 id="extra"><a href="#extra" class="headerlink" title="extra"></a>extra</h4><p>Using filesort: 没有办法利用现有索引进行排序，需要额外排序，建议：根据排序需要，创建相应合适的索引</p>
<p>Using temporary: 需要用临时表存储结果集，通常是因为group by的列列上没有索引。也有可能是因为同<br>时有group by和order by，但group by和order by的列又不一样 </p>
<p>Using index ： 利用覆盖索引，无需回表即可取得结果数据（即数据直接从索引文件中读取），这种结果是好的。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>其中重要的几个就是 <strong>key、type 、rows、extra</strong>，其中<strong>key为null、all 、index</strong>时，需要调整、优化索引。一般需要达到 <strong>ref、eq_ref</strong> 级别，<strong>范围查找需要达到 range</strong>，extra有Using filesort、Using temporary 的一定需要优化，根据rows可以直观看出优化结果。</p>
<h3 id="sql的执行顺序"><a href="#sql的执行顺序" class="headerlink" title="sql的执行顺序"></a>sql的执行顺序</h3><p><img src="E:\学习笔记\图片\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hYTkxZVw==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="AND执行逻辑"><a href="#AND执行逻辑" class="headerlink" title="AND执行逻辑"></a>AND执行逻辑</h3><p>对于and连接的两个条件，优先执行有索引的，假若都有索引，则根据数据库管理系统自身的优化去选择执行逻辑。</p>
<h3 id="索引的效率"><a href="#索引的效率" class="headerlink" title="索引的效率"></a>索引的效率</h3><p>索引type从优到差：<strong>System–&gt;const–&gt;eq_ref–&gt;ref–&gt;ref_or_null–&gt;index_merge–&gt;unique_subquery–&gt;index_subquery–&gt;range–&gt;index–&gt;all.</strong></p>
<p>例：</p>
<p>在tb_dept中建立一个复合索引 idx_parent_id_code：</p>
<p><img src="E:\学习笔记\图片\20190924110540494.png" alt="img"></p>
<p> 然后看下两个sql 解释的结果：</p>
<img src="E:\学习笔记\图片\20190924110934239.png" alt="img" style="zoom:200%;" />

<img src="E:\学习笔记\图片\20190924111011925.png" alt="img" style="zoom:200%;" />

<p>1）在当前索引下，哪一个sql索引利用率高？</p>
<p>借助于上文中查询SQL的执行顺序，是先执行 WHERE再执行 GROUP BY 的，即：</p>
<p>第一个sql执行的顺序是先执行了 where后的 parent_id然后执行了 group by 后的 dept_code，顺序是和索引的顺序是一致的，type等级为ref，扫描行数rows为 4；</p>
<p>而第二个sql是先执行了 where后的 dept_code然后执行了 group by 后的 parent_id，顺序是和索引的顺序是不一致的，type等级为index，扫描行数rows为 19；</p>
<p>从解释结果看，第一条的sql索引利用率高于第二条的。（后文会讲到：索引type从优到差：System–&gt;const–&gt;eq_ref–&gt;ref–&gt;ref_or_null–&gt;index_merge–&gt;unique_subquery–&gt;index_subquery–&gt;range–&gt;index–&gt;all.）</p>
<p>或者从扫描的行数rows对比数据源也可直观的看出，两个语句的性能</p>
<h3 id="索引失效的几种情况"><a href="#索引失效的几种情况" class="headerlink" title="索引失效的几种情况"></a>索引失效的几种情况</h3><ul>
<li>索引列上做了计算、函数、类型转换操作，这些情况下索引失效是因为查询过程需要扫描整个索引并回表，代价高于直接全表扫描；</li>
<li>like 匹配使用了前缀匹配符 ‘%abc’；</li>
<li>字符串不加引号导致类型转换；</li>
</ul>
<h3 id="常见优化索引的方法"><a href="#常见优化索引的方法" class="headerlink" title="常见优化索引的方法"></a>常见优化索引的方法</h3><ul>
<li><strong>前缀索引优化</strong></li>
</ul>
<p>前缀索引就是用某个字段中，字符串的前几个字符建立索引，比如我们可以在订单表上对商品名称字段的前 5 个字符建立索引。使用前缀索引是为了减小索引字段大小。</p>
<p>但是，前缀索引有一定的局限性，例如 order by 就无法使用前缀索引，无法把前缀索引用作覆盖索引。</p>
<ul>
<li><strong>覆盖索引优化</strong></li>
</ul>
<p>覆盖索引是指 SQL 中 query 的所有字段，在索引 B+tree 的叶子节点上都能找得到的那些索引，从辅助索引中查询得到记录，而不需要通过聚簇索引查询获得。（即要查找的字段本身就是索引，无需通过辅助栈回表查询）假设我们只需要查询商品的名称、价格，有什么方式可以避免回表呢？</p>
<p>我们可以建立一个组合索引，即商品ID、名称、价格作为一个组合索引。</p>
<ul>
<li><strong>联合索引</strong></li>
</ul>
<p>联合索引时，存在<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配。比如联合索引 (userpin, username)，如果查询条件是 WHERE userpin&#x3D;1 AND username&#x3D;2，就可以匹配上联合索引；或者查询条件是 WHERE userpin&#x3D;1，也能匹配上联合索引，但是如果查询条件是 WHERE username&#x3D;2，就无法匹配上联合索引。</p>
<h3 id="索引的使用原则"><a href="#索引的使用原则" class="headerlink" title="索引的使用原则"></a>索引的使用原则</h3><p><img src="E:\学习笔记\图片\image-20220328210243449.png" alt="image-20220328210243449"></p>
<h3 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h3><ul>
<li><p>避免 SELECT *，只查询需要的字段。</p>
</li>
<li><p>小表驱动大表，即小的数据集驱动大的数据集：</p>
<p>当B表的数据集比A表小时，用in优化 exist两表执行顺序是先查B表再查A表查询语句：SELECT * FROM A WHERE id in (SELECT id FROM B) ;<br>当A表的数据集比B表小时，用exist优化in ，两表执行顺序是先查A表，再查B表，查询语句：SELECT * FROM A WHERE EXISTS (SELECT id FROM B WHERE A.id &#x3D; B.ID) ;</p>
</li>
<li><p>尽量使用连接代替子查询，因为使用 join 时，MySQL 不会在内存中创建临时表。</p>
</li>
</ul>
<h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><ul>
<li>尽量使用主键查询，而非其他索引，因为主键查询不会触发回表查询。</li>
<li>不做列运算，把计算都放入各个业务系统实现</li>
<li>查询语句尽可能简单，大语句拆小语句，减少锁时间</li>
<li><strong>or 查询改写成 union 查询</strong></li>
<li>不用函数和触发器</li>
<li>避免 %xx 查询，可以使用：select * from t where reverse(f) like reverse(‘%abc’);</li>
<li><strong>少用 join 查询</strong></li>
<li>使用同类型比较，比如 ‘123’ 和 ‘123’、123 和 123</li>
<li>尽量<strong>避免在 where 子句中使用 !&#x3D; 或者 &lt;&gt; 操作符</strong>，查询引用会放弃索引而进行全表扫描</li>
<li>列表数据使用分页查询，每页数据量不要太大</li>
<li>避免在索引列上使用 is null 和 is not null</li>
</ul>
<h3 id="表结构设计优化"><a href="#表结构设计优化" class="headerlink" title="表结构设计优化"></a>表结构设计优化</h3><ul>
<li>使用可以存下数据最小的数据类型。</li>
<li>尽量使用 tinyint、smallint、mediumint 作为整数类型而非 int。</li>
<li><strong>尽可能使用 not null 定义字段</strong>，因为 null 占用 4 字节空间。数字可以默认 0 ，字符串默认 “”</li>
<li>尽量少用 text 类型，非用不可时最好独立出一张表。</li>
<li>尽量使用 timestamp，而非 datetime。</li>
<li>单表不要有太多字段，建议在 20 个字段以内。</li>
</ul>
<h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><p>1.语法格式：</p>
<p>CREATE &lt;索引名&gt; ON &lt;表名&gt; (&lt;列名&gt; [&lt;长度&gt;] [ ASC | DESC])</p>
<p>语法说明如下：</p>
<ul>
<li><code>&lt;索引名&gt;</code>：指定索引名。一个表可以创建多个索引，但每个索引在该表中的名称是唯一的。</li>
<li><code>&lt;表名&gt;</code>：指定要创建索引的表名。</li>
<li><code>&lt;列名&gt;</code>：指定要创建索引的列名。通常可以考虑将查询语句中在 JOIN 子句和 WHERE 子句里经常出现的列作为索引列。</li>
<li><code>&lt;长度&gt;</code>：可选项。指定使用列前的 length 个字符来创建索引。使用列的一部分创建索引有利于减小索引文件的大小，节省索引列所占的空间。在某些情况下，只能对列的前缀进行索引。索引列的长度有一个最大上限 255 个字节（MyISAM 和 InnoDB 表的最大上限为 1000 个字节），如果索引列的长度超过了这个上限，就只能用列的前缀进行索引。另外，BLOB 或 TEXT 类型的列也必须使用前缀索引。</li>
<li><code>ASC|DESC</code>：可选项。<code>ASC</code>指定索引按照升序来排列，<code>DESC</code>指定索引按照降序来排列，默认为<code>ASC</code>。</li>
</ul>
<p>2.也可以在创建表时创建索引</p>
<h2 id="10-锁"><a href="#10-锁" class="headerlink" title="10.锁"></a>10.锁</h2><p>MyISAM支持表级锁，Innode支持表级锁和行级锁</p>
<h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><p><strong>行锁则是锁定某行、某几行数据或者行之间的间隙。</strong></p>
<p><strong>行锁是作用在索引上的</strong>，建表的时候没有索引，Innode也会创建一个聚簇索引将其作为锁作用的索引。</p>
<p>使用时机：使用主键索引需要加一把锁，使用二级索引需要在二级索引和主键索引上各加一把锁。</p>
<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p><strong>表锁就是对整张表进行加锁。</strong></p>
<p>操作语句中的<strong>条件判断列有索引的用行锁，如果现在的判断列不存在索引直接用表锁。</strong>表锁使用的是一次性锁技术，在会话开始的地方使用 lock 命令将后续需要用到的表都加上锁，在表释放前，只能访问这些加锁的表，不能访问其他表，直到最后通过 unlock tables 释放所有表锁。</p>
<p>除了使用 unlock tables 显示释放锁之外，会话持有其他表锁时执行lock table 语句会释放会话之前持有的锁；会话持有其他表锁时执行 start transaction 或者 begin 开启事务时，也会释放之前持有的锁。</p>
<h3 id="两种锁的比较"><a href="#两种锁的比较" class="headerlink" title="两种锁的比较"></a>两种锁的比较</h3><p><strong>表锁：加锁过程的开销小，加锁的速度快；不会出现死锁的情况；锁定的粒度大，发生锁冲突的几率大，并发度低；</strong></p>
<ul>
<li>一般在执行DDL语句时会对整个表进行加锁，比如说 ALTER TABLE 等操作；</li>
<li>如果对InnoDB的表使用行锁，被锁定字段不是主键，也没有针对它建立索引的话，那么将会锁整张表；</li>
<li>表级锁更适合于以查询为主，并发用户少，只有少量按索引条件更新数据的应用，如Web 应用。</li>
</ul>
<p><strong>行锁：加锁过程的开销大，加锁的速度慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高；</strong></p>
<ul>
<li>最大程度的支持并发，同时也带来了最大的锁开销。</li>
<li>在 InnoDB 中，除单个 SQL 组成的事务外，锁是逐步获得的，这就决定了在 InnoDB 中发生死锁是可能的。</li>
<li>行级锁只在存储引擎层实现，而 MySQL 服务器层没有实现。 行级锁更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。</li>
</ul>
<h3 id="MyISAM表锁"><a href="#MyISAM表锁" class="headerlink" title="MyISAM表锁"></a>MyISAM表锁</h3><h3 id="表共享读锁"><a href="#表共享读锁" class="headerlink" title="表共享读锁"></a>表共享读锁</h3><p>不会阻塞其他线程对同一个表的读操作请求，但会阻塞其他线程的写操作请求；</p>
<h3 id="表独占锁"><a href="#表独占锁" class="headerlink" title="表独占锁"></a>表独占锁</h3><p>一旦表被加上独占写锁，那么无论其他线程是读操作还是写操作，都会被阻塞；</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><strong>重要：</strong>MyISAM在执行<strong>查询</strong>语句（SELECT）前，会<strong>自动</strong>给涉及的所有表加<strong>读锁</strong>，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此用户一般不需要直接用 LOCK TABLE 命令给 MyISAM 表显式加锁。<strong>在自动加锁的情况下，MyISAM 总是一次获得 SQL 语句所需要的全部锁，这也正是 MyISAM 表不会出现死锁（Deadlock Free）的原因。</strong></p>
<p>MyISAM存储引擎支持并发插入，以减少给定表的读操作和写操作之间的争用：</p>
<p>如果MyISAM表在数据<strong>文件中没有空闲块</strong>（由于删除或更新导致的空行），则行始终插入数据文件的末尾。在这种情况下，你可以自由混合并发使用MyISAM表的 INSERT 和 SELECT 语句而不需要加锁（你可以在其他线程进行读操作的情况下，同时将行插入到MyISAM表中）。如果文件中<strong>有空闲块，则并发插入会被禁止，</strong>但当所有的空闲块重新填充有新数据时，它又会自动启用。 要控制此行为，可以使用MySQL的concurrent_insert系统变量。</p>
<ul>
<li>当concurrent_insert&#x3D;0时，不允许并发插入功能。</li>
<li>当concurrent_insert&#x3D;1时，允许对没有空闲块的表使用并发插入，新数据位于数据文件结尾（缺省）。</li>
<li>当concurrent_insert&#x3D;2时，不管表有没有空想快，都允许在数据文件结尾并发插入。</li>
</ul>
<h3 id="InnoDB行锁和表锁"><a href="#InnoDB行锁和表锁" class="headerlink" title="InnoDB行锁和表锁"></a>InnoDB行锁和表锁</h3><p><code>RU</code>和<code>RC</code>不存在间隙锁！如果<strong>隔离级别为<code>RU</code>和<code>RC</code>，无论条件列上是否有索引，都不会锁表</strong>，只锁行！而所谓的“锁表”，其原理是通过行锁+间隙锁来实现的。这2种隔离级别下，无论是范围查询还是等值查询，只存在2种加锁类型：读锁、写锁。</p>
<p><strong>注意</strong>：InnoDB只有在通过索引条件检索数据时使用行级锁，否则使用表锁！</p>
<h3 id="表锁——意向锁"><a href="#表锁——意向锁" class="headerlink" title="表锁——意向锁"></a>表锁——意向锁</h3><p><strong>作用</strong>：由于表锁和行锁虽然锁定范围不同，但是会相互冲突。当你要加表锁时，势必要先遍历该表的所有记录，判断是否有排他锁。这种遍历检查的方式显然是一种低效的方式，MySQL引入了意向锁，来检测表锁和行锁的冲突。</p>
<p>意向锁也是表级锁，分为读意向锁（IS锁）和写意向锁（IX锁）。当事务要在记录上加上行锁时，要首先在表上加上意向锁。这样判断表中是否有记录正在加锁就很简单了，只要看下表上是否有意向锁就行了，从而就能提高效率。</p>
<p>意向锁之间是不会产生冲突的，它只会阻塞表级读锁或写锁。意向锁不与行级锁发生冲突。</p>
<h3 id="表锁的加锁方式"><a href="#表锁的加锁方式" class="headerlink" title="表锁的加锁方式"></a>表锁的加锁方式</h3><ul>
<li>意向锁是 InnoDB 自动加的，不需要用户干预；</li>
<li>自动加锁。</li>
<li>查询操作（SELECT），会自动给涉及的所有表加读锁。</li>
<li>更新操作（UPDATE、DELETE、INSERT），会自动给涉及的表加写锁。也可以显示加锁：<br>共享读锁：lock table tableName read;<br>独占写锁：lock table tableName write;<br>批量解锁：unlock tables;</li>
</ul>
<h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><h4 id="共享锁（S）："><a href="#共享锁（S）：" class="headerlink" title="共享锁（S）："></a>共享锁（S）：</h4><p>也称为读锁，加了锁的记录，所有事务都能去读取但不能修改，同时阻止其他事务获得相同数据集的排他锁</p>
<h4 id="排它锁（X）："><a href="#排它锁（X）：" class="headerlink" title="排它锁（X）："></a>排它锁（X）：</h4><p>也称为写锁，允许已经获得排他锁的事务去更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁</p>
<p>根据使用场景的不同，又可以将行锁进行进一步的划分：<strong>Next-Key Lock</strong>、<strong>Gap Lock</strong>、<strong>Record Lock</strong>以及插入意向GAP锁。</p>
<p>不同的锁锁定的位置是不同的，比如说记录锁只锁定对应的记录，而间隙锁锁住记录和记录之间的间隙，Next-key Lock则锁住所属记录之间的间隙。不同的锁类型锁定的范围大致如图所示：</p>
<p><img src="E:\学习笔记\图片\1614350-20201115221250844-767865625.png" alt="img"></p>
<h4 id="记录锁-x2F-行锁（Record-Lock）"><a href="#记录锁-x2F-行锁（Record-Lock）" class="headerlink" title="记录锁&#x2F;行锁（Record Lock）"></a>记录锁&#x2F;行锁（Record Lock）</h4><p>在某条数据上加锁</p>
<h4 id="间隙锁（Gap-Lock）"><a href="#间隙锁（Gap-Lock）" class="headerlink" title="间隙锁（Gap Lock）"></a>间隙锁（Gap Lock）</h4><p>对于键值在条件范围内但并不存在（空闲块）的记录，就叫做<strong>间隙</strong></p>
<p>当我们使用范围条件而不是相等条件去检索，并请求锁时，InnoDB就会给符合条件的记录的索引项加上锁；可以表明间隙锁是所在两个存在的索引之间，是一个<strong>开区间</strong></p>
<p><strong>存在的目的：</strong></p>
<p>间隙锁的目的是为了<strong>防止幻读</strong>，其主要通过两个方面实现这个目的：</p>
<p>(1)防止间隙内有新数据被插入</p>
<p>(2)防止已存在的数据，更新成间隙内的数据(例如防止numer&#x3D;3的记录通过update变成number&#x3D;5)</p>
<p><strong>一个事务所采取的间隙锁是不会去阻止另外一个事务在同一个间隙中加锁的。</strong></p>
<p> <strong>RU 和 RC 两种隔离级别</strong>下，无法防止<strong>幻读</strong>（读后写的场景）。因为这两种隔离级别下只会有<strong>行锁</strong>，而不会有<strong>间隙锁</strong>。</p>
<p><strong>产生间隙锁的条件（RR事务隔离级别下）：</strong></p>
<ol>
<li>使用普通索引锁定；</li>
<li>使用多列唯一索引；</li>
<li>使用唯一索引锁定多行记录。</li>
</ol>
<h4 id="临键锁（Next-key-Lock）"><a href="#临键锁（Next-key-Lock）" class="headerlink" title="临键锁（Next-key Lock）"></a>临键锁（Next-key Lock）</h4><p>临键锁是记录锁与间隙锁的结合，所以临键锁与间隙锁是一个同时存在的概念，唯一区别是临键锁是<strong>左开右闭</strong>（索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。）</p>
<p>next-key Lock范围</p>
<ul>
<li>非唯一索引的等值查询<ul>
<li>查询的值存在：加两把锁：next-key Lock + 间隙锁 （ 值和前后的间隙）</li>
<li>查询的值不存在： 加next-key Lock，但是会退化为间隙锁（包含值的范围）</li>
</ul>
</li>
<li>非唯一索引的范围查询：加next-key Lock</li>
<li>唯一索引的等值查询<ul>
<li>查询的值存在：加next-key Lock，退化为行锁</li>
<li>查询的值不存在：加next-key Lock，退化为间隙锁</li>
</ul>
</li>
<li>唯一索引的范围查询：加next-key Lock，会退化为间隙锁&#x2F;记录锁</li>
</ul>
<img src="https://img-blog.csdnimg.cn/ef14569294104adf884947cba2867be0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAwrfmooXoirHljYHkuIk=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom:200%;" />

<p><strong>范围边界值的注意事项</strong></p>
<ul>
<li>24属于临键锁（21，24] 的下区间边界值，属于后闭原则，该条记录被锁定了，无法修改</li>
<li>新插入的数据其age是下区间的边界值24，牢记：插入的数据在区间的边界值，则根据主键来判断锁定范围。数据库存在age&#x3D;24的记录，其id&#x3D;10，针对插入的是下区间边界值，只要插入的主键 大于 其数据库age&#x3D;24 对应的id值 10 就能插入。</li>
</ul>
<h4 id="插入意向锁（Insert-Intention-Lock）"><a href="#插入意向锁（Insert-Intention-Lock）" class="headerlink" title="插入意向锁（Insert Intention Lock）"></a>插入意向锁（Insert Intention Lock）</h4><p>插入意图锁是一种间隙锁，在执行 INSERT 插入操作之前设置。如果多个事务 INSERT 到同一个索引间隙之间，但没有在同一位置上插入，则不会产生任何的冲突。</p>
<h4 id="行锁的加锁方式"><a href="#行锁的加锁方式" class="headerlink" title="行锁的加锁方式"></a>行锁的加锁方式</h4><ul>
<li>自动加锁</li>
<li>对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及的数据集加上排他锁；</li>
<li>对于普通的SELECT语句，InnoDB不会加任何锁；事务可以通过以下语句显式给记录集添加共享锁或排他锁：<ul>
<li>共享锁（S）：<code>select * from table_name where ... lock in share mode</code>。此时其他 session 仍然可以查询记录，并也可以对该记录加 share mode 的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。</li>
<li>排他锁（X）：<code>select * from table_name where ... for update</code>。其他session可以查询记录，但是不能对该记录加共享锁或排他锁，只能等待锁释放后在加锁。</li>
</ul>
</li>
</ul>
<h3 id="加锁的规则"><a href="#加锁的规则" class="headerlink" title="加锁的规则"></a>加锁的规则</h3><p>加锁规则里面，包含了两个“原则”、两个“优化”和一个“bug”。</p>
<p>原则 1:在RR隔离级别下，加锁的基本单位是 next-key lock。希望你还记得，next-key lock 是前开后闭 区间。</p>
<p>原则 2:查找过程中访问到的对象才会加锁。</p>
<p>优化 1:索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。</p>
<p>优化 2:索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。</p>
<p>一个 bug:唯一索引上的范围查询会访问到不满足条件的第一个值为止。</p>
<h4 id="什么场景下用表锁"><a href="#什么场景下用表锁" class="headerlink" title="什么场景下用表锁"></a>什么场景下用表锁</h4><p>InnoDB默认采用行锁，在未使用索引字段查询时升级为表锁。即便你在条件中使用了索引字段，MySQL会根据自身的执行计划，考虑是否使用索引(所以explain命令中会有possible_key 和 key)。如果MySQL认为全表扫描效率更高，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。因此，在分析锁冲突时，别忘了检查SQL的执行计划，以确认是否真正使用了索引。</p>
<p>第一种情况：<strong>全表更新</strong>。事务需要更新大部分或全部数据，且表又比较大。若使用行锁，会导致事务执行效率低，从而可能造成其他事务长时间锁等待和更多的锁冲突。</p>
<p>第二种情况：<strong>多表查询</strong>。事务涉及多个表，比较复杂的关联查询，很可能引起死锁，造成大量事务回滚。这种情况若能一次性锁定事务涉及的表，从而可以避免死锁、减少数据库因事务回滚带来的开销。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>1 InnoDB 支持表锁和行锁，使用索引作为检索条件修改数据时采用行锁，否则采用表锁。<br>2 InnoDB 自动给修改操作加锁，给查询操作不自动加锁<br>3 行锁可能因为未使用索引而升级为表锁，所以除了检查索引是否创建的同时，也需要通过explain执行计划查询索引是否被实际使用。<br>4 行锁相对于表锁来说，优势在于高并发场景下表现更突出，毕竟锁的粒度小。<br>5 当表的大部分数据需要被修改，或者是多表复杂关联查询时，建议使用表锁优于行锁。<br>6 为了保证数据的一致完整性，任何一个数据库都存在锁定机制。锁定机制的优劣直接影响到一个数据库的并发处理能力和性能。</p>
<h2 id="11-分库分表"><a href="#11-分库分表" class="headerlink" title="11.分库分表"></a>11.分库分表</h2><h3 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h3><p><strong>垂直分库</strong>就是根据业务耦合性，将关联度低的不同表存储在不同的数据库。做法与大系统拆分为多个小系统类似，按业务分类进行独立划分。</p>
<p><img src="E:\学习笔记\图片\20181208091644449.png" alt="img"></p>
<p><strong>垂直分表</strong>是基于数据库中的”列”进行，某个表字段较多，可以新建一张扩展表，将不经常用或字段长度较大的字段拆分出去到扩展表中。</p>
<p><img src="E:\学习笔记\图片\20181208091530935.png" alt="img"></p>
<p><strong>垂直切分的优点：</strong></p>
<ul>
<li>解决业务系统层面的耦合，业务清晰</li>
<li>与微服务的治理类似，也能对不同业务的数据进行分级管理、维护、监控、扩展等</li>
<li>高并发场景下，垂直切分一定程度的提升IO、数据库连接数、单机硬件资源的瓶颈</li>
</ul>
<p>缺点：</p>
<ul>
<li>部分表无法join，只能通过接口聚合方式解决，提升了开发的复杂度</li>
<li>分布式事务处理复杂</li>
<li>依然存在单表数据量过大的问题（需要水平切分）</li>
</ul>
<h3 id="横向切分"><a href="#横向切分" class="headerlink" title="横向切分"></a>横向切分</h3><p><img src="E:\学习笔记\图片\20181208091814113.png" alt="img"></p>
<p>水平切分分为库内分表和分库分表，是根据表内数据内在的逻辑关系，将同一个表按不同的条件分散到多个数据库或多个表中，每个表中只包含一部分数据，从而使得单个表的数据量变小，达到分布式的效果。</p>
<p>库内分表只解决了单一表数据量过大的问题，但没有将表分布到不同机器的库上，因此对于减轻MySQL数据库的压力来说，帮助不是很大，大家还是竞争同一个物理机的CPU、内存、网络IO，最好通过分库分表来解决。</p>
<p>水平切分的优点：</p>
<ul>
<li>不存在单库数据量过大、高并发的性能瓶颈，提升系统稳定性和负载能力</li>
<li>应用端改造较小，不需要拆分业务模块</li>
</ul>
<p>缺点：</p>
<ul>
<li>跨分片的事务一致性难以保证</li>
<li>跨库的join关联查询性能较差</li>
<li>数据多次扩展难度和维护量极大</li>
</ul>
<p>水平切分后同一张表会出现在多个数据库&#x2F;表中，每个库&#x2F;表的内容不同。</p>
<h3 id="分库分表常用方案："><a href="#分库分表常用方案：" class="headerlink" title="分库分表常用方案："></a>分库分表常用方案：</h3><ol>
<li>不分库只分表</li>
<li>只分库不分表</li>
<li>既分库又分表</li>
</ol>
<h3 id="分库分表常用数据拆分算法："><a href="#分库分表常用数据拆分算法：" class="headerlink" title="分库分表常用数据拆分算法："></a>分库分表常用数据拆分算法：</h3><ol>
<li>对key取模法（分片的数据相对比较均匀，不容易出现热点和并发访问的瓶颈，但是，后期分片集群扩容起来需要迁移旧的数据。）</li>
<li>RANGE分区（适合需要范围查询的情景，但是会存在热点问题）</li>
<li>时间分区（存在热点问题）</li>
<li>一致性Hash（能够很大程度的避免后期分片集群扩容起来需要迁移旧的数据的问题。）</li>
</ol>
<h3 id="分库分表的难点"><a href="#分库分表的难点" class="headerlink" title="分库分表的难点"></a>分库分表的难点</h3><p>垂直分库带来的问题和解决思路：</p>
<h4 id="跨库join的问题"><a href="#跨库join的问题" class="headerlink" title="跨库join的问题"></a><strong>跨库join的问题</strong></h4><p>在拆分之前，系统中很多列表和详情页所需的数据是可以通过sql join来完成的。而拆分后，数据库可能是分布式在不同实例和不同的主机上，join将变得非常麻烦。而且基于架构规范，性能，安全性等方面考虑，一般是禁止跨库join的。那该怎么办呢？首先要考虑下垂直分库的设计问题，如果可以调整，那就优先调整。如果无法调整的情况，总结几种常见的解决思路，并分析其适用场景。</p>
<h4 id="跨库Join的几种解决思路"><a href="#跨库Join的几种解决思路" class="headerlink" title="跨库Join的几种解决思路"></a><strong>跨库Join的几种解决思路</strong></h4><p><strong>全局表</strong><br>所谓全局表，就是有可能系统中所有模块都可能会依赖到的一些表。比较类似我们理解的“数据字典”。为了避免跨库join查询，我们可以将这类表在其他每个数据库中均保存一份。同时，这类数据通常也很少发生修改（甚至几乎不会），所以也不用太担心“一致性”问题。</p>
<p><strong>字段冗余</strong><br>这是一种典型的反范式设计，在互联网行业中比较常见，通常是为了性能来避免join查询。</p>
<p>举个电商业务中很简单的场景：</p>
<p>“订单表”中保存“卖家Id”的同时，将卖家的“Name”字段也冗余，这样查询订单详情的时候就不需要再去查询“卖家用户表”。</p>
<p>字段冗余能带来便利，是一种“<strong>空间换时间</strong>”的体现。但其适用场景也比较有限，比较适合依赖字段较少的情况。最复杂的还是数据一致性问题，这点很难保证，可以借助数据库中的触发器或者在业务代码层面去保证。当然，也需要结合实际业务场景来看一致性的要求。就像上面例子，如果卖家修改了Name之后，是否需要在订单信息中同步更新呢？</p>
<p><strong>数据同步</strong><br>定时A库中的tab_a表和B库中tbl_b有关联，可以定时将指定的表做同步。当然，同步本来会对数据库带来一定的影响，需要性能影响和数据时效性中取得一个平衡。这样来避免复杂的跨库查询。笔者曾经在项目中是通过ETL工具来实施的。</p>
<p><strong>系统层组装</strong><br>在系统层面，通过调用不同模块的组件或者服务，获取到数据并进行字段拼装。说起来很容易，但实践起来可真没有这么简单，尤其是数据库设计上存在问题但又无法轻易调整的时候。</p>
<h3 id="分布式全局唯一ID"><a href="#分布式全局唯一ID" class="headerlink" title="分布式全局唯一ID"></a>分布式全局唯一ID</h3><p>在很多中小项目中，我们往往直接使用数据库自增特性来生成主键ID，这样确实比较简单。而在分库分表的环境中，数据分布在不同的分片上，不能再借助数据库自增长特性直接生成，否则会造成不同分片上的数据表主键会重复。简单介绍下使用和了解过的几种ID生成算法。</p>
<ul>
<li>Twitter的Snowflake（又名“雪花算法”）</li>
<li>UUID&#x2F;GUID（一般应用程序和数据库均支持）</li>
<li>MongoDB ObjectID（类似UUID的方式）</li>
<li>Ticket Server（数据库生存方式，Flickr采用的就是这种方式）</li>
</ul>
<p>其中，Twitter 的Snowflake算法是笔者近几年在分布式系统项目中使用最多的，未发现重复或并发的问题。</p>
<h2 id="12-日志"><a href="#12-日志" class="headerlink" title="12.日志"></a>12.日志</h2><p>其中重做日志和回滚日志与事务操作息息相关，二进制日志也与事务操作有一定的关系。</p>
<h3 id="1：重做日志（redo-log）"><a href="#1：重做日志（redo-log）" class="headerlink" title="1：重做日志（redo log）"></a>1：<strong>重做日志（redo log）</strong></h3><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a><strong>作用：</strong></h4><p>　　<strong>确保事务的持久性</strong>。redo日志记录<strong>事务执行后的状态</strong>，用来恢复未写入data file的已成功事务更新的数据。防止在发生故障的时间点，尚有脏页未写入磁盘，<strong>在重启<a target="_blank" rel="noopener" href="https://www.2cto.com/database/MySQL/">mysql</a>服务的时候，根据redo log进行重做</strong>，从而达到事务的持久性这一特性。</p>
<h4 id="内容："><a href="#内容：" class="headerlink" title="内容："></a><strong>内容：</strong></h4><p>　　<strong>物理格式</strong>的日志，记录的是物理数据页面的修改的信息，其redo log是顺序写入redo log file的物理文件中去的。</p>
<h4 id="什么时候产生："><a href="#什么时候产生：" class="headerlink" title="什么时候产生："></a><strong>什么时候产生：</strong></h4><p>　　<strong>事务开始之后就产生redo log</strong>，redo log的落盘并不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入redo log文件中。</p>
<h4 id="什么时候释放："><a href="#什么时候释放：" class="headerlink" title="什么时候释放："></a><strong>什么时候释放：</strong></h4><p>　　当对应事务的脏页写入到磁盘之后，redo log的使命也就完成了，重做日志占用的空间就可以重用（被覆盖）。</p>
<h4 id="对应的物理文件："><a href="#对应的物理文件：" class="headerlink" title="对应的物理文件："></a><strong>对应的物理文件：</strong></h4><p>　　默认情况下，对应的物理文件位于<a target="_blank" rel="noopener" href="https://www.2cto.com/database/">数据库</a>的data目录下的ib_logfile1&amp;ib_logfile2</p>
<p>　　innodb_log_group_home_dir 指定日志文件组所在的路径，默认.&#x2F; ，表示在数据库的数据目录下。</p>
<p>　　innodb_log_files_in_group 指定重做日志文件组中文件的数量，默认2</p>
<h4 id="关于文件的大小和数量，由以下两个参数配置："><a href="#关于文件的大小和数量，由以下两个参数配置：" class="headerlink" title="关于文件的大小和数量，由以下两个参数配置："></a><strong>关于文件的大小和数量，由以下两个参数配置：</strong></h4><p>　　innodb_log_file_size 重做日志文件的大小。</p>
<p>　　innodb_mirrored_log_groups 指定了日志镜像文件组的数量，默认1</p>
<h4 id="其他："><a href="#其他：" class="headerlink" title="其他："></a><strong>其他：</strong></h4><p>　　很重要一点，redo log是什么时候写盘的？前面说了是在事物开始之后逐步写盘的。</p>
<p>　　之所以说重做日志是在事务开始之后逐步写入重做日志文件，而不一定是事务提交才写入重做日志缓存，原因就是，重做日志有一个缓存区Innodb_log_buffer，Innodb_log_buffer的默认大小为8M(这里设置的16M),Innodb存储引擎先将重做日志写入innodb_log_buffer中。</p>
<p>然后会通过以下三种方式将innodb日志缓冲区的日志刷新到磁盘</p>
<p>　　Master Thread 每秒一次执行刷新Innodb_log_buffer到重做日志文件。</p>
<p>　　每个事务提交时会将重做日志刷新到重做日志文件。</p>
<p>　　当重做日志缓存可用空间 少于一半时，重做日志缓存被刷新到重做日志文件</p>
<h3 id="2：回滚日志（undo-log）"><a href="#2：回滚日志（undo-log）" class="headerlink" title="2：回滚日志（undo log）"></a>2：<strong>回滚日志（undo log）</strong></h3><h4 id="作用：-1"><a href="#作用：-1" class="headerlink" title="作用："></a><strong>作用：</strong></h4><p>　　<strong>保证数据的原子性</strong>，保存了<strong>事务发生之前</strong>的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读</p>
<p><strong>内容：</strong></p>
<p>　　<strong>逻辑格式</strong>的日志，<strong>在执行undo的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，而不是从物理页面上操作实现的，</strong>这一点是不同于redo log的。</p>
<h4 id="什么时候产生：-1"><a href="#什么时候产生：-1" class="headerlink" title="什么时候产生："></a><strong>什么时候产生：</strong></h4><p>　　事务开始之前，将当前的版本生成undo log，undo 也会产生 redo 来保证undo log的可靠性</p>
<h4 id="什么时候释放：-1"><a href="#什么时候释放：-1" class="headerlink" title="什么时候释放："></a><strong>什么时候释放：</strong></h4><p>　　当事务提交之后，undo log并不能立马被删除，而是放入待清理的链表，由purge线程判断是否由其他事务在使用undo段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间。</p>
<h4 id="对应的物理文件：-1"><a href="#对应的物理文件：-1" class="headerlink" title="对应的物理文件："></a><strong>对应的物理文件：</strong></h4><p>　　MySQL5.6之前，undo表空间位于共享表空间的回滚段中，共享表空间的默认的名称是ibdata，位于数据文件目录中。</p>
<p>　　MySQL5.6之后，undo表空间可以配置成独立的文件，但是提前需要在配置文件中配置，完成数据库初始化后生效且不可改变undo log文件的个数</p>
<p>　　如果初始化数据库之前没有进行相关配置，那么就无法配置成独立的表空间了。</p>
<h3 id="3：二进制日志（binlog）"><a href="#3：二进制日志（binlog）" class="headerlink" title="3：二进制日志（binlog）"></a>3：<strong>二进制日志（binlog）</strong></h3><h4 id="作用：-2"><a href="#作用：-2" class="headerlink" title="作用："></a><strong>作用：</strong></h4><p>　　用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步。</p>
<p>　　用于数据库的基于时间点的还原。</p>
<p>​		可以说<code>MySQL</code>数据库的<strong>数据备份、主备、主主、主从</strong>都离不开<code>binlog</code>，需要依靠<code>binlog</code>来同步数据，保证<strong>数据一致性</strong>。</p>
<h4 id="内容：-1"><a href="#内容：-1" class="headerlink" title="内容："></a><strong>内容：</strong></h4><p>　　逻辑格式的日志，可以简单认为就是执行过的事务中的sql语句。</p>
<p>记录内容是语句的原始逻辑，类似于“给 ID&#x3D;2 这一行的 c 字段加 1”，属于<code>MySQL Server</code> 层。</p>
<p>　　但又不完全是sql语句这么简单，而是包括了执行的sql语句（增删改）反向的信息，也就意味着delete对应着delete本身和其反向的insert；update对应着update执行前后的版本的信息；insert对应着delete和insert本身的信息。</p>
<p>　　在使用mysqlbinlog解析binlog之后一些都会真相大白。</p>
<p>　　因此可以基于binlog做到类似于oracle的闪回功能，其实都是依赖于binlog中的日志记录。</p>
<h4 id="什么时候产生：-2"><a href="#什么时候产生：-2" class="headerlink" title="什么时候产生："></a><strong>什么时候产生：</strong></h4><p>　　<strong>事务提交的时候</strong>，<strong>一次性</strong>将事务中的sql语句（一个事务可能对应多个sql语句）按照一定的格式记录到binlog中。</p>
<p>　　这里与redo log很明显的差异就是redo log并不一定是在事务提交的时候刷新到磁盘，redo log是在事务开始之后就开始逐步写入磁盘。</p>
<p>　　因此对于事务的提交，即便是较大的事务，提交（commit）都是很快的，但是在开启了bin_log的情况下，对于较大事务的提交，可能会变得比较慢一些。</p>
<p>　　这是因为binlog是在事务提交的时候一次性写入的造成的，这些可以通过测试验证。</p>
<h4 id="什么时候释放：-2"><a href="#什么时候释放：-2" class="headerlink" title="什么时候释放："></a><strong>什么时候释放：</strong></h4><p>　　binlog的默认是保持时间由参数expire_logs_days配置，也就是说对于非活动的日志文件，在生成时间超过expire_logs_days配置的天数之后，会被自动删除。</p>
<h4 id="对应的物理文件：-2"><a href="#对应的物理文件：-2" class="headerlink" title="对应的物理文件："></a><strong>对应的物理文件：</strong></h4><p>　　配置文件的路径为log_bin_basename，binlog日志文件按照指定大小，当日志文件达到指定的最大的大小之后，进行滚动更新，生成新的日志文件。</p>
<p>　　对于每个binlog日志文件，通过一个统一的index文件来组织。</p>
<h4 id="记录格式"><a href="#记录格式" class="headerlink" title="记录格式"></a><strong>记录格式</strong></h4><p><code>binlog</code> 日志有三种格式，可以通过<code>binlog_format</code>参数指定。</p>
<ul>
<li><strong>statement</strong></li>
<li><strong>row</strong></li>
<li><strong>mixed</strong></li>
</ul>
<p>指定<code>statement</code>，<strong>记录的内容是<code>SQL</code>语句原文</strong>，比如执行一条<code>update T set update_time=now() where id=1</code>，记录的内容如下。</p>
<p><img src="E:\学习笔记\图片\02-20220305234738688.png" alt="img"></p>
<p>同步数据时，会执行记录的<code>SQL</code>语句，但是有个问题，<code>update_time=now()</code>这里会获取当前系统时间，直接执行会导致与原库的数据不一致。</p>
<p>为了解决这种问题，我们需要指定为<code>row</code>，<strong>记录的内容</strong>不再是简单的<code>SQL</code>语句了，<strong>还包含操作的具体数据</strong>，记录内容如下。</p>
<p><img src="E:\学习笔记\图片\03-20220305234742460.png" alt="img"></p>
<p><strong><code>row</code>格式记录的内容看不到详细信息，要通过<code>mysqlbinlog</code>工具解析出来。</strong></p>
<p><code>update_time=now()</code>变成了具体的时间<code>update_time=1627112756247</code>，条件后面的@1、@2、@3 都是该行数据第 1 个~3 个字段的原始值（<strong>假设这张表只有 3 个字段</strong>）。</p>
<p>这样就能保证同步数据的一致性，通常情况下都是指定为<code>row</code>，这样可以为数据库的恢复与同步带来更好的可靠性。</p>
<p>但是这种格式，<strong>需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗<code>IO</code>资源，影响执行速度。</strong></p>
<p>所以就有了一种折中的方案，指定为<code>mixed</code>，记录的内容是前两者的混合。</p>
<p><code>MySQL</code>会判断这条<code>SQL</code>语句是否可能引起数据不一致，如果是，就用<code>row</code>格式，否则就用<code>statement</code>格式。</p>
<h4 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h4><p><code>redo log</code>（重做日志）让<code>InnoDB</code>存储引擎拥有了崩溃恢复能力。</p>
<p><code>binlog</code>（归档日志）保证了<code>MySQL</code>集群架构的数据一致性。</p>
<p>虽然它们都属于持久化的保证，但是侧重点不同。</p>
<p>在执行更新语句过程，会记录<code>redo log</code>与<code>binlog</code>两块日志，以基本的事务为单位，<code>redo log</code>在事务执行过程中可以不断写入，而<code>binlog</code>只有在提交事务时才写入，所以<code>redo log</code>与<code>binlog</code>的写入时机不一样。</p>
<p>这就会造成一个<strong>问题</strong>：</p>
<p>我们以<code>update</code>语句为例，假设<code>id=2</code>的记录，字段<code>c</code>值是<code>0</code>，把字段<code>c</code>值更新成<code>1</code>，<code>SQL</code>语句为<code>update T set c=1 where id=2</code>。</p>
<p>假设执行过程中写完<code>redo log</code>日志后，<code>binlog</code>日志写期间发生了异常，由于<code>binlog</code>没写完就异常，这时候<code>binlog</code>里面没有对应的修改记录。因此，之后用<code>binlog</code>日志恢复数据时，就会少这一次更新，恢复出来的这一行<code>c</code>值是<code>0</code>，而原库因为<code>redo log</code>日志恢复，这一行<code>c</code>值是<code>1</code>，最终数据不一致。</p>
<p>为了解决两份日志之间的逻辑一致问题，<code>InnoDB</code>存储引擎使用<strong>两阶段提交</strong>方案。</p>
<p>原理很简单，将<code>redo log</code>的写入拆成了两个步骤<code>prepare</code>和<code>commit</code>，这就是<strong>两阶段提交</strong>。</p>
<ol>
<li><p>使用<strong>两阶段提交</strong>后，写入<code>binlog</code>时发生异常也不会有影响，因为<code>MySQL</code>根据<code>redo log</code>日志恢复数据时，发现<code>redo log</code>还处于<code>prepare</code>阶段，并且没有对应<code>binlog</code>日志，就会回滚该事务。</p>
<p><img src="E:\学习笔记\图片\image-20220717152648764.png" alt="image-20220717152648764"></p>
</li>
<li><p><code>redo log</code>设置<code>commit</code>阶段发生异常，那会不会回滚事务呢？</p>
<img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20220717152745446.png" alt="image-20220717152745446" style="zoom:150%;" />

<p>并不会回滚事务，它会执行上图框住的逻辑，虽然<code>redo log</code>是处于<code>prepare</code>阶段，但是能通过事务<code>id</code>找到对应的<code>binlog</code>日志，所以<code>MySQL</code>认为是完整的，就会提交事务恢复数据。</p>
</li>
</ol>
<p><strong>其他：</strong></p>
<p>redo 和 binlog的对比</p>
<p>　　二进制日志的作用之一是还原数据库的，这与redo log很类似，很多人混淆过，但是两者有本质的不同</p>
<p>　　<strong>作用不同</strong>：redo log是保证事务的持久性的，是事务层面的，binlog作为还原的功能，是数据库层面的（当然也可以精确到事务层面的），虽然都有还原的意思，但是其保护数据的层次是不一样的。</p>
<p>　　<strong>内容不同</strong>：redo log是物理日志，是数据页面的修改之后的物理记录，binlog是逻辑日志，可以简单认为记录的就是sql语句</p>
<p>　　另外，两者日志产生的时间，可以释放的时间，在可释放的情况下清理机制，都是完全不同的。</p>
<p>　　恢复数据时候的效率，基于物理日志的redo log恢复数据的效率要高于语句逻辑日志的binlog</p>
<p>　　关于事务提交时，redo log和binlog的写入顺序，为了保证主从复制时候的主从一致（当然也包括使用binlog进行基于时间点还原的情况），是要严格一致的，MySQL通过两阶段提交过程来完成事务的一致性的，也即redo log和binlog的一致性的，理论上是先写redo log，再写binlog，两个日志都提交成功（刷入磁盘），事务才算真正的完成。</p>
<h3 id="4：错误日志（errorlog）"><a href="#4：错误日志（errorlog）" class="headerlink" title="4：错误日志（errorlog）"></a>4：<strong>错误日志（errorlog）</strong></h3><h3 id="5：慢查询日志（slow-query-log）"><a href="#5：慢查询日志（slow-query-log）" class="headerlink" title="5：慢查询日志（slow query log）"></a>5：<strong>慢查询日志（slow query log）</strong></h3><h3 id="6：一般查询日志（general-log）"><a href="#6：一般查询日志（general-log）" class="headerlink" title="6：一般查询日志（general log）"></a>6：<strong>一般查询日志（general log）</strong></h3><h3 id="7：中继日志（relay-log）。"><a href="#7：中继日志（relay-log）。" class="headerlink" title="7：中继日志（relay log）。"></a>7：<strong>中继日志（relay log）。</strong></h3><h2 id="13-MVCC（多版本并发控制）"><a href="#13-MVCC（多版本并发控制）" class="headerlink" title="13.MVCC（多版本并发控制）"></a>13.MVCC（多版本并发控制）</h2><h3 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC"></a>什么是MVCC</h3><p>全称Multi-Version Concurrency Control，即多版本并发控制，主要是为了提高数据库的并发性能。以下文章都是围绕InnoDB引擎来讲，因为myIsam不支持事务。</p>
<p>同一行数据平时发生读写请求时，会上锁阻塞住。但mvcc用更好的方式去处理读—写请求，做到在发生读—写请求冲突时不用加锁。</p>
<p>这个读是指的快照读，而不是当前读，当前读是一种加锁操作，是悲观锁。</p>
<h3 id="什么是MySQL-InnoDB下的当前读和快照读？"><a href="#什么是MySQL-InnoDB下的当前读和快照读？" class="headerlink" title="什么是MySQL InnoDB下的当前读和快照读？"></a>什么是MySQL InnoDB下的当前读和快照读？</h3><p><strong>当前读</strong><br>它读取的数据库记录，都是当前最新的版本，会对当前读取的数据进行加锁，防止其他事务修改数据。是悲观锁的一种操作。</p>
<p>如下操作都是当前读：</p>
<p>select lock in share mode (共享锁)</p>
<p>select for update (排他锁)</p>
<p>update (排他锁)</p>
<p>insert (排他锁)</p>
<p>delete (排他锁)</p>
<p>串行化事务隔离级别</p>
<p><strong>快照读</strong><br>快照读的实现是基于多版本并发控制，即MVCC，既然是多版本，那么快照读读到的数据不一定是当前最新的数据，有可能是之前历史版本的数据。</p>
<p>如下操作是快照读：</p>
<p>不加锁的select操作（注：事务级别不是串行化）</p>
<p>快照读与mvcc的关系</p>
<p><strong>MVCC是“维持一个数据的多个版本，使读写操作没有冲突”的一个抽象概念。</strong></p>
<p><strong>这个概念需要具体功能去实现，这个具体实现就是快照读。</strong>（具体实现下面讲）</p>
<p><strong>数据库并发场景</strong></p>
<ul>
<li>读-读：不存在任何问题，也不需要并发控制</li>
<li>读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读</li>
<li>写-写：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失</li>
</ul>
<p><strong>MVCC解决并发哪些问题？</strong></p>
<p>mvcc用来解决读—写冲突的无锁并发控制，就是为事务分配单向增长的时间戳。为每个数据修改保存一个版本，版本与事务时间戳相关联。</p>
<p>读操作只读取该事务开始前的数据库快照。</p>
<p>解决问题如下：</p>
<p>并发读-写时：可以做到读操作不阻塞写操作，同时写操作也不会阻塞读操作。</p>
<p>解决脏读、幻读、不可重复读等事务隔离问题，但不能解决上面的写-写 更新丢失问题。</p>
<p>因此有了下面提高并发性能的<strong>组合拳</strong>：</p>
<p>MVCC + 悲观锁：MVCC解决读写冲突，悲观锁解决写写冲突</p>
<p>MVCC + 乐观锁：MVCC解决读写冲突，乐观锁解决写写冲突</p>
<h3 id="MVCC的实现原理"><a href="#MVCC的实现原理" class="headerlink" title="MVCC的实现原理"></a>MVCC的实现原理</h3><p>它的实现原理主要是版本链，undo日志 ，Read View 来实现的</p>
<h4 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a><strong>版本链</strong></h4><p>我们数据库中的每行数据，除了我们肉眼看见的数据，还有几个隐藏字段，得开天眼才能看到。分别是db_trx_id、db_roll_pointer、db_row_id。</p>
<p><strong>db_trx_id</strong></p>
<p>6byte，最近修改(修改&#x2F;插入)事务ID：记录创建这条记录&#x2F;最后一次修改该记录的事务ID。</p>
<p><strong>事务id什么时候创建的？</strong><br>如果某个事务执行过程中对某个表执行了增、删、改操作，那么InnoDB存储引擎就会给它分配一个独一无二的事务id，分配方式如下：</p>
<ul>
<li>对于只读事务来说，只有在它第一次对某个用户创建的临时表执行增、删、改操作时才会为这个事务分配一个事务id，否则的话是不分配事务id的。</li>
<li>对于读写事务来说，只有在它第一次对某个表（包括用户创建的临时表）执行增、删、改操作时才会为这个事务分配一个事务id，否则的话也是不分配事务id的。</li>
</ul>
<p><strong>db_roll_pointer（版本链关键）</strong></p>
<p>7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）</p>
<p><strong>db_row_id</strong></p>
<p>6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以db_row_id产生一个聚簇索引。</p>
<p>实际还有一个删除flag隐藏字段, 记录被更新或删除并不代表真的删除，而是删除flag变了</p>
<p><img src="E:\学习笔记\图片\7d239fc720ed0f548d4d994272398847-2.png" alt="img"><br>如上图，db_row_id是数据库默认为该行记录生成的唯一隐式主键，db_trx_id是当前操作该记录的事务ID，而db_roll_pointer是一个回滚指针，用于配合undo日志，指向上一个旧版本。</p>
<p>每次对数据库记录进行改动，都会记录一条undo日志，每条undo日志也都有一个roll_pointer属性（INSERT操作对应的undo日志没有该属性，因为该记录并没有更早的版本），可以将这些undo日志都连起来，串成一个链表，所以现在的情况就像下图一样：</p>
<p><img src="E:\学习笔记\图片\7d239fc720ed0f548d4d994272398847-3.png" alt="img"><br>对该记录每次更新后，都会将旧值放到一条undo日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被roll_pointer属性连接成一个链表，我们把这个链表称之为版本链，版本链的头节点就是当前记录最新的值。另外，每个版本中还包含生成该版本时对应的事务id，这个信息很重要，在根据ReadView判断版本可见性的时候会用到。</p>
<h4 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a><strong>undo日志</strong></h4><p>Undo log 主要用于记录数据被修改之前的日志，在表信息修改之前先会把数据拷贝到undo log里。</p>
<p>当事务进行回滚时可以通过undo log 里的日志进行数据还原。</p>
<p><strong>Undo log 的用途</strong></p>
<p>保证事务进行rollback时的原子性和一致性，当事务进行回滚的时候可以用undo log的数据进行恢复。</p>
<p>用于MVCC快照读的数据，在MVCC多版本控制中，通过读取undo log的历史版本数据可以实现不同事务版本号都拥有自己独立的快照数据版本。</p>
<p><strong>undo log主要分为两种：</strong></p>
<p><strong>insert undo log</strong></p>
<p>代表事务在insert新记录时产生的undo log , 只在事务回滚时需要，并且在事务提交后可以被立即丢弃</p>
<p><strong>update undo log（主要）</strong></p>
<p>事务在进行update或delete时产生的undo log ; 不仅在事务回滚时需要，在快照读时也需要；</p>
<p>所以不能随便删除，只有在快照读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除</p>
<h4 id="Read-View-读视图"><a href="#Read-View-读视图" class="headerlink" title="Read View(读视图)"></a><strong>Read View(读视图)</strong></h4><p>事务进行快照读操作的时候生产的读视图(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照。</p>
<p>记录并维护系统当前活跃事务的ID(没有commit，当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以越新的事务，ID值越大)，是系统中当前不应该被本事务看到的其他事务id列表。</p>
<p><strong>Read View主要是用来做可见性判断的,</strong> 即当我们某个事务执行快照读的时候，对该记录创建一个Read View读视图，<strong>把它当做条件用来判断当前事务能够看到哪个版本的数据</strong>，既可能是当前最新的数据，也有可能是该行记录的undo log里面的某个版本的数据。</p>
<p><strong>Read View几个属性</strong></p>
<p><strong>trx_ids</strong>: 当前系统活跃(未提交)事务版本号集合，数据结构为List。</p>
<p><strong>max_limit_id</strong>: 创建当前read view 时，“当前系统最大的事务版本号+1”。</p>
<p><strong>min_limit_id</strong>: 创建当前read view 时“系统正处于活跃的事务最小版本号”，即trx_ids中的最小值</p>
<p><strong>creator_trx_id</strong>: 创建当前read view的事务版本号；</p>
<p><strong>RC、RR隔离级别下，生成ReadView的时机</strong></p>
<ul>
<li>READ UNCOMMITTED：不会生成ReadView，直接读取记录的最新版本即可。</li>
<li>READ COMMITTD：在每一次进行普通SELECT操作前都会生成一个ReadView。</li>
<li>REPEATABLE READ：只有第一次进行普通SELECT操作前生成一个ReadView，之后复用同一ReadView。</li>
</ul>
<h4 id="Read-View可见性判断条件"><a href="#Read-View可见性判断条件" class="headerlink" title="Read View可见性判断条件"></a>Read View可见性判断条件</h4><ol>
<li>如果数据事务ID <code>db_trx_id &lt; min_limit_id</code>，表明生成该版本的事务在生成Read View前，已经提交(因为事务ID是递增的)，所以该版本可以被当前事务访问。</li>
<li>如果<code>db_trx_id&gt;= max_limit_id</code>，表明生成该版本的事务在生成ReadView后才生成，所以该版本不可以被当前事务访问。</li>
<li>如果 <code>db_trx_id</code>包含在活跃事务中,需要分3种情况讨论</li>
</ol>
<blockquote>
<ul>
<li>（1）如果<code>trx_ids</code>包含<code>db_trx_id</code>,则代表Read View生成时刻，这个事务还未提交，但是如果数据的<code>trx_id</code>等于<code>creator_trx_id</code>的话，表明数据是自己生成的，因此是<strong>可见</strong>的。</li>
<li>（2）如果<code>trx_ids</code>包含<code>db_trx_id</code>，并且<code>db_trx_id</code>不等于<code>creator_trx_id</code>，则Read   View生成时，事务未提交，并且不是自己生产的，所以当前事务也是<strong>看不见</strong>的；</li>
<li>（3）如果<code>trx_ids</code>不包含<code>db_trx_id</code>，则说明你这个事务在Read View生成之前就已经提交了，修改的结果，当前事务是能看见的。</li>
</ul>
</blockquote>
<p>MVCC和事务隔离级别<br>上面所讲的Read View用于支持RC（Read Committed，读提交）和RR（Repeatable Read，可重复读）隔离级别的实现。</p>
<p>RR、RC生成时机<br>RC隔离级别下，是每个快照读都会生成并获取最新的Read View；</p>
<p>而在RR隔离级别下，则是同一个事务中的第一个快照读才会创建Read View, 之后的快照读获取的都是同一个Read View，之后的查询就不会重复生成了，所以一个事务的查询结果每次都是一样的。</p>
<p><strong>解决幻读问题</strong><br>快照读：通过MVCC来进行控制的，不用加锁。按照MVCC中规定的“语法”进行增删改查等操作，以避免幻读。</p>
<p>当前读：通过next-key锁（行锁+gap锁）来解决问题的。</p>
<p><strong>RC、RR级别下的InnoDB快照读区别</strong><br>在RR级别下的某个事务的对某条记录的第一次快照读会创建一个快照及Read View， 将当前系统活跃的其他事务记录起来，此后在调用快照读的时候，还是使用的是同一个Read View，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个Read View，所以对之后的修改不可见；</p>
<p><strong>即RR级别下，快照读生成Read View时，Read View会记录此时所有其他活动事务的快照，这些事务的修改对于当前事务都是不可见的。而早于Read View创建的事务所做的修改均是可见</strong></p>
<p>而在RC级别下的事务中，每次快照读都会新生成一个快照和Read View, 这就是我们在RC级别下的事务中可以看到别的事务提交的更新的原因。</p>
<h3 id="查询一条记录，基于MVCC，是怎样的流程"><a href="#查询一条记录，基于MVCC，是怎样的流程" class="headerlink" title="查询一条记录，基于MVCC，是怎样的流程"></a>查询一条记录，基于MVCC，是怎样的流程</h3><ol>
<li>获取事务自己的版本号，即事务ID</li>
<li>获取Read View</li>
<li>查询得到的数据，然后Read View中的事务版本号进行比较。</li>
<li>如果不符合Read View的可见性规则， 即就需要Undo log中历史快照;</li>
<li>最后返回符合规则的数据</li>
</ol>
<h3 id="读已提交（RC）隔离级别，存在不可重复读问题的分析历程"><a href="#读已提交（RC）隔离级别，存在不可重复读问题的分析历程" class="headerlink" title="读已提交（RC）隔离级别，存在不可重复读问题的分析历程"></a>读已提交（RC）隔离级别，存在不可重复读问题的分析历程</h3><ol>
<li>创建core_user表，插入一条初始化数据,如下：</li>
</ol>
<p><img src="E:\学习笔记\图片\6691d9ce1ea64b1b8ad15f34041f2d8d_tplv-k3u1fbpfcp-zoom-in-crop-mark_1304_0_0_0.awebp" alt="img"></p>
<ol>
<li>隔离级别设置为读已提交（RC），事务A和事务B同时对core_user表进行查询和修改操作。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">事务A: select * fom core_user where id=1</span><br><span class="line">事务B: update core_user set name =”曹操”</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>执行流程如下：</p>
<p><img src="E:\学习笔记\图片\2801bebf19494f4289a449c6625b7dcf_tplv-k3u1fbpfcp-zoom-in-crop-mark_1304_0_0_0.awebp" alt="img"></p>
<p>最后事务A查询到的结果是，<strong>name&#x3D;曹操</strong>的记录，我们<strong>基于MVCC</strong>，来分析一下执行流程：</p>
<p>(1). A开启事务，首先得到一个事务ID为100</p>
<p>(2).B开启事务，得到事务ID为101</p>
<p>(3).事务A生成一个Read View，read view对应的值如下</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>trx_ids</td>
<td>100，101</td>
</tr>
<tr>
<td>max_limit_id</td>
<td>102</td>
</tr>
<tr>
<td>min_limit_id</td>
<td>100</td>
</tr>
<tr>
<td>creator_trx_id</td>
<td>100</td>
</tr>
</tbody></table>
<p>然后回到版本链：开始从版本链中挑选可见的记录：</p>
<p><img src="E:\学习笔记\图片\c1141a8679704c259649b63c9753054b_tplv-k3u1fbpfcp-zoom-in-crop-mark_1304_0_0_0.awebp" alt="版本链"></p>
<p>由图可以看出，最新版本的列name的内容是<code>孙权</code>，该版本的<code>trx_id</code>值为100。开始执行read view可见性规则校验：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min_limit_id(100)=&lt;trx_id（100）&lt;102;</span><br><span class="line">creator_trx_id = trx_id =100;</span><br></pre></td></tr></table></figure>

<p>由此可得，trx_id&#x3D;100的这个记录，当前事务是可见的。所以查到是name为<code>孙权</code>的记录。</p>
<p>（4). 事务B进行修改操作，把名字改为曹操。把原数据拷贝到undo log,然后对数据进行修改，标记事务ID和上一个数据版本在undo log的地址。</p>
<p><img src="E:\学习笔记\图片\81a6e0d3575041c19992747e5eeeebe2_tplv-k3u1fbpfcp-zoom-in-crop-mark_1304_0_0_0.awebp" alt="img"></p>
<p>(5) 提交事务</p>
<p>(6) 事务A再次执行查询操作，<strong>新生成一个Read View</strong>，Read View对应的值如下</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>trx_ids</td>
<td>100</td>
</tr>
<tr>
<td>max_limit_id</td>
<td>102</td>
</tr>
<tr>
<td>min_limit_id</td>
<td>100</td>
</tr>
<tr>
<td>creator_trx_id</td>
<td>100</td>
</tr>
</tbody></table>
<p>然后再次回到版本链：从版本链中挑选可见的记录：</p>
<p><img src="E:\学习笔记\图片\9467257ba46f4eaebce01eb9a68ef13f_tplv-k3u1fbpfcp-zoom-in-crop-mark_1304_0_0_0.awebp" alt="img"></p>
<p>从图可得，最新版本的列name的内容是<code>曹操</code>，该版本的<code>trx_id</code>值为101。开始执行Read View可见性规则校验：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min_limit_id(100)=&lt;trx_id（101）&lt;max_limit_id（102);</span><br><span class="line">但是,trx_id=101，不属于trx_ids集合</span><br></pre></td></tr></table></figure>

<p>因此，<code>trx_id=101</code>这个记录，对于当前事务是可见的。所以SQL查询到的是name为<code>曹操</code>的记录。</p>
<p>综上所述，在<strong>读已提交（RC）隔离级别</strong>下，同一个事务里，两个相同的查询，读取同一条记录（id&#x3D;1），却返回了不同的数据（<strong>第一次查出来是孙权，第二次查出来是曹操那条记录</strong>），因此RC隔离级别，存在<strong>不可重复读</strong>并发问题。</p>
<h3 id="可重复读（RR）隔离级别，解决不可重复读问题的分析"><a href="#可重复读（RR）隔离级别，解决不可重复读问题的分析" class="headerlink" title="可重复读（RR）隔离级别，解决不可重复读问题的分析"></a>可重复读（RR）隔离级别，解决不可重复读问题的分析</h3><p>在RR隔离级别下，是如何解决不可重复读问题的呢？我们一起再来看下，</p>
<p>还是4.2小节那个流程，还是这个事务A和事务B，如下：</p>
<p><img src="E:\学习笔记\图片\1397758a985b47f5be81b0750e262012_tplv-k3u1fbpfcp-zoom-in-crop-mark_1304_0_0_0.awebp" alt="img"></p>
<h3 id="不同隔离级别下，Read-view的工作方式不同"><a href="#不同隔离级别下，Read-view的工作方式不同" class="headerlink" title="不同隔离级别下，Read view的工作方式不同"></a>不同隔离级别下，Read view的工作方式不同</h3><p>实际上，各种事务隔离级别下的Read view工作方式，是不一样的，RR可以解决不可重复读问题，就是跟<strong>Read view工作方式有关</strong>。</p>
<ul>
<li>在读已提交（RC）隔离级别下，同一个事务里面，<strong>每一次查询都会产生一个新的Read View副本</strong>，这样就可能造成同一个事务里前后读取数据可能不一致的问题（不可重复读并发问题）。</li>
</ul>
<table>
<thead>
<tr>
<th>begin</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>select * from core_user where id &#x3D;1</td>
<td>生成一个Read View</td>
</tr>
<tr>
<td>&#x2F;</td>
<td>&#x2F;</td>
</tr>
<tr>
<td>&#x2F;</td>
<td>&#x2F;</td>
</tr>
<tr>
<td>select * from core_user where id &#x3D;1</td>
<td>生成一个Read View</td>
</tr>
</tbody></table>
<ul>
<li>在可重复读（RR）隔离级别下，<strong>一个事务里只会获取一次read view</strong>，都是副本共用的，从而保证每次查询的数据都是一样的。</li>
</ul>
<table>
<thead>
<tr>
<th>begin</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>select * from core_user where id &#x3D;1</td>
<td>生成一个Read View</td>
</tr>
<tr>
<td>&#x2F;</td>
<td></td>
</tr>
<tr>
<td>&#x2F;</td>
<td></td>
</tr>
<tr>
<td>select * from core_user where id &#x3D;1</td>
<td>共用一个Read View副本</td>
</tr>
</tbody></table>
<h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><p>我们穿越下，回到<strong>刚4.2的例子</strong>，然后执行第2个查询的时候：</p>
<p>事务A再次执行查询操作，复用老的Read View副本，Read View对应的值如下</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>m_ids</td>
<td>100，101</td>
</tr>
<tr>
<td>max_limit_id</td>
<td>102</td>
</tr>
<tr>
<td>min_limit_id</td>
<td>100</td>
</tr>
<tr>
<td>creator_trx_id</td>
<td>100</td>
</tr>
</tbody></table>
<p>然后再次回到版本链：从版本链中挑选可见的记录：</p>
<p><img src="E:\学习笔记\图片\ee46d54f9d48428187a9403bd5fde927_tplv-k3u1fbpfcp-zoom-in-crop-mark_1304_0_0_0.awebp" alt="img"></p>
<p>从图可得，最新版本的列name的内容是<code>曹操</code>，该版本的<code>trx_id</code>值为101。开始执行read view可见性规则校验：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">min_limit_id(100)=&lt;trx_id（101）&lt;max_limit_id（102);</span><br><span class="line">因为m_ids&#123;100,101&#125;包含trx_id（101），</span><br><span class="line">并且creator_trx_id (100) 不等于trx_id（101）</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>所以，<code>trx_id=101</code>这个记录，对于当前事务是<strong>不可见</strong>的。这时候呢，版本链<code>roll_pointer</code>跳到下一个版本，<code>trx_id=100</code>这个记录，再次校验是否可见：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">min_limit_id(100)=&lt;trx_id（100）&lt; max_limit_id（102);</span><br><span class="line">因为m_ids&#123;100,101&#125;包含trx_id（100），</span><br><span class="line">并且creator_trx_id (100) 等于trx_id（100）</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>所以，<code>trx_id=100</code>这个记录，对于当前事务是<strong>可见</strong>的。即在可重复读（RR）隔离级别下，复用老的Read View副本，解决了<strong>不可重复读</strong>的问题。</p>
<h3 id="MVCC只能在一定程度上解决幻读"><a href="#MVCC只能在一定程度上解决幻读" class="headerlink" title="MVCC只能在一定程度上解决幻读"></a>MVCC只能在一定程度上解决幻读</h3><p>通过<code>MVCC</code>我们仅可以避免<strong>只读查询</strong>时的幻读；考虑如下在并发场景下两个事务下的<strong>非只读查询</strong>(按照时间线先后排序)：</p>
<p>开启事务A，并查询<code>blog</code>表，发现此时该表中存在一行数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from blog where id &lt; 5; </span><br><span class="line">+----+-----------------+--------------+</span><br><span class="line">| id | secondary_index | normal_field |</span><br><span class="line">+----+-----------------+--------------+</span><br><span class="line">|  1 | index_text1     | normal_text1 |</span><br><span class="line">+----+-----------------+--------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>另外开启事务B，插入一条<code>id=2</code>的数据并进行提交：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from blog;</span><br><span class="line">+----+-----------------+--------------+</span><br><span class="line">| id | secondary_index | normal_field |</span><br><span class="line">+----+-----------------+--------------+</span><br><span class="line">|  1 | index_text1     | normal_text1 |</span><br><span class="line">+----+-----------------+--------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into blog (secondary_index, normal_field) values (&quot;index_text2&quot;, &quot;normal_text2&quot;);</span><br><span class="line">Query OK, 1 row affected (0.28 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from blog;</span><br><span class="line">+----+-----------------+--------------+</span><br><span class="line">| id | secondary_index | normal_field |</span><br><span class="line">+----+-----------------+--------------+</span><br><span class="line">|  1 | index_text1     | normal_text1 |</span><br><span class="line">|  2 | index_text2     | normal_text2 |</span><br><span class="line">+----+-----------------+--------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; commit;</span><br><span class="line">Query OK, 0 rows affected (0.06 sec)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>此时在事务A中修改所有<code>id&lt;5</code>的<code>secondary_index</code>的值变为<code>mvcc</code>，然后查询<code>blog</code>表中的数据发现多了<code>id=2</code>的行数据-（产生幻影读问题）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update blog set secondary_index = &quot;mvcc&quot; where id &lt; 5;</span><br><span class="line">Query OK, 2 rows affected (5.66 sec)</span><br><span class="line">Rows matched: 2  Changed: 2  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from blog;</span><br><span class="line">+----+-----------------+--------------+</span><br><span class="line">| id | secondary_index | normal_field |</span><br><span class="line">+----+-----------------+--------------+</span><br><span class="line">|  1 | mvcc            | normal_text1 |</span><br><span class="line">|  2 | mvcc            | normal_text2 |</span><br><span class="line">+----+-----------------+--------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; commit;</span><br><span class="line">Query OK, 0 rows affected (0.06 sec)</span><br></pre></td></tr></table></figure>

<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p><strong>RR隔离级别</strong>下，因为在一个事务<strong>运行过程中</strong>，只有<strong>在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，并且重新生成一个<code>ReadView</code><strong>。然后我们根据<code>MVCC ReadView</code>中</strong>判断数据行对当前事务是否可见</strong>的方式进行判断，因为事务A运行<code>update</code>语句是在事务B提交之后，因此事务A被分配到的<code>trx_id</code>是大于事务B的，因此在重新生成的<code>ReadView</code>中，事务B的改动对于事务A是可见的。</p>
<p>所以<code>MVCC</code>只能解决部分幻读问题，而根源解决幻读问题还是通过锁机制-**谓词锁与<code>Next-Key Lock</code>**，其中<code>Next-Key Lock</code>是对谓词锁的优化。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>从以上的描述中我们可以看出来，所谓的MVCC指的就是在使用READ COMMITTD、REPEATABLE READ这两种隔离级别的事务在执行普通的SEELCT操作时访问记录的版本链的过程，这样子可以使不同事务的读-写、写-读操作并发执行，从而提升系统性能。</p>
<h2 id="14-MySQL的Server层与引擎层"><a href="#14-MySQL的Server层与引擎层" class="headerlink" title="14.MySQL的Server层与引擎层"></a>14.MySQL的Server层与引擎层</h2><img src="E:/面试/myJava.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly95YW5nd2VucWlhbmcuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70.png" alt="img" style="zoom: 50%;" />

<p><strong>【Server层】</strong></p>
<ul>
<li><strong>连接器</strong>：每一个客户端都是和Server层的连接器建立连接，连接器负责客户端与数据库建立连接，获取权限，维持和管理连接。</li>
<li><strong>查询缓存</strong>：在每一次的查询时，我们都先去看看是否命中缓存，命中则直接返回，提高了系统的响应速度。但是这个功能有一个相当大的弊病，那就是一旦这个表中数据发生更改，那么这张表对应的所有缓存都会失效。对于更新压力大的数据库来说，查询缓存的命中率会非常低。</li>
<li><strong>分析器</strong>：系统在真正执行你输入的语句之前，必须分析出你的语句想要干嘛？首先通过select关键字得知这是一条查询命令，还包括分析你要查询的是哪张表以及查询条件是什么？同时，分析器必须分析你输入语句的语法正确性。</li>
<li><strong>优化器</strong>：优化器是MySQL用来对你输入的语句在真正执行之前所做的最后一步优化。优化内容包括：选择哪个索引？是否选择索引？多表查询的联合顺序等。 每一种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。</li>
<li><strong>执行器</strong>：MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。<del>开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误。</del></li>
</ul>
<p><strong>【引擎层】</strong></p>
<ul>
<li>MySQL的存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。</li>
</ul>
<h2 id="15-数据表字段扩展"><a href="#15-数据表字段扩展" class="headerlink" title="15.数据表字段扩展"></a>15.数据表字段扩展</h2><ol>
<li><p>动态添加属性字段。</p>
<p>当数据库中需要增加一个字段的时候，直接在数据库中增加，并修改相应的代码。</p>
<p>​    <strong>优点：</strong>操作简单，易懂</p>
<p>​    <strong>缺点：</strong>每增加一个字段都需要修改数据库表结构，修改代码。而且在一张大表进行操作的时候，还可能需要很长时间。</p>
</li>
<li><p>先预留字段，到时再用。</p>
<p><strong>优点</strong>：简单，支持索引<br><strong>缺点</strong>：太少可能起不到作用，太多也不行，影响性能</p>
</li>
<li><p>使用 XML 字段保存。</p>
</li>
<li><p>JSON 格式保存。</p>
<p>把需要扩展的字段统一放到一个字段里面。各个字段通过JSON的方式组成一个大的字符串。这样在扩展字段的时候，只需要修改这个JSON即可。</p>
<p><strong>优点</strong>：增加，修改，删除字段都很方便</p>
<p><strong>缺点</strong>：查询简直是灾难，特别是涉及到关联查询，需要对JSON里面的字段建索引，根据JSON 里面的字段进行排序时，很难操作。</p>
</li>
<li><p>属性字段行存储</p>
<p>将属性作为行记录进行存储，将动态变化的字段放在新的表中，增加一个新的字段，在表中增加一条记录。</p>
<p> <strong>优点：</strong>不需要修改表结构。</p>
<p> <strong>缺点：</strong>因为会有很多这样的属性字段表，或者一个属性字段表，会产生很复杂的关联查询语句</p>
<p>例如：<img src="E:\学习笔记\图片\image-20220819100248661.png" alt="image-20220819100248661"></p>
<p><img src="E:\学习笔记\图片\image-20220819100438045.png" alt="image-20220819100438045"></p>
</li>
</ol>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="1-手写死锁"><a href="#1-手写死锁" class="headerlink" title="1.手写死锁"></a>1.手写死锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeathLock</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">garlic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">vinegar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (vinegar) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;ThreadA... wait B.&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (garlic) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;B come...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (garlic) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;ThreadB... wait A.&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (vinegar) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;A come...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DeathLock</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeathLock</span>();</span><br><span class="line">        <span class="type">DeathLock</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeathLock</span>();</span><br><span class="line">        threadA.flag = <span class="number">0</span>;</span><br><span class="line">        threadB.flag = <span class="number">1</span>;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">tA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(threadA);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">tB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(threadB);</span><br><span class="line">        tA.start();</span><br><span class="line">        tB.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-进程和线程通信"><a href="#2-进程和线程通信" class="headerlink" title="2.进程和线程通信"></a>2.进程和线程通信</h2><h3 id="2-1进程间的通信方式（同步方式）"><a href="#2-1进程间的通信方式（同步方式）" class="headerlink" title="2.1进程间的通信方式（同步方式）"></a>2.1进程间的通信方式（同步方式）</h3><p>​	要注意这里的同步并不是指同时进行的意思，而是按照先后顺序依次进行。 </p>
<p>首先了解一下同步与互斥的概念：</p>
<p>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系； </p>
<p>互斥：多个进程在同一时刻只有一个进程能进入临界区。</p>
<p><strong>进程同步和通信的关系</strong></p>
<p><strong>进程同步</strong>就是控制多个进程按一定顺序执行，而<strong>进程间通信</strong>（IPC）是在进程间传输信息。它们之间的关系是：进程通信是一种手段，而进程同步是一种目的，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。借用知乎某佬的一句话：<br>不要当那种考试考傻了的书呆子，把“同步”和“通信”的概念分得那么清楚，能通信就一定是一种同步机制，这是显而易见的。</p>
<p>所以面试官问你进程同步的方式时，他的意思其实是让你回答进程间的通信方式。常用的进程通信方式如下：</p>
<ul>
<li><p>管道&#x2F;匿名管道(Pipes) ：用于具有亲缘关系的<strong>父子进程间</strong>或者兄弟进程之间的通信，<strong>管道就是一只存在于内存中的文件</strong>。</p>
</li>
<li><p>有名管道(Names Pipes) : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循先进先出(first in first out)。有名管道以磁盘文件的方式存在，可以实现本机<strong>任意两个进程通信</strong>，<strong>存在于实际的磁盘介质或者文件系统</strong>。</p>
</li>
<li><p>共享内存(Shared memory) ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。</p>
</li>
<li><p>信号(Signal) ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；是进程通信机制中唯一的<strong>异步</strong>通信机制。</p>
</li>
<li><p>信号量(Semaphores) ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。</p>
</li>
<li><p>消息队列(Message Queuing) ：消息队列是消息的链表,具有特定的格式，存放在内存中并由消息队列标识符标识。<strong>存放在内存中的消息的链表，而消息本质上是用户自定义的数据结构</strong></p>
<p>管道和消息队列的通信数据都是先进先出的原则。<strong>与管道（</strong>无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）<strong>不同的是消息队列存放在内核中</strong>，只有在内核重启(即，操作系统重启)或者显式地删除一个消息队列时，该消息队列才会被真正的删除。<strong>消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取。</strong>比 FIFO 更有优势。消息队列克服了信号承载信息量少，<strong>管道只能承载无格式字节流</strong>以及缓冲区大小受限等缺点。</p>
<p>用户进程写入数据到内存中的消息队列时，会发生从用户态<strong>拷贝</strong>数据到内核态的过程；同样的，另一个用户进程读取内存中的消息数据时，会发生从内核态拷贝数据到用户态的过程。因此，<strong>如果数据量较大，使用消息队列就会造成频繁的系统调用，也就是需要消耗更多的时间以便内核介入</strong>。</p>
</li>
<li><p>套接字(Sockets) : 可用于不同主机之间的进程间通信。</p>
</li>
</ul>
<h3 id="2-2线程间的通信方式（同步方式）"><a href="#2-2线程间的通信方式（同步方式）" class="headerlink" title="2.2线程间的通信方式（同步方式）"></a>2.2线程间的通信方式（同步方式）</h3><p>线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。操作系统一般有下面三种线程同步的方式：</p>
<ul>
<li>互斥量(Mutex)：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。</li>
<li>信号量(Semaphore) ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</li>
<li>事件(Event) :Wait&#x2F;Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</li>
</ul>
<h2 id="3-I-x2F-O模型"><a href="#3-I-x2F-O模型" class="headerlink" title="3.I&#x2F;O模型"></a>3.I&#x2F;O模型</h2><h3 id="从TCP发送数据的流程说起"><a href="#从TCP发送数据的流程说起" class="headerlink" title="从TCP发送数据的流程说起"></a><strong>从TCP发送数据的流程说起</strong></h3><p>要深入的理解各种IO模型，那么必须先了解下产生各种IO的原因是什么，要知道这其中的本质问题那么我们就必须要知一条消息是如何从过一个人发送到另外一个人的；</p>
<p>以两个应用程序通讯为例，我们来了解一下当“A”向”B” 发送一条消息，简单来说会经过如下流程：</p>
<p><strong>第一步</strong>：应用A把消息发送到 TCP发送缓冲区。</p>
<p><strong>第二步：</strong> TCP发送缓冲区再把消息发送出去，经过网络传递后，消息会发送到B服务器的TCP接收缓冲区。</p>
<p><strong>第三步：</strong>B再从TCP接收缓冲区去读取属于自己的数据。</p>
<p><img src="E:\学习笔记\图片\v2-5311954c22d15ca91e47ab52168b7ada_720w.jpg" alt="img"></p>
<p>根据上图我们基本上了解消息发送要经过 应用A、应用A对应服务器的TCP发送缓冲区、经过网络传输后消息发送到了应用B对应服务器TCP接收缓冲区、然后最终B应用读取到消息。</p>
<p>如果理解了上面的消息发送流程，那么我们下面开始进入文章的主题；</p>
<hr>
<h3 id="阻塞IO-非阻塞IO"><a href="#阻塞IO-非阻塞IO" class="headerlink" title="阻塞IO |非阻塞IO"></a><strong>阻塞IO |非阻塞IO</strong></h3><p>我们把视角切换到上面图中的第三步， 也就是应用B从TCP缓冲区中读取数据。</p>
<p><img src="E:\学习笔记\图片\v2-cdd47940a292d8c4686570c7e128c235_720w.jpg" alt="img"></p>
<p><strong>思考一个问题：</strong></p>
<p>因为应用之间发送消息是间断性的，也就是说在上图中TCP缓冲区还没有接收到属于应用B该读取的消息时，那么此时应用B向TCP缓冲区发起读取申请，TCP接收缓冲区是应该马上告诉应用B现在没有你的数据，还是说让应用B在这里等着，直到有数据再把数据交给应用B。</p>
<p>把这个问题应用到第一个步骤也是一样，应用A在向TCP发送缓冲区发送数据时，如果TCP发送缓冲区已经满了，那么是告诉应用A现在没空间了，还是让应用A等待着，等TCP发送缓冲区有空间了再把应用A的数据访拷贝到发送缓冲区。</p>
<h4 id="什么是阻塞IO"><a href="#什么是阻塞IO" class="headerlink" title="什么是阻塞IO"></a><strong>什么是阻塞IO</strong></h4><p>如果上面的问题你已经思考过了，那么其实你已经明白了什么是阻塞IO了，所谓阻塞IO就是当应用B发起读取数据申请时，在内核数据没有准备好之前，应用B会一直处于等待数据状态，直到内核把数据准备好了交给应用B才结束。</p>
<p><strong>术语描述</strong>：在应用调用recvfrom读取数据时，其系统调用直到数据包到达且被复制到应用缓冲区中或者发送错误时才返回，在此期间一直会等待，进程从调用到返回这段时间内都是被阻塞的称为阻塞IO；</p>
<p><strong>流程：</strong></p>
<p>1、应用进程向内核发起recfrom读取数据。</p>
<p>2、准备数据报（应用进程阻塞）。</p>
<p>3、将数据从内核负责到应用空间。</p>
<p>4、复制完成后，返回成功提示。</p>
<p><img src="E:\学习笔记\图片\v2-abef476a75afe52193be9577dcbcb88a_720w.jpg" alt="img"></p>
<h4 id="什么是非阻塞IO"><a href="#什么是非阻塞IO" class="headerlink" title="什么是非阻塞IO"></a><strong>什么是非阻塞IO</strong></h4><p>我敢保证如果你已经理解了阻塞IO，那么必定已经知道了什么是非阻塞IO。按照上面的思路，所谓非阻塞IO就是当应用B发起读取数据申请时，如果内核数据没有准备好会即刻告诉应用B，不会让B在这里等待。</p>
<p><strong>术语</strong>：非阻塞IO是在应用调用recvfrom读取数据时，如果该缓冲区没有数据的话，就会直接返回一个EWOULDBLOCK错误，不会让应用一直等待中。在没有数据的时候会即刻返回错误标识，那也意味着如果应用要读取数据就需要不断的调用recvfrom请求，直到读取到它数据要的数据为止。</p>
<p><strong>流程：</strong></p>
<p>1、应用进程向内核发起recvfrom读取数据。</p>
<p>2、没有数据报准备好，即刻返回EWOULDBLOCK错误码。</p>
<p>3、应用进程向内核发起recvfrom读取数据。</p>
<p>4、已有数据包准备好就进行一下 步骤，否则还是返回错误码。</p>
<p>5、将数据从内核拷贝到用户空间。</p>
<p>6、完成后，返回成功提示。</p>
<hr>
<h3 id="IO复用模型"><a href="#IO复用模型" class="headerlink" title="IO复用模型"></a><strong>IO复用模型</strong></h3><p>如果你已经明白了非阻塞IO的工作模式，那么接下来我们继续了解IO复用模型的产生原因和思路。</p>
<p><strong>思考一个问题：</strong></p>
<p>我们还是把视角放到应用B从TCP缓冲区中读取数据这个环节来。如果在并发的环境下，可能会N个人向应用B发送消息，这种情况下我们的应用就必须创建多个线程去读取数据，每个线程都会自己调用recvfrom 去读取数据。那么此时情况可能如下图：</p>
<p><img src="E:\学习笔记\图片\v2-529734ac694c4da96ac78eeebd7deb6b_720w.jpg" alt="img"></p>
<p>如上图一样，并发情况下服务器很可能一瞬间会收到几十上百万的请求，这种情况下应用B就需要创建几十上百万的线程去读取数据，同时又因为应用线程是不知道什么时候会有数据读取，为了保证消息能及时读取到，那么这些线程自己必须不断的向内核发送recvfrom 请求来读取数据；</p>
<p>那么问题来了，这么多的线程不断调用recvfrom 请求数据，先不说服务器能不能扛得住这么多线程，就算扛得住那么很明显这种方式是不是太浪费资源了，线程是我们操作系统的宝贵资源，大量的线程用来去读取数据了，那么就意味着能做其它事情的线程就会少。</p>
<p>所以，有人就提出了一个思路，能不能提供一种方式，可以由一个线程监控多个网络请求（<strong>我们后面将称为fd文件描述符，linux系统把所有网络请求以一个fd来标识</strong>），这样就可以只需要一个或几个线程就可以完成数据状态询问的操作，当有数据准备就绪之后再分配对应的线程去读取数据，这么做就可以节省出大量的线程资源出来，这个就是IO复用模型的思路。</p>
<p><img src="E:\学习笔记\图片\v2-2c65fd3534e58d3a54cdeae778a31446_720w.jpg" alt="img"></p>
<p>正如上图，IO复用模型的思路就是系统提供了一种函数可以同时监控多个fd的操作，这个函数就是我们常说到的select、poll、epoll函数，有了这个函数后，应用线程通过调用select函数就可以同时监控多个fd，select函数监控的fd中只要有任何一个数据状态准备就绪了，select函数就会返回可读状态，这时询问线程再去通知处理数据的线程，对应线程此时再发起recvfrom请求去读取数据。</p>
<p><strong>术语描述：</strong>进程通过将一个或多个fd传递给select，阻塞在select操作上，select帮我们侦测多个fd是否准备就绪，当有fd准备就绪时，select返回数据可读状态，应用程序再调用recvfrom读取数据。</p>
<p><img src="E:\学习笔记\图片\v2-260e80cbec13cbcc677779690f6ab2fa_720w.jpg" alt="img"></p>
<p><strong>总结：</strong>复用IO的基本思路就是通过slect或poll、epoll 来监控多fd ，来达到不必为每个fd创建一个对应的监控线程，从而减少线程资源创建的目的。</p>
<h4 id="select、poll、epoll"><a href="#select、poll、epoll" class="headerlink" title="select、poll、epoll"></a><strong>select、poll、epoll</strong></h4><p>I&#x2F;O多路复用是指：通过一种机制，可以<strong>监视多个描述符</strong>，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。</p>
<p><strong>简述</strong>：</p>
<p><strong>(1)select&#x3D;&#x3D;&gt;时间复杂度O(n)</strong></p>
<p>它仅仅知道了，有I&#x2F;O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。</p>
<p><strong>(2)poll&#x3D;&#x3D;&gt;时间复杂度O(n)</strong></p>
<p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， 但是它没<strong>有最大连接数的限制</strong>，原因是它是基于链表来存储的.</p>
<p><strong>(3)epoll&#x3D;&#x3D;&gt;时间复杂度O(1)</strong></p>
<p>epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I&#x2F;O事件通知我们。所以我们说epoll实际上是事件驱动（每个事件关联上fd）的，此时我们对这些流的操作都是有意义的。（复杂度降低到了O(1)）</p>
<h5 id="1）select"><a href="#1）select" class="headerlink" title="1）select"></a>1）select</h5><p><strong>它通过一个select()系统调用来监视多个文件描述符的数组</strong>，<strong>对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低</strong>，当select()返回后，该数组中就绪的文件描述符便会被内核修改标志位，使得进程可以获得这些文件描述符从而进行后续的读写操作。</p>
<p>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点，事实上从现在看来，这也是它所剩不多的优点之一。</p>
<p><strong>缺点</strong>：</p>
<p>（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</p>
<p>（2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</p>
<p>（3）select支持的文件描述符数量太小了，默认是1024（不过可以通过修改宏定义甚至重新编译内核的方式提升这一限制）</p>
<p>另外，select()所维护的存储大量文件描述符的数据结构，随着文件描述符数量的增大，其复制的开销也线性增长。同时，由于网络响应时间的延迟使得大 量TCP连接处于非活跃状态，但调用select()会对所有socket进行一次线性扫描，所以这也浪费了一定的开销。</p>
<h5 id="2）poll"><a href="#2）poll" class="headerlink" title="2）poll"></a>2）poll</h5><p>poll的机制与select类似，与select在本质上没有多大差别，管理多个描述符也是进行<strong>轮询</strong>，根据描述符的状态进行处理，但是poll没有最大文件描述符数量的限制。poll和select同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。</p>
<p>另外，select()和poll()将就绪的文件描述符告诉进程后，如果进程没有对其进行IO操作，那么下次调用select()和poll()的时候 将 再次报告这些文件描述符，所以它们一般不会丢失就绪的消息，这种方式称为水平触发（Level Triggered）。</p>
<h5 id="3）epoll"><a href="#3）epoll" class="headerlink" title="3）epoll"></a>3）epoll</h5><p><strong>epoll可以同时支持水平触发和边缘触发</strong>（Edge Triggered，只告诉进程哪些文件描述符刚刚变为就绪状态，它只说一遍，如果我们没有采取行动，那么它将不会再次告知，这种方式称为边缘触发），理论上边缘触发的性能要更高一些，但是代码实现相当复杂。</p>
<p><strong>epoll同样只告知那些就绪的文件描述符</strong>，而且当我们调用epoll_wait()获得就绪文件描述符时，返回的不是实际的描述符，而是一个代表就绪描述符数量的值，你只需要去epoll指定的一个数组中依次取得相应数量的文件描述符即可，这里也使用了内存映射（mmap）技术，这样便彻底省掉了这些文件描述符在 系统调用时复制的开销。</p>
<p><strong>另一个本质的改进在于epoll采用基于事件的就绪通知方式。</strong>在select&#x2F;poll 中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某 个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。</p>
<h5 id="4）总结"><a href="#4）总结" class="headerlink" title="4）总结"></a>4）总结</h5><p>（1）<strong>select，poll</strong>实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而<strong>epoll</strong>其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是<strong>select和poll</strong>在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。</p>
<p>（2）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。</p>
<hr>
<h3 id="信号驱动IO模型"><a href="#信号驱动IO模型" class="headerlink" title="信号驱动IO模型"></a><strong>信号驱动IO模型</strong></h3><p>复用IO模型解决了一个线程可以监控多个fd的问题，但是select是采用轮询的方式来监控多个fd的，通过不断的轮询fd的可读状态来知道是否有可读的数据，而无脑的轮询就显得有点暴力，因为大部分情况下的轮询都是无效的，所以有人就想，能不能不要我总是去问你是否数据准备就绪，能不能我发出请求后等你数据准备好了就通知我，所以就衍生了信号驱动IO模型。</p>
<p>于是信号驱动IO不是用循环请求询问的方式去监控数据就绪状态，而是在调用sigaction时候建立一个SIGIO的信号联系，<strong>当内核数据准备好之后再通过SIGIO信号通知线程数据准备好后的可读状态</strong>，当线程收到可读状态的信号后，此时再向内核发起recvfrom读取数据的请求，因为信号驱动IO的模型下应用线程在发出信号监控后即可返回，不会阻塞，所以这样的方式下，一个应用线程也可以同时监控多个fd。</p>
<p>类似于下图描述：</p>
<p><img src="E:\学习笔记\图片\v2-2461c8df6a154930afb4e7c345442835_720w.jpg" alt="img"></p>
<p><strong>术语描述：</strong>首先开启套接口信号驱动IO功能，并通过系统调用sigaction执行一个信号处理函数，此时请求即刻返回，当数据准备就绪时，就生成对应进程的SIGIO信号，通过信号回调通知应用线程调用recvfrom来读取数据。</p>
<p><img src="E:\学习笔记\图片\v2-bf11a9d3c0f52da85298baa13000e5c9_720w.jpg" alt="img"></p>
<p><strong>总结：</strong> IO复用模型里面的select虽然可以监控多个fd了，但select其实现的本质上还是通过不断的轮询fd来监控数据状态， 因为大部分轮询请求其实都是无效的，所以信号驱动IO意在通过这种建立信号关联的方式，实现了发出请求后只需要等待数据就绪的通知即可，这样就可以避免大量无效的数据状态轮询操作。</p>
<h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a><strong>异步IO</strong></h3><p>其实经过了上面两个模型的优化，我们的效率有了很大的提升，但是我们当然不会就这样满足了，有没有更好的办法，通过观察我们发现，不管是IO复用还是信号驱动，我们要读取一个数据总是要发起两阶段的请求，<strong>第一次发送select请求，询问数据状态是否准备好，第二次发送recevform请求读取数据。</strong></p>
<p><strong>思考一个问题：</strong></p>
<p>也许你一开始就有一个疑问，为什么我们明明是想读取数据，什么非得要先发起一个select询问数据状态的请求，然后再发起真正的读取数据请求,能不能有一种一劳永逸的方式，我只要发送一个请求我告诉内核我要读取数据，然后我就什么都不管了，然后内核去帮我去完成剩下的所有事情？</p>
<p>当然既然你想得出来，那么就会有人做得到，有人设计了一种方案，应用只需要向内核发送一个read 请求,告诉内核它要读取数据后即刻返回；内核收到请求后会建立一个信号联系，当数据准备就绪，内核会主动把数据从内核复制到用户空间，等所有操作都完成之后，内核会发起一个通知告诉应用，我们称这种一劳永逸的模式为异步IO模型。</p>
<p><img src="E:\学习笔记\图片\v2-96009f54d89ade0d8c4001bc67395c57_720w.jpg" alt="img"></p>
<p><strong>术语描述：</strong> 应用告知内核启动某个操作，并让内核在整个操作完成之后，通知应用，这种模型与信号驱动模型的主要区别在于，信号驱动IO只是由内核通知我们何时可以开始下一个IO操作，而异步IO模型是由内核通知我们操作什么时候完成。</p>
<p><img src="E:\学习笔记\图片\v2-5095ab1ffe868a2577bc15310d740293_720w.jpg" alt="img"></p>
<p><strong>总结：</strong>异步IO的优化思路是解决了应用程序需要先后发送询问请求、发送接收数据请求两个阶段的模式，在异步IO的模式下，只需要向内核发送一次请求就可以完成状态询问和数拷贝的所有操作。</p>
<hr>
<h3 id="再谈IO模型里面的同步异步"><a href="#再谈IO模型里面的同步异步" class="headerlink" title="再谈IO模型里面的同步异步"></a><strong>再谈IO模型里面的同步异步</strong></h3><p>我们通常会说到同步阻塞IO、同步非阻塞IO，异步IO几种术语，通过上面的内容，那么我想你现在肯定已经理解了什么是阻塞什么是非阻塞了，所谓阻塞就是发起读取数据请求的时，当数据还没准备就绪的时候，这时<strong>请求是即刻返回一个状态值，还是在这里等待数据的就绪</strong>，如果需要等待的话就是阻塞，反之如果即刻返回就是非阻塞。</p>
<p>我们区分了阻塞和非阻塞后再来分别下同步和异步，在IO模型里面如果请求方<strong>从发起请求到数据最后完成的这一段过程中都需要自己参与（先发送一个读取请求，数据准备好了再次发起请求进行读取）</strong>，那么这种我们称为<strong>同步</strong>请求；反之，如果应用发送完指令后就不再参与过程了，只需要<strong>等待最终完成结果的通知，那么这就属于异步</strong>。</p>
<p>我们再看同步阻塞、同步非阻塞，他们不同的只是发起读取请求的时候一个请求阻塞，一个请求不阻塞，但是相同的是，他们都需要应用自己监控整个数据完成的过程。而为什么只有异步非阻塞 而没有异步阻塞呢，因为异步模型下请求指定发送完后就即刻返回了，没有任何后续流程了，所以它注定不会阻塞，所以也就只会有异步非阻塞模型了。</p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>同步和异步的概念针对的是应用程序和内核之间的交互状态，比如用户进程<strong>触发IO操作并等待或者轮询去看IO操作是否就绪，然后读取数据</strong>，这是同步，而<strong>异步</strong>指的是用户进程<strong>触发IO操作</strong>后便开始做自己的事情，<strong>当IO操作完成时会得到通知，不再需要自己去接收数据</strong>，内核已经帮我们处理好了数据。而<strong>阻塞和非阻塞指的是进程访问数据时，根据IO操作的就绪状态而采取的不同方式</strong>，阻塞方式下，读取或写入函数不会立即返回一个状态值，而是一直等待，直到读取数据完成才返回，而非阻塞状态下不会挂起线程，直接返回状态值。</p>
<p>同步：应用程序不停轮询是否准备好数据，并且准备好后再发起读取请求(两次询问，数据是否准备好，数据copy至用户空间)</p>
<p>异步:应用程序不需要轮询，内核将数据准备好并拷贝至用户空间，然后通知应用程序(一次请求)</p>
<p>阻塞：轮询时不直接返回状态值，一直等待</p>
<p>非阻塞：轮询时直接返回状态值</p>
<h2 id="7-内存管理机制"><a href="#7-内存管理机制" class="headerlink" title="7.内存管理机制"></a>7.内存管理机制</h2><p>简单分为<strong>连续分配管理方式</strong>和<strong>非连续分配管理方式</strong>这两种。</p>
<p><strong>连续</strong>分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如<strong>块式管理</strong> 。</p>
<p><strong>块式管理</strong> ： 将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。</p>
<p><strong>非连续</strong>分配管理方式允许一个程序使用的内存分布在离散或者说不相邻的内存中，常见的如<strong>页式管理、段式管理、段页式管理</strong>。</p>
<ol>
<li><p><strong>页式管理</strong> ：把主存分为大小相等且固定的一页一页的形式，页较小，相比于块式管理的划分粒度更小，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。</p>
</li>
<li><p><strong>段式管理</strong> ： 页式管理虽然提高了内存利用率，但是页式管理其中的页并无任何实际意义。 段式管理把主存分为一段段的，段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。</p>
<p>简单来说：页是物理单位，段是逻辑单位。分页可以有效提高内存利用率，分段可以更好满足用户需求。</p>
</li>
<li><p><strong>段页式管理机制</strong><br>段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说段页式管理机制中段与段之间以及段的内部的都是离散的。</p>
</li>
</ol>
<h3 id="分页机制和分段机制的共同点和区别"><a href="#分页机制和分段机制的共同点和区别" class="headerlink" title="分页机制和分段机制的共同点和区别"></a>分页机制和分段机制的共同点和区别</h3><ol>
<li><strong>共同点</strong> ：<ul>
<li>分页机制和分段机制都是为了提高内存利用率，减少内存碎片。</li>
<li>页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。</li>
</ul>
</li>
<li><strong>区别</strong> ：<ul>
<li>页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。</li>
<li>分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。</li>
</ul>
</li>
</ol>
<h2 id="8-快表和多级页表"><a href="#8-快表和多级页表" class="headerlink" title="8. 快表和多级页表"></a>8. 快表和多级页表</h2><p>在分页内存管理中，很重要的两点是：</p>
<ol>
<li>虚拟地址到物理地址的转换要快。</li>
<li>解决虚拟地址空间大，页表也会很大的问题</li>
</ol>
<h3 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h3><p>为了提高虚拟地址到物理地址的转换速度，操作系统在页表方案基础之上引入了<strong>快表</strong>来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的<strong>高速缓冲存储器</strong>（Cache），其中的内容是页表的一部分或者全部内容。作为页表的 Cache，它的作用与页表相似，但是提高了访问速率。由于采用页表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。</p>
<p><strong>使用快表之后的地址转换流程</strong>是这样的：</p>
<ol>
<li>根据虚拟地址中的页号查快表；</li>
<li>如果该页在快表中，直接从快表中读取相应的物理地址；</li>
<li>如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；</li>
<li>当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。</li>
</ol>
<p>PS：快表和我们平时经常在我们开发的系统使用的缓存(比如Redis)很像.</p>
<h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多<strong>级页表</strong></h3><p>引入多级页表的主要目的是为了<strong>避免把全部页表一直放在内存中占用过多空间</strong>，特别是那些根本就不需要的页表就不需要保留在内存中。一级页表只存储二级页表的下标索引。多级页表属于时间换空间的典型场景。</p>
<h2 id="9-逻辑-虚拟-地址和物理地址"><a href="#9-逻辑-虚拟-地址和物理地址" class="headerlink" title="9. 逻辑(虚拟)地址和物理地址"></a>9. 逻辑(虚拟)地址和物理地址</h2><p>我们编程一般只有可能和逻辑地址打交道，比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，<strong>逻辑地址</strong>由操作系统决定。</p>
<p><strong>物理地址</strong>指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址。</p>
<h2 id="10-CPU-寻址了解吗-为什么需要虚拟地址空间"><a href="#10-CPU-寻址了解吗-为什么需要虚拟地址空间" class="headerlink" title="10. CPU 寻址了解吗?为什么需要虚拟地址空间?"></a>10. CPU 寻址了解吗?为什么需要虚拟地址空间?</h2><p>现代处理器使用的是一种称为 <strong>虚拟寻址(Virtual Addressing)<strong>的寻址方式。</strong>使用虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。</strong><br> 实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有一个被称为 <strong>内存管理单元（Memory Management Unit, MMU）</strong> 的硬件。</p>
<h3 id="为什么要有虚拟地址空间呢？"><a href="#为什么要有虚拟地址空间呢？" class="headerlink" title="为什么要有虚拟地址空间呢？"></a><strong>为什么要有虚拟地址空间呢？</strong></h3><p>先从没有虚拟地址空间的时候说起吧！没有虚拟地址空间的时候，<strong>程序直接访问和操作的都是物理内存</strong> 。但是这样有什么问题呢？</p>
<ol>
<li>用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易（有意或者无意）破坏操作系统，造成操作系统崩溃。</li>
<li>想要同时运行多个程序特别困难，比如你想同时运行一个微信和一个 QQ 音乐都不行。为什么呢？举个简单的例子：微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖微信之前所赋的值，这就造成了微信这个程序就会崩溃。</li>
</ol>
<p><strong>总结来说：如果直接把物理地址暴露出来的话会带来严重问题，比如可能对操作系统造成伤害以及给同时运行多个程序造成困难。</strong></p>
<p>通过虚拟地址访问内存有以下优势：</p>
<ul>
<li>程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。</li>
<li>程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页（通常大小为 4 KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。</li>
<li>不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。</li>
</ul>
<h2 id="11-什么是虚拟内存？"><a href="#11-什么是虚拟内存？" class="headerlink" title="11. 什么是虚拟内存？"></a>11. 什么是虚拟内存？</h2><p>很多时候我们使用了很多占内存的软件，这些软件占用的内存可能已经远远超出了我们电脑本身具有的物理内存。正是因为虚拟内存的存在，通过 <strong>虚拟内存</strong> 可以让程序可以拥有超过系统物理内存大小的可用内存空间。另外，<strong>虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）</strong>。这样会更加有效地管理内存并减少出错。</p>
<p><strong>虚拟内存</strong>是计算机系统内存管理的一种技术，我们可以手动设置自己电脑的虚拟内存。不要单纯认为虚拟内存只是“使用硬盘空间来扩展内存“的技术。<strong>虚拟内存的重要意义是它定义了一个连续的虚拟地址空间</strong>，并且 <strong>把内存扩展到硬盘空间</strong>。</p>
<h3 id="虚拟内存的实现技术？"><a href="#虚拟内存的实现技术？" class="headerlink" title="虚拟内存的实现技术？"></a>虚拟内存的实现技术？</h3><ol>
<li><strong>请求分页存储管理</strong> ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。</li>
<li><strong>请求分段存储管理</strong> ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。</li>
<li><strong>请求段页式存储管理</strong></li>
</ol>
<h3 id="请求分页-和-分页存储管理-的区别？"><a href="#请求分页-和-分页存储管理-的区别？" class="headerlink" title="请求分页 和 分页存储管理 的区别？"></a>请求分页 和 分页存储管理 的区别？</h3><p>请求分页存储管理建立在分页管理之上。他们的根本区别是是否将程序全部所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因。</p>
<p>它们之间的<strong>根本区别</strong>在于<strong>是否将一作业的全部地址空间同时装入主存</strong>。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。</p>
<p>不管是上面那种实现方式，我们一般都需要：</p>
<ol>
<li>一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；</li>
<li><strong>缺页中断</strong>：如果<strong>需执行的指令或访问的数据尚未在内存</strong>（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段<strong>调入到内存</strong>，然后继续执行程序；</li>
<li><strong>虚拟地址空间</strong> ：逻辑地址到物理地址的变换。</li>
</ol>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><ul>
<li><strong>OPT 页面置换算法（最佳页面置换算法）</strong> ：最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。</li>
<li><strong>FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）</strong> : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。</li>
<li><strong>LRU （Least Recently Used）页面置换算法（最近最久未使用页面置换算法）</strong> ：LRU 算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。</li>
<li><strong>LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）</strong> : 该置换算法选择在之前时期使用最少的页面作为淘汰页。</li>
</ul>
<h2 id="12-局部性原理"><a href="#12-局部性原理" class="headerlink" title="12. 局部性原理"></a>12. 局部性原理</h2><p>局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行。</p>
<p>局部性原理表现在以下两个方面：</p>
<ol>
<li><strong>时间局部性</strong> ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</li>
<li><strong>空间局部性</strong> ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</li>
</ol>
<p>时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上就是建立了 “内存一外存”的两级存储器的结构，利用局部性原理实现髙速缓存。</p>
<h2 id="13-系统调用"><a href="#13-系统调用" class="headerlink" title="13. 系统调用"></a>13. 系统调用</h2><p>介绍系统调用之前，先说一下用户态和系统态。</p>
<p>根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：</p>
<ol>
<li><strong>用户态(user mode)</strong> : 用户态运行的进程或可以直接读取用户程序的数据。</li>
<li><strong>系统态(kernel mode)</strong>: 可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。</li>
</ol>
<p>我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了！</p>
<p>也就是说在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</p>
<p>这些系统调用按功能大致可分为如下几类：</p>
<ul>
<li><strong>设备管理</strong> ：完成设备的请求或释放，以及设备启动等功能。</li>
<li><strong>文件管理</strong> ：完成文件的读、写、创建及删除等功能。</li>
<li><strong>进程控制</strong> ：完成进程的创建、撤销、阻塞及唤醒等功能。</li>
<li><strong>进程通信</strong> ：完成进程之间的消息传递或信号传递等功能。</li>
<li><strong>内存管理</strong> ：完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li>
</ul>
<p>![Untitled](E:\学习笔记\图片\Untitled 40.png)</p>
<h2 id="14-自旋锁"><a href="#14-自旋锁" class="headerlink" title="14.自旋锁"></a>14.自旋锁</h2><p><strong>自旋锁</strong>的定义：当一个线程尝试去获取某一把锁的时候，如果这个锁此时已经被别人获取(占用)，那么此线程就无法获取到这把锁，该线程将会等待，间隔一段时间后会再次尝试获取。这种采用循环加锁 -&gt; 等待的机制被称为自旋锁(spinlock)。</p>
<p><strong>自旋锁有以下特点</strong></p>
<ul>
<li>用于临界区互斥</li>
<li>在任何时刻最多只能有一个执行单元获得锁</li>
<li>要求持有锁的处理器所占用的时间尽可能短</li>
<li>等待锁的线程进入忙循环</li>
</ul>
<p><strong>自旋锁存在的问题</strong></p>
<ul>
<li>如果某个线程持有锁的时间过长，就会导致其它等待获取锁的线程进入循环等待，消耗CPU。使用不当会造成CPU使用率极高。</li>
<li>无法满足等待时间最长的线程优先获取锁。不公平的锁就会存在“线程饥饿”问题。</li>
</ul>
<p><strong>自旋锁的优点</strong></p>
<ul>
<li>自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是active的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快</li>
<li>非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换。（线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能）</li>
</ul>
<p><strong>自旋锁与互斥锁的区别</strong></p>
<ul>
<li>自旋锁与互斥锁都是为了实现保护资源共享的机制。</li>
<li>无论是自旋锁还是互斥锁，在任意时刻，都最多只能有一个保持者。</li>
<li>获取互斥锁的线程，如果锁已经被占用，则该线程将进入睡眠状态；获取自旋锁的线程则不会睡眠，而是一直循环等待锁释放。</li>
</ul>
<h2 id="15-软链接、硬链接"><a href="#15-软链接、硬链接" class="headerlink" title="15.软链接、硬链接"></a>15.软链接、硬链接</h2><p><strong>软链接</strong>相当于建立了一个新的快捷方式文件，该文件有自己的名称和inode以及物理存储的文件数据，文件数据里记录着如何跳转的设置数据，访问该快捷文件会被重新定向到原始文件，删除原始文件，软链文件失效；</p>
<p><strong>硬链接</strong>相当于为当前文件名对应的文件再建立了一个文件别名，别名对应的inode以及物理数据都是一样的，事实上文件系统会维护一个引用计数，只要有文件指向这个区块，它就不会从硬盘上消失，而硬链接相当于是给引用计数加1。</p>
<p><strong>软连接和硬链接的区别</strong></p>
<p>​	(1) <strong>软链接</strong>可以为文件和目录（哪怕是不存在的）创建链接；<strong>硬链接</strong>只能为文件创建链接。 </p>
<p>​	(2) <strong>软链接</strong>可以跨文件系统；<strong>硬链接</strong>必须是同一个文件系统 </p>
<p>​	(3) <strong>硬链接</strong>因为只是文件的一个别名，所以不重复占用内存；<strong>软链接</strong>因为只是一个访问文件的快捷方式文件，文件内只包含快捷指向信息，所以占用很小的内存。 </p>
<p>​	(4) <strong>软链接</strong>的文件权限和源文件可以不一样；<strong>硬链接</strong>文件权限肯定是一样的，因为他们本来就是一个文件的不同名称而已。</p>
<p><strong>二者使用场景</strong></p>
<pre><code> 一般比较重要的文件我们担心文件被误删除且传统复制备份方式占用double数量的空间会造成浪费，可以使用硬链做备份来解决；软链接一般被用来设置可执行文件的快捷方式的路径。
</code></pre>
<h2 id="16-select、poll和epoll"><a href="#16-select、poll和epoll" class="headerlink" title="16.select、poll和epoll"></a>16.select、poll和epoll</h2><h3 id="linux内核事件机制"><a href="#linux内核事件机制" class="headerlink" title="linux内核事件机制"></a>linux内核事件机制</h3><p>在Linux内核中存在着等待队列的数据结构,该数据结构是基于<strong>双端链表</strong>实现,Linux内核通过将阻塞的进程任务添加到等待队列中,而进程任务被唤醒则是在队列轮询遍历检测是否处于就绪状态,如果是那么会在等待队列中删除等待节点并通过节点上的回调函数进行通知，然后加入到cpu就绪队列中等待cpu调度执行。其具体流程主要包含以下两个处理逻辑,即休眠逻辑以及唤醒逻辑.</p>
<h3 id="休眠逻辑"><a href="#休眠逻辑" class="headerlink" title="休眠逻辑"></a>休眠逻辑</h3><ul>
<li>在linux内核中某一个进程任务task执行需要等待某个条件condition被触发执行之前,首先会在内核中创建一个等待节点entry,然后初始化entry相关属性信息,其中将进程任务存放在entry节点并同时存储一个wake_callback函数并挂起当前进程</li>
<li>不断轮询检查当前进程任务task执行的condition是否满足,如果不满足则调用schedule()进入休眠状态</li>
<li>最后如果满足condition的话,就会将entry从队列中移除,也就是说这个时候事件已经被唤醒,进程处于就绪状态</li>
</ul>
<h3 id="唤醒逻辑"><a href="#唤醒逻辑" class="headerlink" title="唤醒逻辑"></a>唤醒逻辑</h3><ul>
<li>在等待队列中循环遍历所有的entry节点,并执行回调函数,直到当前entry为排他节点（条件就绪）的时候退出循环遍历</li>
<li>执行的回调函数中,存在私有逻辑与公用逻辑,类似模板方法设计模式</li>
<li>对于default_wake_function的唤醒回调函数主要是将entry的进程任务task添加到cpu就绪队列中等待cpu调度执行任务task</li>
</ul>
<h3 id="文件描述符fd"><a href="#文件描述符fd" class="headerlink" title="文件描述符fd"></a>文件描述符fd</h3><p>文件描述符（File descriptor）是计算机科学中的一个术语，<strong>是一个用于表述指向文件的引用的抽象化概念</strong>。</p>
<p>文件描述符在形式上是一个非负整数。实际上，<strong>它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表</strong>。</p>
<h3 id="复用原理"><a href="#复用原理" class="headerlink" title="复用原理"></a>复用原理</h3><p><img src="E:\学习笔记\图片\98toev8705.jpeg" alt="img"></p>
<p>基于Linux内核的等待与唤醒机制</p>
<ul>
<li>用户进程向内核发起select函数的调用,并携带socket描述符集合从用户空间复制到内核空间,由内核对socket集合进行可读状态的监控.</li>
<li>当前内核没有数据可达的时候,将注册的socket集合分别以entry节点的方式添加到链表结构的等待队列中等待数据报可达.</li>
<li>这个时候网卡设备接收到网络发送的数据报,内核接收到数据报,就会通过轮询唤醒的方式(内核并不知道是哪个socket可读)逐个进行唤醒通知,直到当前socket描述符有可读状态的时候就退出轮询，然后从等待队列移除对应的socket节点entry,并且这个时候内核将会更新fd集合中的描述符的状态,以便于用户进程知道是哪些socket是具备可读性从而方便后续进行数据读取操作</li>
<li>同时在轮询唤醒的过程中,如果有对应的socket描述符是可读的,那么此时会将read_process加入到cpu就绪队列中,让cpu能够调度执行read_process任务</li>
<li>最后是用户进程调用select函数返回成功,此时用户进程会在socket描述符结合中进行轮询遍历具备可读的socket,此时也就意味着数据此时在内核已经准备就绪,用户进程可以向内核发起数据读取操作,也就是执行上述的read_process任务操作</li>
</ul>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>在Linux中，我们可以使用select函数实现I&#x2F;O端口的复用，传递给 select函数的参数会告诉内核：</p>
<p>   •我们所关心的文件描述符</p>
<p>   •对每个描述符，我们所关心的状态。(我们是要想从一个文件描述符中读或者写，还是关注一个描述符中是否出现异常)</p>
<p>   •我们要等待多长时间。(我们可以等待无限长的时间，等待固定的一段时间，或者根本就不等待)</p>
<p>  从 select函数返回后，内核告诉我们一下信息：</p>
<p>   •对我们的要求已经做好准备的描述符的个数</p>
<p>   •对于三种条件哪些描述符已经做好准备.(读，写，异常)</p>
<p>  有了这些返回信息，我们可以调用合适的I&#x2F;O函数(通常是 read 或 write)，并且这些函数不会再阻塞.</p>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ul>
<li>用户进程向内核发起<strong>select函数的调用</strong>,并携带fd集合<strong>从用户空间复制到内核空间</strong>,由内核对fd集合进行可读状态的监控.</li>
<li>数据准备就绪,就会通过轮询的方式(内核并不知道是哪个fd可读)逐个进行唤醒通知,并进行返回。fd集合在就绪返回前被修改，仅仅保留了就绪的描述符，因此每次重新监控前需要重新添加到描述符集合中。</li>
<li>用户进程调用select函数返回成功,此时用户进程会在fd集合中进行轮询遍历具备可读的fd,此时也就意味着数据此时在内核已经准备就绪,用户进程可以向内核发起数据读取操作,也就是执行上述的read_process任务操作</li>
</ul>
<h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><p>优点：</p>
<p>​	良好的跨平台性</p>
<p>缺点：</p>
<ol>
<li>在Linux中基于POSIX协议定义的select技术使用数组存储描述符fd，<strong>最大可支持的描述符个数为1024个</strong>。</li>
<li>用户进程<strong>调用select的时候需要将一整个fd集合的大块内存从用户空间拷贝到内核中</strong>,期间用户空间与内核空间来回切换开销非常大,再加上调用select的频率本身非常频繁,这样导致高频率调用且大内存数据的拷贝,严重影响性能。</li>
<li><strong>唤醒逻辑</strong>的处理,select技术在等待过程如果监控到至少有一个socket事件是可读的时候将<strong>会唤醒整个等待队列</strong>,告知当前等待队列中有存在就绪事件的socket,但是具体是哪个socket不知道,必须通过轮询的方式逐个遍历进行回调通知,**轮询遍历的时间复杂度是O(n)**。</li>
</ol>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>poll技术与select技术实现逻辑基本一致,重要区别在于其使用链表的方式存储描述符fd,不受数组大小影响。</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>解决了select和poll的两个瓶颈问题</p>
<ol>
<li>fd集合拷贝问题</li>
<li>循环轮询问题</li>
</ol>
<p>epoll操作过程需要三个接口:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>；<span class="comment">//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大 int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)； int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</span></span><br></pre></td></tr></table></figure>

<p><strong>1. int epoll_create(int size);</strong></p>
<p>创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，<strong>参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。</strong></p>
<p><strong>2. int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</strong></p>
<p>函数是对指定描述符fd执行op操作。</p>
<p>用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上</p>
<ul>
<li>epfd：是epoll_create()的返回值。</li>
<li>op：表示op操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD。分别添加、删除和修改对fd的监听事件。</li>
<li>fd：是需要监听的fd（文件描述符）</li>
<li>epoll_event：是告诉内核需要监听什么事</li>
</ul>
<p><strong>3. int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</strong></p>
<p>等待epfd上的io事件，最多返回maxevents个事件。</p>
<p>通过回调函数内核会将 I&#x2F;O 准备好的描述符添加到rdlist双链表管理，进程调用 epoll_wait() 便可以得到事件完成的描述符。</p>
<h4 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h4><p>epoll对文件描述符的操作有两种模式：<strong>LT (level trigger)（默认）</strong>和**ET (edge trigger)**。LT模式是默认模式。</p>
<p>LT模式与ET模式的区别如下：</p>
<ul>
<li><strong>LT模式</strong>：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<strong>应用程序可以不立即处理该事件</strong>。下次调用epoll_wait时，会再次响应应用程序并通知此事件。只要文件描述符的缓冲区中有数据，就永远通知用户这个描述符是可读的。<strong>支持block和noblock。</strong></li>
<li><strong>ET模式</strong>：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<strong>应用程序必须立即处理该事件</strong>。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。只有在文件描述符有新的监听事件发生的时候（例如有新的数据包到达）才会通知应用程序，在没有新的监听时间发生时，即使缓冲区有数据（即上一次没有读完，或者甚至没有读），epoll也不会继续通知应用程序。<strong>只支持nonblock</strong></li>
</ul>
<h4 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h4><p>在 select&#x2F;poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而<strong>epoll事先通过epoll_ctl()来注册一 个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait() 时便得到通知</strong>。(<code>此处去掉了遍历文件描述符，而是通过监听回调的的机制</code>。</p>
<p>优点：</p>
<ol>
<li>监视的描述符数量不受限制</li>
<li>epoll是内核空间用一个 <strong>红黑树</strong>维护所有的fd，epoll_wait 通过回调函数内核会将 I&#x2F;O 准备好的描述符加入到一个链表中管理，<strong>只把就绪的fd用链表复制到用户空间</strong>。</li>
<li>IO的效率不会随着监视fd的数量的增长而下降。epoll不同于select和poll轮询的方式，而是通过每个fd定义的回调函数来实现的。只有就绪的fd才会执行回调函数。</li>
</ol>
<p><strong>极其高效的原因：</strong><br>这是由于我们在调用epoll_create时，内核除了帮我们在epoll文件系统里建了个file结点，在内核cache里建了个红黑树用于存储以后epoll_ctl传来的socket外，还会<strong>再建立一个list链表，用于存储准备就绪的事件</strong>，当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。所以，epoll_wait非常高效。</p>
<p>这个准备就绪list链表是怎么维护的？<br>当我们执行epoll_ctl时，除了把socket放到epoll文件系统里file对象对应的红黑树上之外，还会给内核中断处理程序注册一个回调函数，告诉内核，如果这个句柄的中断到了，就把它放到准备就绪list链表里。所以，当一个socket上有数据到了，内核在把网卡上的数据copy到内核中后就来把socket插入到准备就绪链表里了。<br>上面这句可以看出，epoll的基础就是<strong>回调</strong>！</p>
<h2 id="17-直接内存映射"><a href="#17-直接内存映射" class="headerlink" title="17.直接内存映射"></a>17.直接内存映射</h2><p>Linux提供的mmap系统调用, 它可以将一段用户空间内存映射到内核空间, 当映射成功后, 用户对这段内存区域的修改可以直接反映到内核空间；同样地， 内核空间对这段区域的修改也直接反映用户空间。正因为有这样的映射关系, 就不需要在用户态(User-space)与内核态(Kernel-space) 之间拷贝数据， 提高了数据传输的效率，这就是内存直接映射技术。</p>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="1-OSI七层模型"><a href="#1-OSI七层模型" class="headerlink" title="1.OSI七层模型"></a>1.OSI七层模型</h2><p><img src="E:\学习笔记\图片\image-20220805130408268.png" alt="image-20220805130408268"></p>
<p><img src="E:\学习笔记\图片\image-20220805130455502.png" alt="image-20220805130455502"></p>
<h2 id="2-TCP-x2F-IP四层模型"><a href="#2-TCP-x2F-IP四层模型" class="headerlink" title="2.TCP&#x2F;IP四层模型"></a>2.TCP&#x2F;IP四层模型</h2><p><img src="E:\学习笔记\图片\TCP-IP-4-model.a534f46f.png" alt="TCP-IP-4-model"></p>
<h2 id="3-TCP和UDP"><a href="#3-TCP和UDP" class="headerlink" title="3.TCP和UDP"></a>3.TCP和UDP</h2><p>TCP和UDP都是全双工通信，三次握手类似于半双工。</p>
<p>TCP三个特点：<strong>面向连接</strong>、<strong>可靠</strong>、基于<strong>字节流</strong></p>
<h3 id="1-1-三次握手"><a href="#1-1-三次握手" class="headerlink" title="1.1 三次握手"></a>1.1 三次握手</h3><p>三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。</p>
<p>刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。</p>
<p>进行三次握手：</p>
<p>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN©。此时客户端处于 SYN_SEND 状态。</p>
<p>首部的同步位SYN&#x3D;1，初始序号seq&#x3D;x，SYN&#x3D;1的报文段不能携带数据，但要消耗掉一个序号。</p>
<p>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。</p>
<p>在确认报文段中SYN&#x3D;1，ACK&#x3D;1，确认号ack&#x3D;x+1，初始序号seq&#x3D;y。</p>
<p>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。</p>
<p>确认报文段ACK&#x3D;1，确认号ack&#x3D;y+1，序号seq&#x3D;x+1（初始为seq&#x3D;x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。</p>
<p>发送第一个SYN的一端将执行主动打开（active open），接收这个SYN并发回下一个SYN的另一端执行被动打开（passive open）。</p>
<p>在socket编程中，客户端执行connect()时，将触发三次握手。</p>
<p><img src="E:\学习笔记\图片\v2-2a54823bd63e16674874aa46a67c6c72_720w.jpg" alt="img"></p>
<h4 id="1-1-为什么需要三次握手，两次不行吗？"><a href="#1-1-为什么需要三次握手，两次不行吗？" class="headerlink" title="1.1 为什么需要三次握手，两次不行吗？"></a><strong>1.1 为什么需要三次握手，两次不行吗？</strong></h4><p>弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。</p>
<p>第一次握手：客户端发送网络包，服务端收到了。</p>
<p>这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p>
<p>第二次握手：服务端发包，客户端收到了。</p>
<p>这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</p>
<p>第三次握手：客户端发包，服务端收到了。</p>
<p>这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</p>
<p>因此，需要三次握手才能确认双方的接收与发送能力是否正常。</p>
<p>试想如果是用两次握手，则会出现下面这种情况：</p>
<blockquote>
<p>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</p>
</blockquote>
<h4 id="1-2-什么是半连接队列？"><a href="#1-2-什么是半连接队列？" class="headerlink" title="1.2 什么是半连接队列？"></a><strong>1.2 什么是半连接队列？</strong></h4><p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。</p>
<p>当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p>
<p>这里在补充一点关于SYN-ACK 重传次数的问题：</p>
<p>服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。</p>
<p>注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…</p>
<h4 id="1-3-ISN-Initial-Sequence-Number-是固定的吗？"><a href="#1-3-ISN-Initial-Sequence-Number-是固定的吗？" class="headerlink" title="1.3 ISN(Initial Sequence Number)是固定的吗？"></a><strong>1.3 ISN(Initial Sequence Number)是固定的吗？</strong></h4><p>当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN随时间而变化，因此每个连接都将具有不同的ISN。ISN可以看作是一个32比特的计数器，每4ms加1 。这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。</p>
<p>三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。</p>
<h4 id="1-4-三次握手过程中可以携带数据吗？"><a href="#1-4-三次握手过程中可以携带数据吗？" class="headerlink" title="1.4 三次握手过程中可以携带数据吗？"></a><strong>1.4 三次握手过程中可以携带数据吗？</strong></h4><p>其实第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手不可以携带数据</p>
<p>为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。</p>
<p>也就是说，第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。</p>
<h4 id="1-5-SYN攻击是什么？"><a href="#1-5-SYN攻击是什么？" class="headerlink" title="1.5 SYN攻击是什么？"></a><strong>1.5 SYN攻击是什么？</strong></h4><p>服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS&#x2F;DDoS 攻击。</p>
<p>检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux&#x2F;Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -n -p TCP | grep SYN_RECV</span><br></pre></td></tr></table></figure>

<p>常见的防御 SYN 攻击的方法有如下几种：</p>
<ul>
<li>缩短超时（SYN Timeout）时间</li>
<li>增加最大半连接数</li>
<li>过滤网关防护</li>
<li>SYN cookies技术</li>
</ul>
<h3 id="1-2四次挥手"><a href="#1-2四次挥手" class="headerlink" title="1.2四次挥手"></a>1.2四次挥手</h3><p>建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p>
<p>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作。</p>
<p>刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：</p>
<p><strong>第一次挥手</strong>：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。</p>
<p>即发出连接释放报文段（FIN&#x3D;1，序号seq&#x3D;u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。</p>
<p><strong>第二次挥手</strong>：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。</p>
<p>即服务端收到连接释放报文段后即发出确认报文段（ACK&#x3D;1，确认号ack&#x3D;u+1，序号seq&#x3D;v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。</p>
<p><strong>第三次挥手</strong>：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。</p>
<p>即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN&#x3D;1，ACK&#x3D;1，序号seq&#x3D;w，确认号ack&#x3D;u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。</p>
<p><strong>第四次挥手</strong>：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</p>
<p>即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK&#x3D;1，seq&#x3D;u+1，ack&#x3D;w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。</p>
<p>收到一个FIN只意味着在这一方向上没有数据流动。客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。</p>
<p>在socket编程中，任何一方执行close()操作即可产生挥手操作。</p>
<p><img src="E:\学习笔记\图片\v2-c7d4b5aca66560365593f57385ce9fa9_720w.jpg" alt="img"></p>
<h4 id="1-2-1-挥手为什么需要四次？"><a href="#1-2-1-挥手为什么需要四次？" class="headerlink" title="1.2.1 挥手为什么需要四次？"></a><strong>1.2.1 挥手为什么需要四次？</strong></h4><p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。</p>
<h4 id="1-2-2-2MSL等待状态"><a href="#1-2-2-2MSL等待状态" class="headerlink" title="1.2.2 2MSL等待状态"></a><strong>1.2.2 2MSL等待状态</strong></h4><p>TIME_WAIT状态也成为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。</p>
<p>对一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）。</p>
<p>这种2MSL等待的另一个结果是这个TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。这个连接只能在2MSL结束后才能再被使用。</p>
<h4 id="1-2-3-四次挥手释放连接时，等待2MSL的意义"><a href="#1-2-3-四次挥手释放连接时，等待2MSL的意义" class="headerlink" title="1.2.3 四次挥手释放连接时，等待2MSL的意义?"></a><strong>1.2.3 四次挥手释放连接时，等待2MSL的意义?</strong></h4><p>MSL是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p>
<p>为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。</p>
<p>两个理由：</p>
<ul>
<li>保证客户端发送的最后一个ACK报文段能够到达服务端。</li>
</ul>
<p>这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。</p>
<ul>
<li>防止“已失效的连接请求报文段”出现在本连接中。</li>
</ul>
<p>客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。</p>
<h4 id="1-2-4-为什么TIME-WAIT状态需要经过2MSL才能返回到CLOSE状态？"><a href="#1-2-4-为什么TIME-WAIT状态需要经过2MSL才能返回到CLOSE状态？" class="headerlink" title="1.2.4 为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？"></a><strong>1.2.4 为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？</strong></h4><p>理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但是可能网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</p>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>《TCP&#x2F;IP详解 卷1:协议》有一张TCP状态变迁图，很具有代表性，有助于大家理解三次握手和四次挥手的状态变化。如下图所示，粗的实线箭头表示正常的客户端状态变迁，粗的虚线箭头表示正常的服务器状态变迁。</p>
<p><img src="E:\学习笔记\图片\v2-7c402fde8210519feb8f65d41410c205_720w.jpg" alt="img"></p>
<h3 id="1-3-TCP和UDP的区别？"><a href="#1-3-TCP和UDP的区别？" class="headerlink" title="1.3. TCP和UDP的区别？"></a>1.3. TCP和UDP的区别？</h3><img src="E:\学习笔记\图片\Untitled 31-1660535568964.png" alt="Untitled" style="zoom: 67%;" />

<p>应用场景：TCP 用于在传输层有必要实现可靠传输的情况，UDP 用于对高速传输和实时性有较高要求的通信。TCP和 UDP 应该根据应用目的按需使用。</p>
<img src="E:\学习笔记\图片\Untitled 32-1660535574607.png" alt="Untitled" style="zoom:50%;" />

<h3 id="1-4-TCP-协议如何保证可靠传输"><a href="#1-4-TCP-协议如何保证可靠传输" class="headerlink" title="1.4 TCP 协议如何保证可靠传输"></a>1.4 <strong>TCP 协议如何保证可靠传输</strong></h3><ol>
<li>应用数据被<strong>分割</strong>成TCP认为最适合发送的数据块。</li>
<li>TCP 给发送的每一个包进行<strong>编号</strong>，接收方对数据包进行排序，把<strong>有序</strong>数据传送给应用层。</li>
<li><strong>校验和：</strong> TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li>TCP 的接收端会丢弃重复的数据。</li>
<li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li>
<li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。慢开始、快恢复、快重传、拥塞避免</li>
<li><strong>ARQ 协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>
</ol>
<h3 id="1-5-ARQ-协议"><a href="#1-5-ARQ-协议" class="headerlink" title="1.5 ARQ 协议"></a>1.5 <strong>ARQ 协议</strong></h3><p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是 OSI 模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ 包括停止等待 ARQ 协议和连续 ARQ 协议。</p>
<h4 id="停止等待-ARQ-协议"><a href="#停止等待-ARQ-协议" class="headerlink" title="停止等待 ARQ 协议"></a><strong>停止等待 ARQ 协议</strong></h4><p>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复 ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组。</p>
<p>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。</p>
<p><strong>优缺点：</strong></p>
<ul>
<li><strong>优点：</strong> 简单</li>
<li><strong>缺点：</strong> 信道利用率低，等待时间长</li>
</ul>
<p><strong>1) 无差错情况:</strong></p>
<p>发送方发送分组, 接收方在规定时间内收到, 并且回复确认. 发送方再次发送。</p>
<p><strong>2) 出现差错情况（超时重传）:</strong></p>
<p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 <strong>自动重传请求 ARQ</strong> 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。<strong>连续 ARQ 协议</strong> 可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p>
<p><strong>3) 确认丢失和确认迟到</strong></p>
<ul>
<li><strong>确认丢失</strong> ：确认消息在传输过程丢失。当 A 发送 M1 消息，B 收到后，B 向 A 发送了一个 M1 确认消息，但却在传输过程中丢失。而 A 并不知道，在超时计时过后，A 重传 M1 消息，B 再次收到该消息后采取以下两点措施：1. 丢弃这个重复的 M1 消息，不向上层交付。 2. 向 A 发送确认消息。（不会认为已经发送过了，就不再发送。A 能重传，就证明 B 的确认消息丢失）。</li>
<li><strong>确认迟到</strong> ：确认消息在传输过程中迟到。A 发送 M1 消息，B 收到并发送确认。在超时时间内没有收到确认消息，A 重传 M1 消息，B 仍然收到并继续发送确认消息（B 收到了 2 份 M1）。此时 A 收到了 B 第二次发送的确认消息。接着发送其他数据。过了一会，A 收到了 B 第一次发送的对 M1 的确认消息（A 也收到了 2 份确认消息）。处理如下：1. A 收到重复的确认后，直接丢弃。2. B 收到重复的 M1 后，也直接丢弃重复的 M1。</li>
</ul>
<h4 id="连续-ARQ-协议"><a href="#连续-ARQ-协议" class="headerlink" title="连续 ARQ 协议"></a><strong>连续 ARQ 协议</strong></h4><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p>
<p><strong>优缺点：</strong></p>
<ul>
<li><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</li>
<li><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5 条 消息，中间第三条丢失（3 号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</li>
</ul>
<h3 id="1-6-滑动窗口和流量控制"><a href="#1-6-滑动窗口和流量控制" class="headerlink" title="1.6 滑动窗口和流量控制"></a>1.6 <strong>滑动窗口和流量控制</strong></h3><p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong> 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<h3 id="1-7拥塞控制"><a href="#1-7拥塞控制" class="headerlink" title="1.7拥塞控制"></a><strong>1.7拥塞控制</strong></h3><p><strong>基本概念</strong></p>
<p>​	拥塞：即对资源的需求超过了可用的资源。若网络中许多资源同时供应不足，网络的性能就要明显变坏，整个网络的吞吐量随之负荷的增大而下降。</p>
<p>  拥塞控制：<strong>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。</strong>拥塞控制所要做的都有一个<strong>前提：网络能够承受现有的网络负荷。</strong>拥塞控制是一个<strong>全局性的过程</strong>，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。</p>
<p>  流量控制：指点对点通信量的控制，是端到端正的问题。流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>
<p>  拥塞控制代价：需要获得网络内部流量分布的信息。在实施拥塞控制之前，还需要在结点之间交换信息和各种命令，以便选择控制的策略和实施控制。这样就产生了额外的开销。拥塞控制还需要将一些资源分配给各个用户单独使用，使得网络资源不能更好地实现共享。</p>
<h4 id="1几种拥塞控制方法"><a href="#1几种拥塞控制方法" class="headerlink" title="1几种拥塞控制方法"></a>1几种拥塞控制方法</h4><p>  慢开始( slow-start )、拥塞避免( congestion avoidance )、快重传( fast retransmit )和快恢复( fast recovery )。</p>
<h4 id="2慢开始和拥塞避免"><a href="#2慢开始和拥塞避免" class="headerlink" title="2慢开始和拥塞避免"></a>2慢开始和拥塞避免</h4><p>  发送方维持一个<strong>拥塞窗口 cwnd</strong> ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞。</p>
<p>  发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</p>
<h5 id="2-1慢开始算法："><a href="#2-1慢开始算法：" class="headerlink" title="2.1慢开始算法："></a>2.1<strong>慢开始算法</strong>：</h5><p>当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。因此，较好的方法是 先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS（MSS&#x3D;MTU-20字节TCP报头-20字节IP报头，MSS值一般就是1500-20-20&#x3D;1460字节）的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口加倍。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。</p>
<p><strong><img src="E:\学习笔记\图片\2010101120451114.jpg" alt="img"></strong></p>
<p>每经过一个传输轮次，拥塞窗口 cwnd 就加倍。一个传输轮次所经历的时间其实就是往返时间RTT。不过“传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。</p>
<p>另，慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd&#x3D;1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。</p>
<h5 id="2-2慢开始门限ssthresh"><a href="#2-2慢开始门限ssthresh" class="headerlink" title="2.2慢开始门限ssthresh"></a>2.2慢开始门限ssthresh</h5><p> 为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态<strong>变量</strong>（如何设置ssthresh）。慢开始门限ssthresh的用法如下：</p>
<p>  当 cwnd &lt; ssthresh 时，使用上述的慢开始算法。</p>
<p>  当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</p>
<p>  当 cwnd &#x3D; ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。</p>
<h5 id="2-3拥塞避免算法："><a href="#2-3拥塞避免算法：" class="headerlink" title="2.3拥塞避免算法："></a><strong>2.3拥塞避免算法</strong>：</h5><p>让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</p>
<p>  无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为<strong>出现拥塞时的发送方窗口值的一半</strong>（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。</p>
<p>  如下图，用具体数值说明了上述拥塞控制的过程。现在发送窗口的大小和拥塞窗口一样大。</p>
<p><img src="E:\学习笔记\图片\2010101120591634.jpg" alt="img"></p>
<p>&lt;1&gt;. 当TCP连接进行初始化时，把拥塞窗口cwnd置为1。前面已说过，为了便于理解，图中的窗口单位不使用字节而使用报文段的个数。慢开始门限的初始值设置为16个报文段，即 cwnd &#x3D; 16 。</p>
<p>&lt;2&gt;. 在执行慢开始算法时，拥塞窗口 cwnd 的初始值为1。以后发送方每收到一个对新报文段的确认ACK，就把拥塞窗口值另1，然后开始下一轮的传输（图中横坐标为传输轮次）。因此拥塞窗口cwnd 随着传输轮次按指数规律增长。当拥塞窗口cwnd增长到慢开始门限值ssthresh时（即当cwnd&#x3D;16时），就改为执行拥塞控制算法，拥塞窗口按线 性规律增长。</p>
<p>&lt;3&gt;. 假定拥塞窗口的数值增长到24时，网络出现超时（这很可能就是网络发生拥塞了）。更新后的ssthresh值变为12（即变为出现超时时的拥塞窗口数值 24的一半），拥塞窗口再重新设置为1，并执行慢开始算法。当cwnd&#x3D;ssthresh&#x3D;12时改为执行拥塞避免算法，拥塞窗口按线性规律增长，每经过 一个往返时间增加一个MSS的大小。</p>
<p>强调：“拥塞避免”并非指完全能够避免了拥塞。利用以上的措施要完全避免网络拥塞还是不可能的。“拥塞避免”是说在拥塞避免阶段将拥塞窗口控制为按线性规律增长，<strong>使网络比较不容易出现拥塞。</strong></p>
<h4 id="3快重传和快恢复"><a href="#3快重传和快恢复" class="headerlink" title="3快重传和快恢复"></a>3快重传和快恢复</h4><p>  如果发送方设置的超时计时器时限已到但还没有收到确认，那么很可能是网络出现了拥塞，致使报文段在网络中的某处被丢弃。这时，TCP马上把拥塞窗口 cwnd 减小到1，并执行慢开始算法，同时把慢开始门限值ssthresh减半。这是不使用快重传的情况。</p>
<h5 id="3-1快重传算法："><a href="#3-1快重传算法：" class="headerlink" title="3.1快重传算法："></a>3.1快重传算法：</h5><p>首先要求接收方<strong>每收到一个失序的报文段后就立即发出重复确认</strong>（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。</p>
<p><img src="E:\学习笔记\图片\2010101122524670.jpg" alt="img"></p>
<p>接收方收到了M1和M2后都分别发出了确认。现在假定接收方没有收到M3但接着收到了M4。显然，接收方不能确认M4，因为M4是收到的失序报文段。根据可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。但按照快重传算法的规定，接收方应及时发送对M2的重复确认，这样做可以让发送方及早知道报文段M3没有到达接收方。发送方接着发送了M5和M6。接收方收到这两个报文后，也还要再次发出对M2的重复确认。这样，发送方共收到了接收方的四个对M2的确认，其中后三个都是重复确认。<strong>快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待报文设置的重传计时器到期。</strong>由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。</p>
<h5 id="3-2快恢复算法："><a href="#3-2快恢复算法：" class="headerlink" title="3.2快恢复算法："></a>3.2快恢复算法：</h5><p>其过程有以下两个要点：</p>
<p>  &lt;1&gt;. 当发送方连续收到三个重复确认，就执行“乘法减小”算法，把<strong>慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半</strong>。这是为了预防网络发生拥塞。请注意：接下去不执行慢开始算法。</p>
<p>  &lt;2&gt;. 由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在<strong>不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。</strong></p>
<p>  下图给出了快重传和快恢复的示意图，并标明了“TCP Reno版本”。</p>
<p>  区别：新的 TCP Reno 版本在快重传之后采用快恢复算法而不是采用慢开始算法。</p>
<p><img src="E:\学习笔记\图片\2010101123101842.jpg" alt="img"> </p>
<p> 也有的快重传实现是把开始时的拥塞窗口cwnd值再增大一点，即等于 ssthresh + 3 X MSS 。这样做的理由是：既然发送方收到三个重复的确认，就表明有三个分组已经离开了网络。这三个分组不再消耗网 的资源而是停留在接收方的缓存中。可见现在网络中并不是堆积了分组而是减少了三个分组。因此可以适当把拥塞窗口扩大了些。</p>
<p><strong>补充</strong></p>
<p>  接收方根据自己的接收能力设定了接收窗口rwnd，并把这个窗口值写入TCP首部中的窗口字段，传送给发送方。因此，接收窗口又称为通知窗口。因此，从接收方对发送方的流量控制的角度考虑，发送方的发送窗口一定不能超过对方给出的接收窗口rwnd 。</p>
<p>  发送方窗口的上限值 &#x3D; Min [ rwnd, cwnd ]</p>
<p>  当rwnd &lt; cwnd 时，是接收方的接收能力限制发送方窗口的最大值。</p>
<p>  当cwnd &lt; rwnd 时，则是网络的拥塞限制发送方窗口的最大值。</p>
<h3 id="1-8-TCP中的缓存有什么作用？"><a href="#1-8-TCP中的缓存有什么作用？" class="headerlink" title="1.8  TCP中的缓存有什么作用？"></a>1.8  TCP中的缓存有什么作用？</h3><h4 id="TCP缓冲区是什么？"><a href="#TCP缓冲区是什么？" class="headerlink" title="TCP缓冲区是什么？"></a>TCP缓冲区是什么？</h4><p>每个 socket 被创建后，都会分配两个缓冲区，输入缓冲区和输出缓冲区。</p>
<h4 id="缓冲区的意义（作用）"><a href="#缓冲区的意义（作用）" class="headerlink" title="缓冲区的意义（作用）"></a>缓冲区的意义（作用）</h4><p> <strong>TCP的发送缓冲区是用来缓存应用程序的数据，发送缓冲区的每个字节都有序列号，被应答确认的序列号对应的数据会从发送缓冲区删除掉。</strong></p>
<img src="E:/面试/myJava.assets/50D7F6CDDD9A36ED91D4F78DFABF1DF3.jpeg" alt="img" style="zoom: 43%;" />

<p>write()&#x2F;send() 并不立即向网络中传输数据，而是先将数据写入缓冲区中，再由TCP协议将数据从缓冲区发送到目标机器。</p>
<p><strong>一旦将数据写入到缓冲区，函数就可以成功返回，不管它们有没有到达目标机器</strong>，也不管它们何时被发送到网络，这些都是TCP协议负责的事情。   </p>
<p>TCP协议独立于 write()&#x2F;send() 函数，数据有可能刚被写入缓冲区就发送到网络，也可能在缓冲区中不断积压，多次写入的数据被一次性发送到网络，比如nagle算法，这取决于当时的网络情况、当前线程是否空闲等诸多因素，不由程序员控制。   </p>
<p>read()&#x2F;recv() 函数也是如此，也从输入缓冲区中读取数据，而不是直接从网络中读取。</p>
<h4 id="I-x2F-O缓冲区特性"><a href="#I-x2F-O缓冲区特性" class="headerlink" title="I&#x2F;O缓冲区特性"></a>I&#x2F;O缓冲区特性</h4><p>（1）I&#x2F;O缓冲区在每个TCP套接字中单独存在；</p>
<p>（2）I&#x2F;O缓冲区在创建套接字时自动生成；</p>
<p>（3）即使关闭套接字也会继续传送输出缓冲区中遗留的数据；</p>
<p>（4）关闭套接字将丢失输入缓冲区中的数据。</p>
<h3 id="1-9-tcp粘包、拆包的机制"><a href="#1-9-tcp粘包、拆包的机制" class="headerlink" title="1.9 tcp粘包、拆包的机制"></a>1.9 tcp粘包、拆包的机制</h3><h4 id="TCP粘包和拆包问题"><a href="#TCP粘包和拆包问题" class="headerlink" title="TCP粘包和拆包问题"></a><strong>TCP粘包和拆包问题</strong></h4><p>  TCP是一个“流”协议，所谓流，就是<strong>没有界限的一长串二进制数据</strong>。TCP作为传输层协议并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行数据包的划分，所以在业务上认为是一个完整的包，可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。</p>
<h4 id="产生TCP粘包和拆包的原因"><a href="#产生TCP粘包和拆包的原因" class="headerlink" title="产生TCP粘包和拆包的原因"></a><strong>产生TCP粘包和拆包的原因</strong></h4><p>  我们知道TCP是以流的方式传输数据的，传输的<strong>最小单位</strong>为一个报文段（Segment）。TCP Header中有个Options标识位。常见的标识位为MSS（Maximum Segment Size）指的是，连接层每次传输的数据有个最大限制MTU（Maximum Transmission Unit），一般是1500bit，超过这个量要分成多个报文段，MSS则是这个最大限制减去TCP的header，光是要传输的数据的大小，一般为1460bit。换算成字节，也就是180多字节。   TCP为提高性能，发送端会将需要发送的数据发送到缓冲区，等待缓冲区满了以后，再将缓冲中的数据发送到接收方。同理，接收方也有缓冲区这样的机制来接受数据。 发生TCP粘包、拆包主要是以下原因：   </p>
<ul>
<li>（1）应用程序写入数据大于套接字缓冲区大小，会发生拆包；   </li>
<li>（2）应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发送粘包；   </li>
<li>（3）进行MSS（最大报文长度）大小的TCP分段，当TCP报文长度——TCP header长度&gt;MSS 的时候会发生拆包；   </li>
<li>（4）接收方法不及时读取套接字缓冲区数据，这将发生粘包。</li>
</ul>
<h4 id="如何处理粘包和拆包"><a href="#如何处理粘包和拆包" class="headerlink" title="如何处理粘包和拆包"></a><strong>如何处理粘包和拆包</strong></h4><p><strong>处理拆包</strong>：http连接是短连接，请求之后，收到回答，立马断开连接，不会出现粘包。 拆包现象是有可能存在的。</p>
<p>（1）通过包头+包长+包体的协议形式，当服务器端获取到指定的包长时才说明获取完整。   </p>
<p>（2） 指定包的结束标识，这样当我们获取到指定的标识时，说明包获取完整。</p>
<pre><code> **处理粘包**：http的短连接协议不会出现粘包的现象，但是一旦建立了长连接，粘包还是有可能会发生的。
</code></pre>
<p><strong>处理粘包的方法如下：</strong></p>
<p>  （1）发送方对于发送方造成的粘包问题，可以通过关闭Nagle算法来解决，使用TCP_NODELAY选项来关闭算法。</p>
<p>  （2）接收方没有办法来处理粘包现象，只能将问题交给应用层来处理。应用层的解决办法简单可行，不仅能解决接收方的粘包问题，还可以解决发送方的粘包问题。解决办法：循环处理，应用程序从接收缓存中读取分组时，读完一条数据，就应该循环读取下一条数据，直到所有数据都被处理完成，判断每条数据的长度的方法有两种：</p>
<p>​    a. 格式化数据：每条数据有固定的格式（开始符，结束符），这种方法简单易行，但是选择开始符和结束符时一定要确保每条数据的内部不包含开始符和结束符。</p>
<p>​    b. 发送长度：发送每条数据时，将数据的长度一并发送，例如规定数据的前4位是数据的长度，应用层在处理时可以根据长度来判断每个分组的开始和结束位置。</p>
<h4 id="UDP会不会产生粘包问题呢？"><a href="#UDP会不会产生粘包问题呢？" class="headerlink" title="UDP会不会产生粘包问题呢？"></a><strong>UDP会不会产生粘包问题呢？</strong></h4><p>  TCP为了保证可靠传输并减少额外的开销（每次发包都要验证），采用了基于流的传输，基于流的传输不认为消息是一条一条的，是无保护消息边界的（保护消息边界：指传输协议把数据当做一条独立的消息在网上传输，接收端一次只能接受一条独立的消息）。UDP则是面向消息传输的，是有保护消息边界的，接收方一次只接受一条独立的信息，所以不存在粘包问题。</p>
<p>  举个例子：有三个数据包，大小分别为2k、4k、6k，如果采用UDP发送的话，不管接受方的接收缓存有多大，我们必须要进行至少三次以上的发送才能把数据包发送完，但是使用TCP协议发送的话，我们只需要接受方的接收缓存有12k的大小，就可以一次把这3个数据包全部发送完毕。</p>
<h2 id="4-长连接和短连接"><a href="#4-长连接和短连接" class="headerlink" title="4. 长连接和短连接"></a>4. 长连接和短连接</h2><p>在HTTP&#x2F;1.0中，默认使用的是<strong>短连接</strong>。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其 他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。 </p>
<p>从 HTTP&#x2F;1.1起，默认使用<strong>长连接</strong>，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码： Connection:keep-alive 在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长 连接要客户端和服务端都支持长连接。 </p>
<p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p>
<h2 id="5-如何让UDP可靠一些？"><a href="#5-如何让UDP可靠一些？" class="headerlink" title="5. 如何让UDP可靠一些？"></a>5. 如何让UDP可靠一些？</h2><ol>
<li><p><strong>为什么需要可靠的UDP</strong></p>
<p>在弱网（2G、3G、信号不好）环境下，使用 TCP 连接的延迟很高，影响体验。使用 UDP 是很好的解决方案，既然把 UDP 作为弱网里面的 TCP 来使用，就必须保证数据传输能像 TCP 一样可靠</p>
</li>
<li><p><strong>如何实现可靠的UDP</strong></p>
<p><del>UDP它不属于连接型协议，因而具有资源消耗小，处理速度快的优点，所以通常音频、视频和普通数据在传送时使用UDP较多，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</del></p>
<p>传输层无法保证数据的可靠传输，只能通过<strong>应用层</strong>来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。关键在于两点，从应用层角度考虑：</p>
<p>（1）提供超时重传，能避免数据报丢失。</p>
<p>（2）提供确认序列号，可以对数据报进行确认和排序。</p>
<p> <strong>本端</strong>：首先在UDP数据报定义一个首部，首部包含确认序列号和时间戳，时间戳是用来计算RTT(数据报传输的往返时间)，计算出合适的RTO(重传的超时时间)。然后以等-停的方式发送数据报，即收到对端的确认之后才发送下一个的数据报。当时间超时，本端重传数据报，同时RTO扩大为原来的两倍，重新开始计时。</p>
<p> <strong>对端</strong>：接受到一个数据报之后取下该数据报首部的时间戳和确认序列号，并添加本端的确认数据报首部之后发送给对端。根据此序列号对已收到的数据报进行排序并丢弃重复的数据报。</p>
</li>
</ol>
<h2 id="6-HTTP和HTTPS"><a href="#6-HTTP和HTTPS" class="headerlink" title="6. HTTP和HTTPS"></a>6. HTTP和HTTPS</h2><ul>
<li><strong>安全性和资源消耗</strong> ：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。<strong>HTTPS</strong>是运行在 SSL&#x2F;TLS 之上的 HTTP 协议，SSL&#x2F;TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</li>
<li><strong>端口号</strong> ：HTTP 默认是 80，HTTPS 默认是 443。</li>
<li><strong>URL 前缀</strong> ：HTTP 的 URL 前缀是 <code>http://</code>，HTTPS 的 URL 前缀是 <code>https://</code>。</li>
</ul>
<h3 id="HTTP和HTTPS的区别？"><a href="#HTTP和HTTPS的区别？" class="headerlink" title="HTTP和HTTPS的区别？"></a>HTTP和HTTPS的区别？</h3><p><strong>HTTP</strong></p>
<p>HTTP（Hypertext Transfer Protocol）全称是超文本传输协议，它是一个无状态协议，也就是说服务器不维护任何有关客户端过去所发请求的消息。HTTP 是<strong>应用层</strong>协议，它以 TCP（传输层）作为底层协议，默认端口为 80。HTTP扩展性强、速度快、跨平台支持性好。</p>
<p><strong>HTTPS</strong></p>
<p>HTTPS 协议（Hyper Text Transfer Protocol Secure），是 HTTP 的加强安全版本。HTTPS 是基于 HTTP 的，也是用 TCP 作为底层协议，并额外使用 SSL&#x2F;TLS 协议用作加密和安全认证。默认端口号是 443。</p>
<p>HTTPS 协议中，SSL 通道通常使用基于密钥的加密算法，密钥长度通常是 40 比特或 128 比特。HTTPS保密性好、信任度高。</p>
<h3 id="HTTP系列的区别"><a href="#HTTP系列的区别" class="headerlink" title="HTTP系列的区别"></a>HTTP系列的区别</h3><h4 id="HTTP1-0和HTTP1-1的区别"><a href="#HTTP1-0和HTTP1-1的区别" class="headerlink" title="HTTP1.0和HTTP1.1的区别?"></a>HTTP1.0和HTTP1.1的区别?</h4><p><strong>长连接</strong>：HTTP 1.1支持长连接（Persistent Connection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive ，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</p>
<p><strong>缓存处理</strong>：在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略，可供选择的缓存头来控制缓存策略。</p>
<p><strong>带宽优化及网络连接的使用</strong>：<strong>HTTP1.0</strong>中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且<strong>不支持断点续传</strong>功能，<strong>HTTP1.1</strong>则在请求头引入了range头域，它<strong>允许只请求资源的某个部分</strong>，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p>
<p><strong>错误通知的管理</strong>：在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p>
<p><strong>Host头处理</strong>：在<strong>HTTP1.0</strong>中认为每台服务器都绑定一个唯一的IP地址，因此，<strong>请求消息中的URL并没有传递主机名</strong>（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。<strong>HTTP1.1的请求消息和响应消息都应支持Host头域</strong>，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）</p>
<h4 id="HTTP1-1和-HTTP2-0的区别？"><a href="#HTTP1-1和-HTTP2-0的区别？" class="headerlink" title="HTTP1.1和 HTTP2.0的区别？"></a>HTTP1.1和 HTTP2.0的区别？</h4><p>HTTP2.0相比HTTP1.1支持的特性：</p>
<p><strong>新的二进制格式</strong>：HTTP1.1的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</p>
<p><strong>多路复用</strong>，即连接共享，即每一个request都是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</p>
<p><strong>头部压缩</strong>，HTTP1.1的头部（header）带有大量信息，而且每次都要重复发送；HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</p>
<p><strong>服务端推送</strong>：服务器除了对最初请求的响应外，服务器还可以额外的向客户端推送资源，而无需客户端明确的请求。</p>
<img src="E:/面试/myJava.assets/Untitled 33.png" alt="Untitled" style="zoom:100%;" />

<h3 id="HTTPS的秘钥交换过程"><a href="#HTTPS的秘钥交换过程" class="headerlink" title="HTTPS的秘钥交换过程"></a>HTTPS的秘钥交换过程</h3><p>  HTTPS的密钥交换过程如下：</p>
<ol>
<li><p>客户端要访问一个网站，向支持https的服务器发起请求。</p>
</li>
<li><p>客户端向服务器发送自己支持的秘钥交换算法列表。</p>
</li>
<li><p>服务器选取一种秘钥交换算法加上CA证书返回给客户端。</p>
</li>
<li><p>客户端验证服务器是否合法，并生成一个随机数然后用协商好的加密算法加密生成随机秘钥，并用刚才从CA证书中拿到的公钥对其加密后发送给服务器。</p>
</li>
<li><p>服务器收到后用自己的私钥解密（中间人没有服务器的私钥，所以没有办法看到传输的数据，另外确认秘钥交换算法是在第一步，中间人是不知道秘钥交换算法（中间人是无法在第一步做手脚的，那等同于它自己就是一个真实客户端发起了一个新的请求，唯一一种情况攻击人有一个合法CA下发的证书，且客户端（一般为安卓设备）没有对CA下发的证书中的内容网站地址和当前请求地址做对比校验），就算攻击者有公钥，因为不知道协商协议，所以做不出来随机秘钥，顶多就是在传输过程中将报文拦截下来，乱改，但是给到服务器后，私钥是解不开乱改之后的密文的）。</p>
</li>
<li><p>服务器私钥解密之后，拿到对称秘钥，并且用它再加密一个信息，返回给浏览器。</p>
<p><strong>注意：</strong>最关键的一步就是在客户端采用 <strong>RSA</strong> 或 Diffie-Hellman 等加密算法生成 Pre-master，这个随机秘钥是用来计算最终的对称秘钥的，用公钥加密之后攻击人是不知道这个这个随机秘钥的，只有服务器才能解的开。</p>
</li>
</ol>
<h3 id="为什么HTTPS用到了非对称-x2F-对称加密两种"><a href="#为什么HTTPS用到了非对称-x2F-对称加密两种" class="headerlink" title="为什么HTTPS用到了非对称&#x2F;对称加密两种"></a>为什么HTTPS用到了非对称&#x2F;对称加密两种</h3><ul>
<li><p>第一阶段的<strong>非对称加密</strong>，保证了对称密钥的<strong>安全</strong>性；</p>
</li>
<li><p>第二阶段的<strong>对称加密</strong>，可以提高加密&#x2F;解密处理的<strong>速度</strong>，提高数据传输的效率。</p>
</li>
</ul>
<p><strong>因为对称加密的保密性完全依赖于密钥的保密性。</strong>在双方通信之前，需要商量一个用于对称加密的密钥。而网络通信的信道是不安全的，传输报文对任何人是可见的，密钥的交换肯定不能直接在网络信道中传输。因此，使用非对称加密，对对称加密的密钥进行加密，保护该密钥不在网络信道中被窃听。这样，通信双方只需要一次非对称加密，交换对称加密的密钥，在之后的信息通信中，使用绝对安全的密钥，对信息进行对称加密，即可保证传输消息的保密性。</p>
<h3 id="HTTPS的证书认证过程"><a href="#HTTPS的证书认证过程" class="headerlink" title="HTTPS的证书认证过程"></a>HTTPS的证书认证过程</h3><p>  HTTPS的证书认证过程如下：</p>
<ol>
<li><p>浏览器将自己支持的一套加密规则发送给网站。</p>
</li>
<li><p>网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。</p>
</li>
<li><p>浏览器获得网站证书之后浏览器要做以下工作：</p>
<p>（1） 验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。 （2）如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。 （3）使用约定好的HASH算法计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。</p>
</li>
<li><p>网站接收浏览器发来的数据之后要做以下的操作：</p>
<p>（1） 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。 （2） 使用密码加密一段握手消息，发送给浏览器。</p>
</li>
<li><p>浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。</p>
</li>
</ol>
<h3 id="为什么要有CA？"><a href="#为什么要有CA？" class="headerlink" title="为什么要有CA？"></a><strong>为什么要有CA？</strong></h3><p><strong>为了非对称加密中公钥传输的信赖性问题，防止中间人攻击。</strong>	</p>
<p>CA 默认是受信任的第三方。CA 会给各个服务器颁发证书，证书存储在服务器上，并附有 CA 的<strong>电子签名</strong>。（为了防止郑虎被伪造，用到了数字签名。数字签名，是 CA 在给服务器颁发证书时，使用散列+加密的组合技术，在证书上盖个章，以此来提供验伪的功能。）</p>
<p><strong>PS</strong>：（CA 知道服务器的公钥，对该公钥采用散列技术生成一个摘要。CA 使用 CA 私钥对该摘要进行加密，并附在证书下方，发送给服务器。</p>
<p>现在服务器将该证书发送给客户端，客户端需要验证该证书的身份。客户端找到第三方机构 CA，获知 CA 的公钥，并用 CA 公钥对证书的签名进行解密，获得了 CA 生成的摘要。</p>
<p>客户端对证书数据（也就是服务器的公钥）做相同的散列处理，得到摘要，并将该摘要与之前从签名中解码出的摘要做对比，如果相同，则身份验证成功；否则验证失败。）</p>
<h3 id="SSL-x2F-STL"><a href="#SSL-x2F-STL" class="headerlink" title="SSL&#x2F;STL"></a>SSL&#x2F;STL</h3><p>SSL 指安全套接字协议（Secure Sockets Layer），TLS 是基于 SSL 之上的，但由于习惯叫法，通常把 HTTPS 中的核心加密协议混成为 SSL&#x2F;TLS。</p>
<p><strong>SSL&#x2F;STL的工作原理</strong></p>
<p>SSL&#x2F;TLS 的核心要素是<strong>非对称加密</strong>。非对称加密采用两个密钥——一个公钥，一个私钥。在通信时，私钥仅由解密者保存，公钥由任何一个想与解密者通信的发送者（加密者）所知。非对称加密的公钥和私钥需要采用一种复杂的数学机制生成（密码学认为，为了较高的安全性，尽量不要自己创造加密方案）。公私钥对的生成算法依赖于单向陷门函数。</p>
<p>使用 SSL&#x2F;TLS 进行通信的双方需要使用非对称加密方案来通信，但是非对称加密设计了较为复杂的数学算法，在实际通信过程中，计算的代价较高，效率太低，因此，<strong>SSL&#x2F;TLS 实际对消息的加密使用的是对称加密</strong>。（<strong>对称加密</strong>：通信双方共享唯一密钥 k，加解密算法已知，加密方利用密钥 k 加密，解密方利用密钥 k 解密，保密性依赖于密钥 k 的保密性。）</p>
<h2 id="7-HTTP状态码"><a href="#7-HTTP状态码" class="headerlink" title="7. HTTP状态码"></a>7. HTTP状态码</h2><table>
<thead>
<tr>
<th>分类</th>
<th>分类描述</th>
</tr>
</thead>
<tbody><tr>
<td>1**</td>
<td>信息，服务器收到请求，需要请求者继续执行操作</td>
</tr>
<tr>
<td>2**</td>
<td>成功，操作被成功接收并处理</td>
</tr>
<tr>
<td>3**</td>
<td>重定向，需要进一步的操作以完成请求</td>
</tr>
<tr>
<td>4**</td>
<td>客户端错误，请求包含语法错误或无法完成请求</td>
</tr>
<tr>
<td>5**</td>
<td>服务器错误，服务器在处理请求的过程中发生了错误</td>
</tr>
</tbody></table>
<p>常见状态码：</p>
<ul>
<li><p><strong>200</strong>：服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。</p>
</li>
<li><p><strong>201</strong>： 已创建。成功请求并创建了新的资源</p>
</li>
<li><p><strong>202</strong> (Accepted&#x2F;接受) (SC_ACCEPTED)告诉客户端请求正在被执行，但还没有处理完。</p>
</li>
<li><p>203：非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</p>
</li>
<li><p>204：无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</p>
</li>
<li><p>205：重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</p>
</li>
<li><p>206：部分内容。服务器成功处理了部分GET请求</p>
</li>
<li><p><strong>301</strong>： 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</p>
</li>
<li><p><strong>302</strong>：临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</p>
</li>
<li><p>303：查看其它地址。与301类似。使用GET和POST请求查看</p>
</li>
<li><p>304：未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</p>
</li>
<li><p>305：使用代理。所请求的资源必须通过代理访问</p>
</li>
<li><p>306：已经被废弃的HTTP状态码</p>
</li>
<li><p>307：临时重定向。与302类似。使用GET请求重定向</p>
</li>
<li><p><strong>400</strong> ：客户端请求的语法错误，服务器无法理解</p>
</li>
<li><p><strong>401</strong> (Unauthorized&#x2F;未授权)请求要求用户的身份认证</p>
<p>401 (SC_UNAUTHORIZED)表示客户端在授权头信息中没有有效的身份信息时访问受到密码保护的页面。这个响应必须包含一个WWW-Authenticate的授权信息头。</p>
</li>
<li><p><strong>403</strong> ：服务器理解请求客户端的请求，但是拒绝执行此请求</p>
</li>
<li><p><strong>404</strong> ：服务器无法根据客户端的请求找到资源（网页）。</p>
</li>
<li><p>405：客户端请求中的方法被禁止</p>
</li>
<li><p>406：服务器无法根据客户端请求的内容特性完成请求</p>
</li>
<li><p>407：请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</p>
</li>
<li><p>408：服务器等待客户端发送的请求时间过长，超时</p>
</li>
<li><p>409：服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</p>
</li>
<li><p>410：客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</p>
</li>
<li><p>411：服务器无法处理客户端发送的不带Content-Length的请求信息</p>
</li>
<li><p>412：客户端请求信息的先决条件错误</p>
</li>
<li><p>413：由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</p>
</li>
<li><p>414：请求的URI过长（URI通常为网址），服务器无法处理</p>
</li>
<li><p>415：服务器无法处理请求附带的媒体格式</p>
</li>
<li><p>416：客户端请求的范围无效</p>
</li>
<li><p>417：服务器无法满足Expect的请求头信息</p>
</li>
<li><p><strong>500</strong>： (服务器内部错误) 服务器遇到错误，无法完成请求。</p>
</li>
<li><p>501： 服务器不支持请求的功能，无法完成请求</p>
</li>
<li><p><strong>502</strong> (Bad Gateway&#x2F;错误的网关)作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</p>
</li>
<li><p><strong>503</strong> (Service Unavailable&#x2F;服务无法获得)由于超载或系统维护，服务器暂时的无法处理客户端的请求。<u>例如</u>，如果某些线程或数据库连接池已经没有空闲则servlet会返回这个头信息。服务器可提供一个Retry-After头信息告诉客户端什么时候可以在试一次。</p>
</li>
<li><p><strong>504</strong> (Gateway Timeout&#x2F;网关超时)充当网关或代理的服务器，未及时从远端服务器获取请求</p>
</li>
<li><p>505：服务器不支持请求的HTTP协议的版本，无法完成处理</p>
</li>
</ul>
<h2 id="8-DNS域名解析"><a href="#8-DNS域名解析" class="headerlink" title="8. DNS域名解析"></a>8. DNS域名解析</h2><ol>
<li>首先客户端位置是一台电脑或手机，在打开浏览器以后，比如输入<a href="http://www.zdns.cn的域名，它首先是由浏览器发起一个DNS解析请求，如果本地缓存服务器中找不到结果，则首先会向根服务器查询，根服务器里面记录的都是各个顶级域所在的服务器的位置，当向根服务器请求[http://www.zdns.cn]的时候，根服务器就会返回.cn服务器的位置信息；">http://www.zdns.cn的域名，它首先是由浏览器发起一个DNS解析请求，如果本地缓存服务器中找不到结果，则首先会向根服务器查询，根服务器里面记录的都是各个顶级域所在的服务器的位置，当向根服务器请求[http://www.zdns.cn]的时候，根服务器就会返回.cn服务器的位置信息；</a></li>
<li>递归服务器拿到.cn的权威服务器地址以后，就会寻问.cn的权威服务器，知不知道[<a href="http://www.zdns.cn]的位置。这个时候.cn权威服务器查找并返回[http://zdns.cn]服务器的地址；">http://www.zdns.cn]的位置。这个时候.cn权威服务器查找并返回[http://zdns.cn]服务器的地址；</a></li>
<li>继续向[<a href="http://zdns.cn]的权威服务器去查询这个地址，由[http://zdns.cn]的服务器给出了地址：202.173.11.10；">http://zdns.cn]的权威服务器去查询这个地址，由[http://zdns.cn]的服务器给出了地址：202.173.11.10；</a></li>
<li>最终进入http的链接，顺利访问网站；</li>
</ol>
<p><strong>补充说明</strong>：一旦递归服务器拿到解析记录以后，就会在本地进行缓存，如果下次客户端再请求本地的递归域名服务器相同域名的时候，就不会再这样一层一层查了，因为本地服务器里面已经有缓存了，这个时候就直接把[<a href="http://www.zdns.cn]的记录返回给客户端就可以了。">http://www.zdns.cn]的记录返回给客户端就可以了。</a></p>
<p><strong>一级&#x2F;二级&#x2F;三级域名什么区别？</strong></p>
<ul>
<li>一级域名：又叫顶级域名，一般分为国家顶级域名(如.cn、.us等)和国际顶级域名(如.net)</li>
<li>二级域名：在顶级域名之下的域名，可以按照不同类型(如.gov、.edu等)或者不同地域分(如省份)。</li>
<li>三级域名：这个域名是让网站的制作者自己起的，三级域名是由字母、大小写以及连接符号三个部分组成的，网站制作者可以根据自己网站的特点进行选择。</li>
</ul>
<h2 id="9-输入一条url经历的过程？"><a href="#9-输入一条url经历的过程？" class="headerlink" title="9. 输入一条url经历的过程？"></a>9. 输入一条url经历的过程？</h2><ul>
<li>客户端获取URL-&gt;封装HTTP请求 - &gt; DNS解析 - &gt; TCP连接 - &gt;发送HTTP请求 - &gt;服务器处理请求 - &gt;返回报文 - &gt;浏览器解析渲染页面 - &gt; TCP断开连接</li>
</ul>
<ol>
<li><p>解析URL </p>
<p>浏览器做的第⼀步就是解析 URL 得到⾥⾯的参数，将域名和需要请求的资源分离开来 </p>
<p><img src="E:学习笔记图片\image-20220719204933154.png" alt="image-20220719204933154"></p>
</li>
<li><p>封装HTTP请求 「封装」成⼀个 HTTP 请求报⽂发送。</p>
<p><img src="E:学习笔记图片\image-20220719205000000.png" alt="image-20220719205000000"></p>
</li>
<li><p>DNS域名解析</p>
<p><strong>递归查询</strong>：浏览器DNS缓存—-&gt;操作系统DNS缓存—-&gt;本地host文件</p>
<p>当浏览器拿到输入的 <a href="https://link.zhihu.com/?target=http://www.baidu.com">http://www.baidu.com</a> 后，首先会去浏览器的 dns 缓存中去查询是否有对应记录，如果查询到记录就可以直接返回 ip 地址，完成解析。</p>
<p>如果浏览器没有缓存，那就再去查询操作系统的缓存，同样的，如果查询到记录就可以直接返回 ip 地址，完成解析。</p>
<p>如果操作系统也没有缓存，那就再去查看本地 host 文件，Windows 下 host 文件一般位于 “C:\Windows\System32\drivers\etc”。</p>
<p>如果本地 host 文件也没有相应记录，那就需要求助于本地 dns 服务器了，</p>
<p><strong>迭代查询</strong>：本地DNS服务器—-&gt;根域名服务器—-&gt;顶级域名服务器—-&gt;权限域名服务器</p>
<p>dns 域名服务器一般分三种，分别是根域名服务器 (.)、顶级域名服务器 (.com)、权限域名服务器 (<a href="https://link.zhihu.com/?target=http://baidu.com">http://baidu.com</a>) 。</p>
<p><img src="E:学习笔记图片\image-20220719205057959.png" alt="image-20220719205057959"></p>
</li>
<li><p>建⽴TCP连接 </p>
<p>三次握手</p>
</li>
<li><p>准备发送请求（TCP）</p>
<p>TCP：HTTP报⽂——&gt;序号分割—–&gt;若⼲报⽂段+加上 TCP ⾸部 </p>
</li>
<li><p>数据传输（IP） </p>
<p>添加 IP ⾸部封装成 IP 数据报，数据分组+路由选择。</p>
</li>
<li><p>服务器响应请求 </p>
<ol>
<li>TCP：重组报⽂，解析数据 </li>
<li>HTTP:Web 映射获取请求资源</li>
</ol>
</li>
<li><p>数据返回，关闭连接</p>
<p>同样TCP&#x2F;IP协议传回 </p>
<p>假如不在传输数据，四次挥⼿</p>
</li>
<li><p>浏览器解析渲染 </p>
<p>根据响应码，进⾏响应，解码HTML⽂件 </p>
<ol>
<li>HTML解析器：解析JS，DOM，CSS  </li>
<li>异步请求css,图⽚等资源 （http2.0直接发送）</li>
<li>渲染</li>
</ol>
</li>
<li><p>如何客户端没有其他的请求，则通过四次挥手断开连接。</p>
</li>
</ol>
<h2 id="10-GET和POST的区别"><a href="#10-GET和POST的区别" class="headerlink" title="10.GET和POST的区别"></a>10.GET和POST的区别</h2><p>正常情况下</p>
<ul>
<li><p>GET在浏览器回退时是无害的，而POST会再次提交请求。</p>
</li>
<li><p>GET产生的URL地址可以被Bookmark，而POST不可以。</p>
</li>
<li><p>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</p>
</li>
<li><p>GET请求只能进行url编码，而POST支持多种编码方式。 </p>
</li>
<li><p>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</p>
</li>
<li><p>GET请求在URL中传送的参数是有长度限制的，而POST么有。</p>
</li>
<li><p>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</p>
</li>
<li><p>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</p>
</li>
<li><p>GET参数通过URL传递，POST放在Request body中。</p>
</li>
</ul>
<p>（本标准答案参考自w3schools）</p>
<h3 id="8-1是否幂等"><a href="#8-1是否幂等" class="headerlink" title="8.1是否幂等"></a>8.1是否幂等</h3><p>GET同来读取一个资源，可以对GET请求的数据做缓存，反复读取不应该对访问的数据有副作用。比如”GET一下，用户就下单了，返回订单已受理“。没有副作用被称为“幂等“（Idempotent)。</p>
<p>POST用于上传资源最明显的区别：GET把参数包含在URL中，在页面里<form> 标签会定义一个表单。点击其中的submit元素会发出一个POST请求让服务器做一件事。这件事往往是<strong>有副作用的，不幂等的</strong>。不幂等也就意味着不能随意多次执行。因此也就不能缓存，比如通过POST下一个单，服务器创建了新的订单，然后返回订单成功的界面。这个页面不能被缓存。试想一下，如果POST请求被浏览器缓存了，那么下单请求就可以不向服务器发请求，而直接返回本地缓存的“下单成功界面”，却又没有真的在服务器下单。</p>
<h3 id="8-2数据格式"><a href="#8-2数据格式" class="headerlink" title="8.2数据格式"></a>8.2数据格式</h3><p>GET和POST携带数据的格式也有区别。当浏览器发出一个GET请求时，就意味着要么是用户自己在浏览器的地址栏输入，要不就是点击了html里a标签的href中的url。所以其实<strong>并不是GET只能用url，而是</strong>浏览器直接发出的GET只能由一个url触发。所以没办法，GET上要在url之外带一些参数就只能依靠url上附带querystring。但是HTTP协议本身并没有这个限制。</p>
<p><strong>浏览器的POST请求都来自表单提交</strong>。每次提交，<strong>表单的数据被浏览器用编码到HTTP请求的body里</strong>。浏览器发出的POST请求的body主要有有两种格式，一种是application&#x2F;x-www-form-urlencoded用来传输简单的数据，大概就是”key1&#x3D;value1&amp;key2&#x3D;value2”这样的格式。另外一种是传文件，会采用multipart&#x2F;form-data格式。采用后者是因为application&#x2F;x-www-form-urlencoded的编码方式对于文件这种二进制的数据非常低效。</p>
<p>POST通过request body传 递参数。</p>
<h3 id="8-3关于安全性"><a href="#8-3关于安全性" class="headerlink" title="8.3关于安全性"></a>8.3关于安全性</h3><p>我们常听到GET不如POST安全，因为POST用body传输数据，而GET用url传输，更加容易看到。但是从攻击的角度，无论是GET还是POST都不够安全，因为HTTP本身是<strong>明文协议</strong>。<strong>每个HTTP请求和返回的每个byte都会在网络上明文传播，不管是url，header还是body</strong>。</p>
<p><strong>但是，实际上：GET和POST本质上没区别</strong></p>
<p>   HTTP的底层是TCP&#x2F;IP。所以GET和POST的底层也是TCP&#x2F;IP，也就是说，GET&#x2F;POST都是TCP链接。GET和POST能做的事情是一样一样的。</p>
<p>GET和POST还有一个<strong>重大区别</strong>，简单的说：</p>
<p>GET产生一个TCP数据包；POST产生两个TCP数据包。 </p>
<p>长的说：</p>
<p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p>
<p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p>
<h3 id="8-4关于编码"><a href="#8-4关于编码" class="headerlink" title="8.4关于编码"></a>8.4关于编码</h3><p><strong>常见的说法有，比如GET的参数只能支持ASCII，而POST能支持任意binary，包括中文。但其实从上面可以看到，GET和POST实际上都能用url和body。</strong>因此所谓编码确切地说应该是http中url用什么编码，body用什么编码。</p>
<p>url只能支持ASCII的说法源自于<a href="https://link.zhihu.com/?target=https://www.ietf.org/rfc/rfc1738.txt">RFC1738</a>。实际上这里规定的仅仅是一个ASCII的子集[a-zA-Z0-9$-_.+!*’(),]。它们是可以“不经编码”在url中使用。比如尽管空格也是ASCII字符，但是不能直接用在url里。</p>
<p>如果url有了特殊符号和中文怎么办呢？一种叫做percent encoding的编码方法就是干这个用的：但要特别注意，这个编码方式只管把字符转换成URL可用字符，但是却不管字符集编码（比如中文到底是用UTF8还是GBK）。</p>
<p>因此，这块早期一直都相当乱，也没有什么统一规范。<strong>对于同样一个带中文的url，如果有的浏览器一定要用GBK（比如老的IE8），有的一定要用UTF8（比如chrome）。后端就可能认不出来。对此常用的办法是避免让用户输入这种带中文的url。</strong>如果有这种形式的请求，都改成用户界面上输入，然后通过Ajax发出的办法。Ajax发出的编码形式开发者是可以100%控制的。</p>
<p>HTTP Body相对好些，因为有个Content-Type来比较明确的定义。比如：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST xxxxxx HTTP/1.1</span><br><span class="line">...</span><br><span class="line">Content-Type: application/x-www-form-urlencoded ; charset=UTF-8</span><br></pre></td></tr></table></figure>

<p>这里Content-Type会同时定义请求body的格式（application&#x2F;x-www-form-urlencoded）和字符编码（UTF-8）。</p>
<p>因此可见，<strong>body和url都可以提交中文数据给后端，但是POST的规范好一些，相对不容易出错，容易让开发者安心。</strong></p>
<h2 id="11-HTTP头部"><a href="#11-HTTP头部" class="headerlink" title="11.HTTP头部"></a>11.HTTP头部</h2><p>HTTP的头域包括通用头、请求头、响应头和实体头四个部分。每个头域由一个域名，冒号（:）和域值三部分组成。</p>
<p>　　通用头部：是客户端和服务器都可以使用的头部，可以在客户端、服务器和其他应用程序之间提供一些非常有用的通用功能，如Date头部。</p>
<p>　　请求头部：是请求报文特有的，它们为服务器提供了一些额外信息，比如客户端希望接收什么类型的数据，如Accept头部。</p>
<p>　　响应头部：便于客户端提供信息，比如，客服端在与哪种类型的服务器进行交互，如Server头部。</p>
<p>　　实体头部：指的是用于应对实体主体部分的头部，比如，可以用实体头部来说明实体主体部分的数据类型，如Content-Type头部。</p>
<h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><p>请求头用于说明是谁或什么在发送请求、请求源于何处，或者客户端的喜好及能力。</p>
<p>请求头域可能包含下列字段Accept、Accept-Charset、Accept- Encoding、Accept-Language、Authorization、From、Host、If-Modified-Since、If-Match、If-None-Match、If-Range、If-Range、If-Unmodified-Since、Max-Forwards、Proxy-Authorization、Range、Referer、User-Agent。对请求头域的扩展要求通讯双方都支持，如果存在不支持的请求头域，一般将会作为实体头域处理。</p>
<p>从HTTP协议的角度，“请求头”就是Method + URL（含querystring）+ Headers；再后边的都是请求体。</p>
<p><img src="E:\学习笔记\图片\1460000006760778" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">请求行</span><br><span class="line">GET http://www.example.com/ HTTP/1.1</span><br><span class="line">请求头</span><br><span class="line">Accept:</span><br><span class="line">text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*</span><br><span class="line">;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9,en;q=0.8</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Host: www.example.com</span><br><span class="line">If-Modified-Since: Thu, 17 Oct 2019 07:18:26 GMT</span><br><span class="line">If-None-Match: &quot;3147526947+gzip&quot;</span><br><span class="line">Proxy-Connection: keep-alive</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 xxx</span><br><span class="line">空行</span><br><span class="line">请求体</span><br><span class="line">param1=1&amp;param2=2</span><br></pre></td></tr></table></figure>

<p>举例</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">1）请求(客户端-&gt;服务端[request]) </span><br><span class="line">    GET(请求的方式) /newcoder/hello.html(请求的目标资源) HTTP/1.1(请求采用的协议和版本号) </span><br><span class="line">    Accept: */*(客户端能接收的资源类型) </span><br><span class="line">    Accept-Language: en-us(客户端接收的语言类型) </span><br><span class="line">    Connection: Keep-Alive(维护客户端和服务端的连接关系) </span><br><span class="line">    Host: localhost:8080(连接的目标主机和端口号) </span><br><span class="line">    Referer: http://localhost/links.asp(告诉服务器我来自于哪里) </span><br><span class="line">    User-Agent: Mozilla/4.0(客户端版本号的名字) </span><br><span class="line">    Accept-Encoding: gzip, deflate(客户端能接收的压缩数据的类型) </span><br><span class="line">    If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT(缓存时间)  </span><br><span class="line">    Cookie(客户端暂存服务端的信息) </span><br><span class="line">    Date: Tue, 11 Jul 2000 18:23:51 GMT(客户端请求服务端的时间)</span><br><span class="line">    </span><br><span class="line">2）响应(服务端-&gt;客户端[response])</span><br><span class="line">    HTTP/1.1(响应采用的协议和版本号) 200(状态码) OK(描述信息)</span><br><span class="line">    Location: http://www.baidu.com(服务端需要客户端访问的页面路径) </span><br><span class="line">    Server:apache tomcat(服务端的Web服务端名)</span><br><span class="line">    Content-Encoding: gzip(服务端能够发送压缩编码类型) </span><br><span class="line">    Content-Length: 80(服务端发送的压缩数据的长度) </span><br><span class="line">    Content-Language: zh-cn(服务端发送的语言类型) </span><br><span class="line">    Content-Type: text/html; charset=GB2312(服务端发送的类型及采用的编码方式)</span><br><span class="line">    Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT(服务端对该资源最后修改的时间)</span><br><span class="line">    Refresh: 1;url=http://www.it315.org(服务端要求客户端1秒钟后，刷新，然后访问指定的页面路径)</span><br><span class="line">    Content-Disposition: attachment; filename=aaa.zip(服务端要求客户端以下载文件的方式打开该文件)</span><br><span class="line">    Transfer-Encoding: chunked(分块传递数据到客户端）  </span><br><span class="line">    Set-Cookie:SS=Q0=5Lb_nQ; path=/search(服务端发送到客户端的暂存数据)</span><br><span class="line">    Expires: -1//3种(服务端禁止客户端缓存页面数据)</span><br><span class="line">    Cache-Control: no-cache(服务端禁止客户端缓存页面数据)  </span><br><span class="line">    Pragma: no-cache(服务端禁止客户端缓存页面数据)   </span><br><span class="line">    Connection: close(1.0)/(1.1)Keep-Alive(维护客户端和服务端的连接关系)  </span><br><span class="line">    Date: Tue, 11 Jul 2000 18:23:51 GMT(服务端响应客户端的时间)</span><br></pre></td></tr></table></figure>

<h2 id="12-cookie-x2F-session"><a href="#12-cookie-x2F-session" class="headerlink" title="12. cookie &#x2F; session"></a>12. cookie &#x2F; session</h2><h3 id="什么是-Cookie"><a href="#什么是-Cookie" class="headerlink" title="什么是 Cookie"></a>什么是 Cookie</h3><p>HTTP Cookie（也叫 Web Cookie或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，客户端向服务器发起请求，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。</p>
<p>Cookie 使基于无状态的HTTP 协议记录稳定的状态信息成为了可能。</p>
<p><strong>Cookie 主要用于以下三个方面</strong>：</p>
<ul>
<li><strong>会话状态管理</strong>（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li><strong>个性化设置</strong>（如用户自定义设置、主题等）</li>
<li><strong>浏览器行为跟踪</strong>（如跟踪分析用户行为等）</li>
</ul>
<p>【PS：**Cookie 被禁用怎么办?**最常用的就是利用 URL 重写把 Session ID 直接附加在 URL 路径的后面】</p>
<h3 id="什么是-Session"><a href="#什么是-Session" class="headerlink" title="什么是 Session"></a>什么是 Session</h3><p>Session 代表着服务器和客户端一次会话的过程（会话指建立连接到断开连接中间发生的所有动作）。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。</p>
<h3 id="cookie和session是如何配合的？"><a href="#cookie和session是如何配合的？" class="headerlink" title="cookie和session是如何配合的？"></a>cookie和session是如何配合的？</h3><p>用户<strong>第一次请求</strong>服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session ，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。</p>
<p>当用户<strong>第二次访问</strong>服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</p>
<p>根据以上流程可知，<strong>SessionID</strong>是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。</p>
<h3 id="Cookie和Session的区别？"><a href="#Cookie和Session的区别？" class="headerlink" title="Cookie和Session的区别？"></a>Cookie和Session的区别？</h3><ul>
<li><strong>存储位置不同：</strong>Cookie 保存在客户端（浏览器），Session 保存在服务器端。</li>
<li><strong>存取方式的不同：</strong>Cookie 只能保存 ASCII，Session可以存任意数据类型，一般情况下我们可以在Session 中保持一些常用变量信息，比如说 UserId 等。</li>
<li><strong>有效期不同：</strong>Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。</li>
<li><strong>隐私策略不同：</strong>Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。</li>
<li><strong>存储大小不同：</strong> 单个Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。</li>
</ul>
<h2 id="13-分布式session"><a href="#13-分布式session" class="headerlink" title="13. 分布式session"></a>13. 分布式session</h2><p>一般会有以下几种解决方案：</p>
<ul>
<li><strong>客户端存储</strong>：直接将信息存储在cookie中，cookie是存储在客户端上的一小段数据，客户端通过http协议和服务器进行cookie交互，通常用来存储一些不敏感信息</li>
<li><strong>Nginx ip_hash 策略</strong>：服务端使用 Nginx 代理，每个请求按访问 IP 的 hash 分配，这样来自同一IP 固定访问一个后台服务器，避免了在服务器 A 创建 Session，第二次分发到服务器 B 的现象。</li>
<li><strong>Session 复制</strong>：任何一个服务器上的 Session 发生改变（增删改），该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点。</li>
<li><strong>共享 Session</strong>：服务端无状态化，将用户的 Session 等信息使用缓存中间件（如Redis）来统一管理，保障分发到每一个服务器的响应结果都一致。</li>
<li><strong>建议采用共享 Session的方案</strong>。</li>
</ul>
<h2 id="14-负载均衡算法有哪些？"><a href="#14-负载均衡算法有哪些？" class="headerlink" title="14. 负载均衡算法有哪些？"></a>14. 负载均衡算法有哪些？</h2><p>多台服务器以对称的方式组成一个服务器集合，每台服务器都具有等价的地位，能互相分担负载。</p>
<ul>
<li><strong>轮询法</strong>：将请求按照顺序轮流的分配到服务器上。大锅饭，不能发挥某些高性能服务器的优势。</li>
<li>随机法：随机获取一台，和轮询类似。</li>
<li>哈希法：通过ip地址哈希化来确定要选择的服务器编号。好处是,每次客户端访问的服务器都是同一个服务器，能很好地利用session或者cookie。</li>
<li><strong>加权轮询</strong>：根据服务器性能不同加权。</li>
</ul>
<h2 id="15-Telnet-x2F-SSH"><a href="#15-Telnet-x2F-SSH" class="headerlink" title="15. Telnet &#x2F; SSH"></a>15. <strong>Telnet &#x2F; SSH</strong></h2><p><strong>Telnet（远程登陆协议）</strong>通过一个终端登陆到其他服务器，建立在可靠的传输协议 TCP 之上。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用Telnet并被一种称为SSH的非常安全的协议所取代的主要原因。</p>
<p><strong>SSH（Secure Shell 安全的网络传输协议）</strong> 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 建立在可靠的传输协议 TCP 之上。</p>
<p><strong>Telnet 和 SSH 之间的主要区别在于 SSH 协议会对传输的数据进行加密保证数据安全性。</strong></p>
<h2 id="16-URI-和-URL-的区别是什么"><a href="#16-URI-和-URL-的区别是什么" class="headerlink" title="16. URI 和 URL 的区别是什么?"></a>16. <strong>URI 和 URL 的区别是什么?</strong></h2><ul>
<li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</li>
<li>URL(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</li>
</ul>
<p>URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p>
<h2 id="17-BIO、NIO、AIO的区别？"><a href="#17-BIO、NIO、AIO的区别？" class="headerlink" title="17.BIO、NIO、AIO的区别？"></a>17.BIO、NIO、AIO的区别？</h2><p><strong>BIO</strong>：<strong>同步阻塞</strong>，在服务器中实现的模式为<strong>一个<u>连接</u>一个线程</strong>。也就是说，<strong>客户端有连接请求的时候，服务器就需要启动一个线程进行处理</strong>，如果这个连接不做任何事情会造成不必要的线程开销。BIO一般适用于连接数目小且固定的架构，这种方式对于服务器资源要求比较高，而且并发局限于应用中，是JDK1.4之前的唯一选择，但好在程序直观简单，易理解。</p>
<p><strong>NIO</strong>：<strong>同步非阻塞</strong>，在服务器中实现的模式为<strong>一个<u>请求</u>一个线程</strong>，也就是说，客户端发送的连接请求都会注册到<strong>多路复用器</strong>上，<strong>多路复用器轮询到有连接IO请求时才会启动一个线程进行处理</strong>。NIO一般适用于连接数目多且连接比较短（轻操作）的架构，并发局限于应用中，编程比较复杂，从JDK1.4开始支持。</p>
<p><strong>AIO</strong>：<strong>异步非阻塞</strong>，在服务器中实现的模式为<strong>一个<u>有效请求</u>一个线程</strong>，也就是说，<strong>客户端的IO请求都是通过操作系统先完成之后，再通知服务器应用去启动线程进行处理</strong>。AIO一般适用于连接数目多且连接比较长（重操作）的架构，充分调用操作系统参与并发操作，编程比较复杂，从JDK1.7开始支持。</p>
<p><strong>应用场景：</strong></p>
<ul>
<li><p><strong>BIO</strong>适⽤于连接数⼩，对服务器资源要求⾼，因为线程要开很多。</p>
</li>
<li><p><strong>NIO</strong>适合于连接数多且数据连接⽐较短的架构，⽐如聊天服务器，弹幕系统等</p>
</li>
<li><p><strong>AIO</strong>适⽤于连接数多且连接⽐较长的架构。充分调⽤操作系统参与并发操作。</p>
</li>
</ul>
<h2 id="18-RPC"><a href="#18-RPC" class="headerlink" title="18.RPC"></a>18.RPC</h2><p>RPC（Remote Procedure Call）远程过程调用协议，一种通过网络从远程计算机上请求服务，而不需要了解底层网络技术的协议。RPC 是一种技术思想而非一种规范或协议。</p>
<h3 id="核心-RPC-框架的重要组成"><a href="#核心-RPC-框架的重要组成" class="headerlink" title="核心 RPC 框架的重要组成"></a>核心 RPC 框架的重要组成</h3><ul>
<li><strong>客户端（Client）：</strong>服务调用方。</li>
<li><strong>客户端存根（Client Stub）：</strong>存放服务端地址信息，将客户端的请求参数数据信息打包成网络消息，再通过网络传输发送给服务端。</li>
<li><strong>服务端存根（Server Stub）：</strong>接收客户端发送过来的请求消息并进行解包，然后再调用本地服务进行处理。</li>
<li><strong>服务端（Server）：</strong>服务的真正提供者。</li>
<li><strong>Network Service：</strong>底层传输，可以是 TCP 或 HTTP。</li>
</ul>
<p>RPC 的核心功能主要由 5 个模块组成，如果想要自己实现一个 RPC，最简单的方式要实现三个技术点，分别是：</p>
<ul>
<li><p><strong>服务寻址</strong></p>
<p>在本地调用中，函数体是直接通过函数指针来指定的，但是在远程调用中，函数指针是不行的，因为两个进程的地址空间是完全不一样的。</p>
<p>可以使用 Call ID 映射，每个函数拥有一个固定的ID，客户端和服务端分别维护一个Call ID和函数对应的表。</p>
<p><strong>实现方式：</strong>服务注册中心</p>
</li>
<li><p><strong>数据流的序列化和反序列化</strong></p>
<p>只有二进制数据才能在网络中传输，因此需要对数据进行序列化</p>
</li>
<li><p><strong>网络传输</strong></p>
<p>可以使用各种协议，只要完成传输过程就可以。</p>
</li>
</ul>
<h3 id="RPC和Http的区别"><a href="#RPC和Http的区别" class="headerlink" title="RPC和Http的区别"></a>RPC和Http的区别</h3><p>http是协议，rpc指的是远程调用，rpc可以用各种协议实现，可以使用http协议。</p>
<h3 id="为什么有了Rpc还要有Http"><a href="#为什么有了Rpc还要有Http" class="headerlink" title="为什么有了Rpc还要有Http"></a>为什么有了Rpc还要有Http</h3><p>RPC比HTTP出现的早，http最初应用于B&#x2F;S模式，rpc最初应用于C&#x2F;S模式，由于B与C的融合，S需要同时支持B和C，随着RESTFUL思潮的兴起，越来越多系统考虑用HTTP来提供服务，后端系统间调用如果能够采用和前端一样的技术栈，那无疑是维护成本最低的。因此逐渐使用了http</p>
<h2 id="19-重定向和请求转发有什么区别？"><a href="#19-重定向和请求转发有什么区别？" class="headerlink" title="19.重定向和请求转发有什么区别？"></a>19.重定向和请求转发有什么区别？</h2><p><strong>转发是服务器行为，重定向是客户端行为。</strong></p>
<h3 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a><strong>请求转发</strong></h3><p>​	客户首先发送一个请求到服务器端，服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器，整个流程都是在服务器端完成的，而且是在同一个请求里面完成的，客户端察觉不到这个动作，地址栏还是原来的地址。</p>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a><strong>重定向</strong></h3><p>​	是服务端根据逻辑，发送一个状态码，告诉浏览器重新去请求那个地址。所以地址栏显示的是新的URL。（服务器向浏览器发送一个302状态码以及一个location消息头，浏览器收到请求后会向再次根据重定向地址发出请求）</p>
<p><strong>二者区别</strong></p>
<p>（1）<strong>请求次数</strong>：重定向是浏览器向服务器发送一个请求并收到响应后再次向一个新地址发出请求，转发是服务器收到请求后完成响应；重定向至少请求两次，转发请求一次；</p>
<p>（2）<strong>地址栏不同</strong>：重定向地址栏会发生变化，转发地址栏不会发生变化；</p>
<p>（3）<strong>是否共享数据</strong>：重定向两次请求不共享数据，转发一次请求共享数据（在request级别使用信息共享，使用重定向必然出错）；</p>
<p>（4）<strong>跳转限制</strong>：重定向可以跳转到任意URL，转发只能跳转本站点资源；</p>
<p>（5）<strong>发生行为不同</strong>：重定向是客户端行为，转发是服务器端行为。</p>
<p>（6）<strong>效率：</strong>转发效率高，重定向效率低。</p>
<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p>消息队列是消息在传递过程中保存消息的容器。</p>
<h2 id="1-为什么要用消息队列"><a href="#1-为什么要用消息队列" class="headerlink" title="1.为什么要用消息队列"></a>1.为什么要用消息队列</h2><p>通常来说，使用消息队列能为我们的系统带来下面三点好处：</p>
<ol>
<li><p><strong>通过异步处理提高系统性能（减少响应所需时间）。</strong></p>
<p>将用户的请求数据存储到消息队列之后就立即返回结果。随后，系统再对消息进行消费。</p>
</li>
<li><p><strong>削峰&#x2F;限流</strong></p>
<p>先将短时间高并发产生的事务消息存储在消息队列中，然后后端服务再慢慢根据自己的能力去消费这些消息，这样就避免直接把后端服务打垮掉。</p>
</li>
<li><p><strong>降低系统耦合性。</strong></p>
<p>生产者（客户端）发送消息到消息队列中去，接受者（服务端）处理消息，需要消费的系统直接去消息队列取消息进行消费即可而不需要和其他系统有耦合，这显然也提高了系统的扩展性。</p>
</li>
</ol>
<h2 id="2-常见消息队列的对比"><a href="#2-常见消息队列的对比" class="headerlink" title="2.常见消息队列的对比"></a>2.常见消息队列的对比</h2><table>
<thead>
<tr>
<th align="center">对比方向</th>
<th align="center">概要</th>
</tr>
</thead>
<tbody><tr>
<td align="center">吞吐量</td>
<td align="center">万级的 ActiveMQ 和 RabbitMQ 的吞吐量（ActiveMQ 的性能最差）要比 十万级甚至是百万级的 RocketMQ 和 Kafka 低一个数量级。</td>
</tr>
<tr>
<td align="center">可用性</td>
<td align="center">都可以实现高可用。ActiveMQ 和 RabbitMQ 都是基于主从架构实现高可用性。RocketMQ 基于分布式架构。 kafka 也是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>
</tr>
<tr>
<td align="center">时效性</td>
<td align="center">RabbitMQ 基于 erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。其他三个都是 ms 级。</td>
</tr>
<tr>
<td align="center">功能支持</td>
<td align="center">除了 Kafka，其他三个功能都较为完备。 Kafka 功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准</td>
</tr>
<tr>
<td align="center">消息丢失</td>
<td align="center">ActiveMQ 和 RabbitMQ 丢失的可能性非常低， RocketMQ 和 Kafka 理论上不会丢失。</td>
</tr>
</tbody></table>
<p><strong>总结：</strong></p>
<ul>
<li>ActiveMQ 的社区算是比较成熟，但是较目前来说，ActiveMQ 的性能比较差，而且版本迭代很慢，不推荐使用。</li>
<li>RabbitMQ 在<strong>吞吐量</strong>方面虽然稍逊于 Kafka 和 RocketMQ ，但是由于它基于 erlang 开发，所以<strong>并发能力</strong>很强，性能极其好，延时很低，达到微秒级。但是也因为 RabbitMQ 基于 erlang 开发，所以国内很少有公司有实力做 erlang 源码级别的研究和定制。如果业务场景对并发量要求不是太高（十万级、百万级），那这四种消息队列中，RabbitMQ 一定是你的首选。如果是大数据领域的实时计算、<strong>日志采集等场景，用 Kafka 是业内标准的</strong>，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</li>
<li>RocketMQ 阿里出品，Java 系开源项目，源代码我们可以直接阅读，然后可以定制自己公司的 MQ，并且 RocketMQ 有阿里巴巴的实际业务场景的实战考验。RocketMQ 社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准 JMS 规范走的有些系统要迁移需要修改大量代码。还有就是阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险，那如果你们公司有技术实力我觉得用 RocketMQ 挺好的。</li>
<li>Kafka 的特点其实很明显，就是仅仅提供较少的核心功能，但是提供<strong>超高的吞吐量</strong>，ms 级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。同时 kafka 最好是支撑较少的 topic 数量即可，保证其超高吞吐量。<strong>kafka 唯一的一点劣势是有可能消息重复消费</strong>，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集。</li>
</ul>
<h2 id="3-Kafka"><a href="#3-Kafka" class="headerlink" title="3.Kafka"></a>3.Kafka</h2><p>Kafka 是一个分布式流式处理平台。</p>
<ol>
<li><strong>消息队列</strong>：发布和订阅消息流，这个功能类似于消息队列，这也是 Kafka 也被归类为消息队列的原因。</li>
<li><strong>容错的持久方式存储记录消息流</strong>： Kafka 会把消息持久化到磁盘，有效避免了消息丢失的风险。</li>
<li><strong>流式处理平台：</strong> 在消息发布的时候进行处理，Kafka 提供了一个完整的流式处理类库。</li>
</ol>
<p>Kafka 主要有两大应用场景：</p>
<ol>
<li><strong>消息队列</strong> ：建立实时流数据管道，以可靠地在系统或应用程序之间获取数据。</li>
<li><strong>数据处理：</strong> 构建实时的流数据处理程序来转换或处理数据流。</li>
</ol>
<h3 id="消息模型"><a href="#消息模型" class="headerlink" title="消息模型"></a>消息模型</h3><p><strong>Kafka采用的发布-订阅模型</strong></p>
<p>Kafka 将生产者发布的消息发送到 <strong>Topic（主题）</strong> 中，需要这些消息的消费者可以订阅这些 <strong>Topic（主题）</strong>，如下图所示：</p>
<p><img src="E:\学习笔记\图片\message-queue20210507200944439.png" alt="img"></p>
<p>上面这张图也为我们引出了，Kafka 比较重要的几个概念：</p>
<ol>
<li><strong>Producer（生产者）</strong> : 产生消息的一方。</li>
<li><strong>Consumer（消费者）</strong> : 消费消息的一方。</li>
<li><strong>Broker（代理）</strong> : 可以看作是一个独立的 Kafka 实例。多个 Kafka Broker 组成一个 Kafka Cluster。</li>
</ol>
<p>同时，你一定也注意到每个 Broker 中又包含了 Topic 以及 Partition 这两个重要的概念：</p>
<ul>
<li><strong>Topic（主题）</strong> : Producer 将消息发送到特定的主题，Consumer 通过订阅特定的 Topic(主题) 来消费消息。</li>
<li><strong>Partition（分区）</strong> : Partition 属于 Topic 的一部分。一个 Topic 可以有多个 Partition ，并且同一 Topic 下的 Partition 可以分布在不同的 Broker 上，这也就表明一个 Topic 可以横跨多个 Broker 。</li>
</ul>
<blockquote>
<p>划重点：<strong>Kafka 中的 Partition（分区） 实际上可以对应成为消息队列中的队列。</strong></p>
</blockquote>
<p> <strong>Kafka 只能为我们保证 Partition(分区) 中的消息有序。</strong></p>
<blockquote>
<p>消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。Kafka 通过偏移量（offset）来保证消息在分区内的顺序性。</p>
</blockquote>
<p>对于如何保证 Kafka 中消息消费的顺序，有了下面两种方法：</p>
<ol>
<li>1 个 Topic 只对应一个 Partition。</li>
<li>（推荐）发送消息的时候指定key&#x2F;Partition。</li>
</ol>
<h3 id="工作模式-1"><a href="#工作模式-1" class="headerlink" title="工作模式"></a>工作模式</h3><ul>
<li>点对点</li>
<li>发布订阅</li>
</ul>
<h3 id="Kafka如何保证消息不丢失"><a href="#Kafka如何保证消息不丢失" class="headerlink" title="Kafka如何保证消息不丢失"></a>Kafka如何保证消息不丢失</h3><h4 id="生产者丢失消息的情况"><a href="#生产者丢失消息的情况" class="headerlink" title="生产者丢失消息的情况"></a>生产者丢失消息的情况</h4><p>生产者(Producer) 调用<code>send</code>方法发送消息之后，消息可能因为网络问题并没有发送过去。</p>
<p>为发送添加一个回调函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ListenableFuture&lt;SendResult&lt;String, Object&gt;&gt; future = kafkaTemplate.send(topic, o);</span><br><span class="line">future.addCallback(result -&gt; logger.info(<span class="string">&quot;生产者成功发送消息到topic:&#123;&#125; partition:&#123;&#125;的消息&quot;</span>, result.getRecordMetadata().topic(), result.getRecordMetadata().partition()),</span><br><span class="line">                ex -&gt; logger.error(<span class="string">&quot;生产者发送消失败，原因：&#123;&#125;&quot;</span>, ex.getMessage()));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="消费者丢失消息"><a href="#消费者丢失消息" class="headerlink" title="消费者丢失消息"></a>消费者丢失消息</h4><p>当消费者拉取到了分区的某个消息之后，消费者会自动提交了 offset。自动提交的话会有一个问题，试想一下，当消费者刚拿到这个消息准备进行真正消费的时候，突然挂掉了，消息实际上并没有被消费，但是 offset 却被自动提交了。</p>
<p><strong>解决办法也比较粗暴，我们手动关闭自动提交 offset，每次在真正消费完消息之后再自己手动提交 offset 。</strong> 但是，细心的朋友一定会发现，这样会带来消息被重新消费的问题。比如你刚刚消费完消息之后，还没提交 offset，结果自己挂掉了，那么这个消息理论上就会被消费两次。</p>
<h4 id="Kafka弄丢了消息"><a href="#Kafka弄丢了消息" class="headerlink" title="Kafka弄丢了消息"></a>Kafka弄丢了消息</h4><p>Kafka 为分区（Partition）引入了多副本（Replica）机制。</p>
<p>假如 leader 副本所在的 broker 突然挂掉，那么就要从 follower 副本重新选出一个 leader ，但是 leader 的数据还有一些没有被 follower 副本的同步的话，就会造成消息丢失。</p>
<p><strong>解决办法：</strong></p>
<p><strong>设置 acks &#x3D; all</strong></p>
<p>解决办法就是我们设置 <strong>acks &#x3D; all</strong>。acks 是 Kafka 生产者(Producer) 很重要的一个参数。</p>
<p>acks 的默认值即为1，代表我们的消息被leader副本接收之后就算被成功发送。当我们配置 <strong>acks &#x3D; all</strong> 代表则所有副本都要接收到该消息之后该消息才算真正成功被发送。</p>
<p><strong>设置 replication.factor &gt;&#x3D; 3</strong></p>
<p>为了保证 leader 副本能有 follower 副本能同步消息，我们一般会为 topic 设置 <strong>replication.factor &gt;&#x3D; 3</strong>。这样就可以保证每个 分区(partition) 至少有 3 个副本。虽然造成了数据冗余，但是带来了数据的安全性。</p>
<p><strong>设置 min.insync.replicas &gt; 1</strong></p>
<p>一般情况下我们还需要设置 <strong>min.insync.replicas&gt; 1</strong> ，这样配置代表消息至少要被写入到 2 个副本才算是被成功发送。<strong>min.insync.replicas</strong> 的默认值为 1 ，在实际生产中应尽量避免默认值 1。</p>
<p>但是，为了保证整个 Kafka 服务的高可用性，你需要确保 <strong>replication.factor &gt; min.insync.replicas</strong> 。为什么呢？设想一下假如两者相等的话，只要是有一个副本挂掉，整个分区就无法正常工作了。这明显违反高可用性！一般推荐设置成 <strong>replication.factor &#x3D; min.insync.replicas + 1</strong>。</p>
<p><strong>设置 unclean.leader.election.enable &#x3D; false</strong></p>
<h3 id="Kafka-如何保证消息不重复消费"><a href="#Kafka-如何保证消息不重复消费" class="headerlink" title="Kafka 如何保证消息不重复消费"></a>Kafka 如何保证消息不重复消费</h3><p><strong>kafka出现消息重复消费的原因：</strong></p>
<ul>
<li>服务端侧已经消费的数据没有成功提交 offset（根本原因）。</li>
<li>Kafka 侧 由于服务端处理业务时间长或者网络链接等等原因让 Kafka 认为服务假死，触发了分区 rebalance。</li>
</ul>
<p><strong>解决方案：</strong></p>
<ul>
<li><p>消费消息服务做幂等校验，比如 Redis 的set、MySQL 的主键等天然的幂等功能。这种方法最有效。</p>
</li>
<li><p>将<code>enable.auto.commit</code>参数设置为 false，关闭自动提交，开发者在代码中手动提交 offset。那么这里会有个问题：</p>
<p>什么时候提交offset合适？</p>
<ul>
<li>处理完消息再提交：依旧有消息重复消费的风险，和自动提交一样</li>
<li>拉取到消息即提交：会有消息丢失的风险。允许消息延时的场景，一般会采用这种方式。然后，通过定时任务在业务不繁忙（比如凌晨）的时候做数据兜底。</li>
</ul>
</li>
</ul>
<h3 id="kafka保证数据的顺序性"><a href="#kafka保证数据的顺序性" class="headerlink" title="kafka保证数据的顺序性"></a>kafka保证数据的顺序性</h3><p>​	kafka 写入partion时指定一个key，列如订单id，那么这个订单的相关数据都会被分发到同一个partion中，并且在partion中是有序的（producer发消息到队列时，通过加锁保证有序）。消费者从partion中取出数据的时候肯定是有序的，但是当开启多个线程的时候可能导致数据不一致。</p>
<p>在消费者端创建多个内存队列queue，具有相同 key 的数据都路由到同一个内存队列；然后每个线程分别消费一个内存队列即可，这样就能保证顺序性。</p>
<p><strong>kafka：</strong>一个topic，一个partition，一个consumer，内部单线程消费，写N个内存queue，然后N个线程分别消费一个内存queue即可</p>
<p><img src="E:\学习笔记\图片\169bde8fd967ab1b_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.awebp" alt="img"></p>
<p><img src="E:\学习笔记\图片\169bde8fd989e5a5_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.awebp" alt="img"></p>
<h2 id="4-RabbitMQ"><a href="#4-RabbitMQ" class="headerlink" title="4.RabbitMQ"></a>4.RabbitMQ</h2><p>RabbitMQ 是采用 Erlang 语言实现 AMQP(Advanced Message Queuing Protocol，高级消息队列协议）的消息中间件</p>
<p>RabbitMQ 的具体特点可以概括为以下几点：</p>
<ul>
<li><strong>可靠性：</strong> RabbitMQ使用一些机制来保证消息的可靠性，如持久化、传输确认及发布确认等。</li>
<li><strong>灵活的路由：</strong> 在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能，RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个交换器绑定在一起，也可以通过插件机制来实现自己的交换器。这个后面会在我们讲 RabbitMQ 核心概念的时候详细介绍到。</li>
<li><strong>扩展性：</strong> 多个RabbitMQ节点可以组成一个集群，也可以根据实际业务情况动态地扩展集群中节点。</li>
<li><strong>高可用性：</strong> 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队列仍然可用。</li>
<li><strong>支持多种协议：</strong> RabbitMQ 除了原生支持 AMQP 协议，还支持 STOMP、MQTT 等多种消息中间件协议。</li>
<li><strong>多语言客户端：</strong> RabbitMQ几乎支持所有常用语言，比如 Java、Python、Ruby、PHP、C#、JavaScript等。</li>
<li><strong>易用的管理界面：</strong> RabbitMQ提供了一个易用的用户界面，使得用户可以监控和管理消息、集群中的节点等。在安装 RabbitMQ 的时候会介绍到，安装好 RabbitMQ 就自带管理界面。</li>
<li><strong>插件机制：</strong> RabbitMQ 提供了许多插件，以实现从多方面进行扩展，当然也可以编写自己的插件。感觉这个有点类似 Dubbo 的 SPI机制。</li>
</ul>
<h3 id="模型架构"><a href="#模型架构" class="headerlink" title="模型架构"></a>模型架构</h3><p><img src="E:\学习笔记\图片\96388546.jpg" alt="图1-RabbitMQ 的整体模型架构"></p>
<ul>
<li><p><strong>Producer(生产者)</strong> :生产消息的一方（邮件投递者）</p>
</li>
<li><p><strong>Consumer(消费者)</strong> :消费消息的一方（邮件收件人）</p>
</li>
<li><p><strong>Exchange（交换器）</strong>：用来接收生产者发送的消息并将这些消息路由给服务器中的队列中。</p>
<p>在 RabbitMQ 中，消息并不是直接被投递到 <strong>Queue(消息队列)</strong> 中的，中间还必须经过 <strong>Exchange(交换器)</strong> 这一层，<strong>Exchange(交换器)</strong> 会把我们的消息分配到对应的 <strong>Queue(消息队列)</strong> 中。</p>
</li>
</ul>
<p>RabbitMQ 中通过 <strong>Binding(绑定)</strong> 将 <strong>Exchange(交换器)</strong> 与 <strong>Queue(消息队列)</strong> 关联起来，在绑定的时候一般会指定一个 <strong>BindingKey(绑定建)</strong> ,这样 RabbitMQ 就知道如何正确将消息路由到队列了</p>
<h3 id="工作模式（五种）"><a href="#工作模式（五种）" class="headerlink" title="工作模式（五种）"></a>工作模式（五种）</h3><ul>
<li><h5 id="simple简单模式"><a href="#simple简单模式" class="headerlink" title="simple简单模式"></a>simple简单模式</h5><p><img src="E:\学习笔记\图片\20181221114009759.png" alt="在这里插入图片描述"></p>
</li>
<li><h5 id="work工作模式-资源的竞争"><a href="#work工作模式-资源的竞争" class="headerlink" title="work工作模式(资源的竞争)"></a>work工作模式(资源的竞争)</h5><p><img src="E:\学习笔记\图片\20181221114036231.png" alt="在这里插入图片描述"></p>
</li>
<li><h5 id="publish-x2F-subscribe发布订阅-共享资源"><a href="#publish-x2F-subscribe发布订阅-共享资源" class="headerlink" title="publish&#x2F;subscribe发布订阅(共享资源)"></a>publish&#x2F;subscribe发布订阅(共享资源)</h5><p><img src="E:\学习笔记\图片\20181221114050657.png" alt="在这里插入图片描述"></p>
</li>
<li><h5 id="routing路由模式"><a href="#routing路由模式" class="headerlink" title="routing路由模式"></a>routing路由模式</h5><p><img src="E:\学习笔记\图片\20181221114420299.png" alt="在这里插入图片描述"></p>
</li>
<li><h5 id="topic-主题模式-路由模式的一种-特点是可以模糊匹配"><a href="#topic-主题模式-路由模式的一种-特点是可以模糊匹配" class="headerlink" title="topic 主题模式(路由模式的一种,特点是可以模糊匹配)"></a>topic 主题模式(路由模式的一种,特点是可以模糊匹配)</h5><p><img src="E:\学习笔记\图片\20181221114208408.png" alt="在这里插入图片描述"></p>
</li>
</ul>
<h3 id="Queue-消息队列"><a href="#Queue-消息队列" class="headerlink" title="Queue(消息队列)"></a>Queue(消息队列)</h3><p><strong>Queue(消息队列)</strong> 用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</p>
<p><strong>RabbitMQ</strong> 中消息只能存储在 <strong>队列</strong> 中，这一点和 <strong>Kafka</strong> 这种消息中间件相反。</p>
<p><strong>多个消费者可以订阅同一个队列</strong>，这时队列中的消息会被平均分摊（Round-Robin，即轮询）给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理，这样避免消息被重复消费。</p>
<p>RabbitMQ<strong>不支持队列层面的广播消费</strong></p>
<h4 id="Broker（消息中间件的服务节点）"><a href="#Broker（消息中间件的服务节点）" class="headerlink" title="Broker（消息中间件的服务节点）"></a>Broker（消息中间件的服务节点）</h4><p>对于 RabbitMQ 来说，一个 RabbitMQ Broker 可以简单地看作一个 RabbitMQ 服务节点，或者RabbitMQ服务实例。大多数情况下也可以将一个 RabbitMQ Broker 看作一台 RabbitMQ 服务器。</p>
<p>下图展示了生产者将消息存入 RabbitMQ Broker,以及消费者从Broker中消费数据的整个流程。</p>
<p><img src="E:\学习笔记\图片\67952922.jpg" alt="消息队列的运转过程"></p>
<h4 id="Exchange-Types-交换器类型"><a href="#Exchange-Types-交换器类型" class="headerlink" title="Exchange Types(交换器类型)"></a>Exchange Types(交换器类型)</h4><p>RabbitMQ 常用的 Exchange Type 有 <strong>fanout</strong>、<strong>direct</strong>、<strong>topic</strong>、<strong>headers</strong> 这四种（AMQP规范里还提到两种 Exchange Type，分别为 system 与 自定义，这里不予以描述）。</p>
<h5 id="①-fanout"><a href="#①-fanout" class="headerlink" title="① fanout"></a>① fanout</h5><p>fanout 类型的Exchange路由规则非常简单，它会把发送到该Exchange的消息路由到<strong>所有</strong>与它绑定的Queue中(每个队列都收到)，不需要做任何判断操作，所以 fanout 类型是所有的交换机类型里面速度最快的。fanout 类型常用来<strong>广播</strong>消息。</p>
<h5 id="②-direct"><a href="#②-direct" class="headerlink" title="② direct"></a>② direct</h5><p>direct 类型的Exchange路由规则也很简单，它会把消息路由到那些 Bindingkey 与 RoutingKey 完全匹配的 Queue 中。</p>
<p><img src="E:\学习笔记\图片\37008021.jpg" alt="direct 类型交换器"></p>
<p>以上图为例，如果发送消息的时候设置路由键为“warning”,那么消息会路由到 Queue1 和 Queue2。如果在发送消息的时候设置路由键为”Info”或者”debug”，消息只会路由到Queue2。如果以其他的路由键发送消息，则消息不会路由到这两个队列中。</p>
<p>direct 类型常用在处理有优先级的任务，根据任务的优先级把消息发送到对应的队列，这样可以指派更多的资源去处理高优先级的队列。</p>
<h5 id="③-topic"><a href="#③-topic" class="headerlink" title="③ topic"></a>③ topic</h5><p>前面讲到direct类型的交换器路由规则是完全匹配 BindingKey 和 RoutingKey ，但是这种严格的匹配方式在很多情况下不能满足实际业务的需求。topic类型的交换器在匹配规则上进行了扩展，它与 direct 类型的交换器相似，也是将消息路由到 BindingKey 和 RoutingKey 相匹配的队列中，但这里的匹配规则有些不同，它约定：</p>
<ul>
<li>RoutingKey 为一个点号“．”分隔的字符串（被点号“．”分隔开的每一段独立的字符串称为一个单词），如 “com.rabbitmq.client”、“java.util.concurrent”、“com.hidden.client”;</li>
<li>BindingKey 和 RoutingKey 一样也是点号“．”分隔的字符串；</li>
<li>BindingKey 中可以存在两种特殊字符串“ *”和“#”，用于做模糊匹配，其中“ * ”用于匹配一个单词，“#”用于匹配多个单词(可以是零个)。</li>
</ul>
<p><img src="E:\学习笔记\图片\73843.jpg" alt="topic 类型交换器"></p>
<p>以上图为例：</p>
<ul>
<li>路由键为 “com.rabbitmq.client” 的消息会同时路由到 Queue1 和 Queue2;</li>
<li>路由键为 “com.hidden.client” 的消息只会路由到 Queue2 中；</li>
<li>路由键为 “com.hidden.demo” 的消息只会路由到 Queue2 中；</li>
<li>路由键为 “java.rabbitmq.demo” 的消息只会路由到 Queue1 中；</li>
<li>路由键为 “java.util.concurrent” 的消息将会被丢弃或者返回给生产者（需要设置 mandatory 参数），因为它没有匹配任何路由键。</li>
</ul>
<h5 id="④-headers-不推荐"><a href="#④-headers-不推荐" class="headerlink" title="④ headers(不推荐)"></a>④ headers(不推荐)</h5><p>headers 类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的 headers 属性进行匹配。在绑定队列和交换器时指定一组键值对，当发送消息到交换器时，RabbitMQ会获取到该消息的 headers（也是一个键值对的形式)，对比其中的键值对是否完全匹配队列和交换器绑定时指定的键值对，如果完全匹配则消息会路由到该队列，否则不会路由到该队列。headers 类型的交换器性能会很差，而且也不实用，基本上不会看到它的存在。</p>
<h3 id="处理消息失败了怎么办？"><a href="#处理消息失败了怎么办？" class="headerlink" title="处理消息失败了怎么办？"></a>处理消息失败了怎么办？</h3><p>一般会设计两个队列：</p>
<ul>
<li>核心业务队列：正常处理消息的。</li>
<li>死信队列：用来处理异常情况的。</li>
</ul>
<p>比如说消费者的系统故障了，导致消息发往消费者时失败，如果消息处理失败，MQ就会把这条消息转入死信队列中。一旦发现消费者系统恢复正常，队列就先处理私信队列中的数据。</p>
<h3 id="如何保证顺序消费"><a href="#如何保证顺序消费" class="headerlink" title="如何保证顺序消费"></a>如何保证顺序消费</h3><ul>
<li>RabbitMQ：出现顺序错乱的原因通常是消费者集群部署，不同消费者消费到了同一订单的不同的消息。解决办法：可以创建多个queue，每个消费者固定消费一个queue的消息，生产者发送消息的时候，同一订单号的消费发送到同一个queue中。</li>
</ul>
<h3 id="保证消息不丢失"><a href="#保证消息不丢失" class="headerlink" title="保证消息不丢失"></a>保证消息不丢失</h3><ul>
<li><p>RabbitMQ</p>
<ul>
<li><p>1）生产者丢数据：<del><strong>方法一</strong>：选择使用RabbitMQ提供的事务功能，就是生产者在发送数据之前开启事务，然后发送消息，如果消息发送失败，就回滚事务。缺点是会阻塞。</del><strong>方法二</strong>：<strong>开启确认模式</strong>，队列收到之后，回传一个ack消息，如果消费者超时没收到ack，就重发。</p>
<ul>
<li>Client发送消息给MQ</li>
<li>MQ将消息持久化后，发送Ack消息给Client，此处有可能因为网络问题导致Ack消息无法发送到Client，那么Client在等待超时后，会重传消息；</li>
</ul>
<ol start="3">
<li>Client收到Ack消息后，认为消息已经投递成功。</li>
</ol>
</li>
<li><p>2）队列丢消息：设置消息持久化到磁盘。创建队列的时候将队列设置为持久化的。可以和确认机制配合使用，只有当消息持久化到磁盘之后，才会通知生产者。</p>
</li>
<li><p>3）消费者端丢消息：也使用<strong>ack机制</strong>，当消费者处理完这个消息之后，再回传ack，消费者再删除消息。</p>
<ul>
<li>MQ将消息push给Client（或Client来pull消息）</li>
</ul>
<ol start="2">
<li>Client得到消息并做完业务逻辑</li>
</ol>
<ul>
<li>Client发送Ack消息给MQ，通知MQ删除该消息，此处有可能因为网络问题导致Ack失败，那么Client会重复消息，这里就引出消费幂等（<strong>给消费者发送多条同样的消息，消费者只会消费其中的一条</strong>）的问题；</li>
</ul>
<ol start="4">
<li>MQ将已消费的消息删除。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="MQ积压几百万条数据怎么办？"><a href="#MQ积压几百万条数据怎么办？" class="headerlink" title="MQ积压几百万条数据怎么办？"></a>MQ积压几百万条数据怎么办？</h2><p>假如是kafka，则采用临时紧急扩容，具体操作步骤和思路如下：</p>
<ol>
<li>先修复consumer的问题，确保其恢复消费速度，然后将现有cnosumer都停掉</li>
<li>新建一个topic，partition是原来的10倍，临时建立好原先10倍或者20倍的queue数量</li>
<li>然后写一个临时的分发数据的consumer程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的10倍数量的queue</li>
<li>接着临时征用10倍的机器来部署consumer，每一批consumer消费一个临时queue的数据</li>
<li>这种做法相当于是临时将queue资源和consumer资源扩大10倍，以正常的10倍速度来消费数据</li>
<li>等快速消费完积压数据之后，得恢复原先部署架构，重新用原先的consumer机器来消费消息</li>
</ol>
<p>假如是RabbitMQ，RabbitMQ是可以设置过期时间的，就是TTL，如果消息在queue中积压超过一定的时间就会被rabbitmq给清理掉，大量的数据会直接搞丢。</p>
<p>采用批量重导。就是大量积压的时候，直接丢弃数据，等过了高峰期以后，就开始写程序，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入mq里面去，把丢的数据补回来。</p>
<p>假设1万个订单积压在mq里面，没有处理，其中1000个订单都丢了，你只能手动写程序把那1000个订单给查出来，手动发到mq里去再补一次</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="1-手写单例模式"><a href="#1-手写单例模式" class="headerlink" title="1. 手写单例模式"></a>1. 手写单例模式</h2><h3 id="1-饿汉式——静态常量方式（线程安全）"><a href="#1-饿汉式——静态常量方式（线程安全）" class="headerlink" title="1. 饿汉式——静态常量方式（线程安全）"></a>1. 饿汉式——静态常量方式（线程安全）</h3><ul>
<li>类加载时就初始化实例，避免了多线程同步问题。天然线程安全。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>(); <span class="comment">// 静态对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;  <span class="comment">// 私有构造方法保证没办法创建其他对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123; <span class="comment">// 返回唯一的对象</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-饿汉式——静态代码块（线程安全）"><a href="#2-饿汉式——静态代码块（线程安全）" class="headerlink" title="2. 饿汉式——静态代码块（线程安全）"></a>2. 饿汉式——静态代码块（线程安全）</h3><p>其实就是在上面 静态常量饿汉式 实现上稍微变动了一下，将<strong>类的实例化放在了静态代码块中</strong>而已。其他没区别。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">				instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">		<span class="keyword">public</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">				<span class="keyword">return</span> instance;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-懒汉式——线程不安全"><a href="#3-懒汉式——线程不安全" class="headerlink" title="3. 懒汉式——线程不安全"></a>3. 懒汉式——线程不安全</h3><p>这是最基本的实现方式，第一次调用才初始化，实现了<strong>懒加载</strong>的特性。多线程场景下禁止使用，因为可能会产生多个对象，不再是单例。</p>
<ul>
<li>多线程场景下禁止使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;  </span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-懒汉式——线程安全，方法上加同步锁"><a href="#4-懒汉式——线程安全，方法上加同步锁" class="headerlink" title="4. 懒汉式——线程安全，方法上加同步锁"></a>4. 懒汉式——线程安全，方法上加同步锁</h3><p>和上面 懒汉式（线程不安全）实现上唯一不同是：获取实例的getInstance()方法上加了同步锁。保证了多线程场景下的单例。但是效率会有所折损，不过还好。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123; <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-双重校验锁——线程安全、效率高"><a href="#5-双重校验锁——线程安全、效率高" class="headerlink" title="5. 双重校验锁——线程安全、效率高"></a>5. 双重校验锁——线程安全、效率高</h3><p>此种实现中不用每次需要获得锁，减少了获取锁和等待的事件。</p>
<p>注意volatile关键字的使用，保证了各线程对singleton静态实例域修改的可见性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-静态内部类实现单例——线程安全、效率高"><a href="#6-静态内部类实现单例——线程安全、效率高" class="headerlink" title="6. 静态内部类实现单例——线程安全、效率高"></a>6. 静态内部类实现单例——线程安全、效率高</h3><p>这种方式下 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。</p>
<p>注意内部类SingletonHolder要用static修饰且其中的静态变量INSTANCE必须是final的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123; <span class="comment">// 内部类</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123; <span class="comment">// final</span></span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-设计模式的六大原则-总原则（七个）"><a href="#2-设计模式的六大原则-总原则（七个）" class="headerlink" title="2. 设计模式的六大原则+总原则（七个）"></a>2. 设计模式的六大原则+总原则（七个）</h2><p>设计模式是对面向对象的原则的具体实现</p>
<p> <strong>总原则——开闭原则</strong></p>
<blockquote>
<p>一个软件实体，如类、模块和函数应该<strong>对扩展开放，对修改关闭</strong>。</p>
</blockquote>
<p>在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。</p>
<p><strong>1）单一职责原则（Single Responsibility Principle）</strong></p>
<blockquote>
<p>一个类应该只有一个发生变化的原因。</p>
</blockquote>
<p>不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，否则就应该把类拆分。</p>
<p><strong>2）里氏替换原则（Liskov Substitution Principle）</strong></p>
<blockquote>
<p>所有引用基类的地方必须能透明地使用其子类的对象。</p>
</blockquote>
<p><strong>任何基类可以出现的地方，子类一定可以出现。</strong>里氏替换原则是继承复用的基石，只有当衍生类可以替换基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。</p>
<p>里氏代换原则是对“开-闭”原则的补充。实现“开闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏替换原则是对实现抽象化的具体步骤的规范。里氏替换原则中，<strong>子类对父类的方法尽量不要重写和重载</strong>。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。</p>
<p><strong>3）依赖倒置原则（Dependence Inversion Principle）</strong></p>
<blockquote>
<p>1、上层模块不应该依赖底层模块，它们都应该依赖于抽象。<br>2、抽象不应该依赖于细节，细节应该依赖于抽象。</p>
</blockquote>
<p>面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。</p>
<p><strong>4）接口隔离原则（Interface Segregation Principle）</strong></p>
<blockquote>
<p>1、客户端不应该依赖它不需要的接口。<br>2、类间的依赖关系应该建立在最小的接口上。</p>
</blockquote>
<p>每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。</p>
<p><strong>5）迪米特法则（最少知道原则）(Law of Demeter)</strong></p>
<blockquote>
<p>只与你的直接朋友交谈，不跟“陌生人”说话。</p>
</blockquote>
<p>一个类对自己依赖的类知道的越少越好。无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。</p>
<p>最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。</p>
<p><strong>6）合成复用原则（Composite Reuse Principle）</strong></p>
<blockquote>
<p>尽量使用对象组合&#x2F;聚合，而不是继承关系达到软件复用的目的。</p>
</blockquote>
<p>合成或聚合可以将已有对象纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能。</p>
<h2 id="3-设计模式的三大类"><a href="#3-设计模式的三大类" class="headerlink" title="3. 设计模式的三大类"></a>3. 设计模式的三大类</h2><p><strong>创建型模式（Creational Pattern）：</strong>对类的实例化过程进行了抽象，能够将软件模块中<strong>对象的创建</strong>和对象的<strong>使用</strong>分离。</p>
<p>（5种）工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式</p>
<p><strong>结构型模式（Structural Pattern）</strong>：关注于对象的组成以及对象之间的依赖关系，描述如何将类或者对象结合在一起形成更大的结构，就像<strong>搭积木</strong>，可以通过简单积木的组合形成复杂的、功能更为强大的结构。</p>
<p>（7种）适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式</p>
<p><strong>行为型模式（Behavioral Pattern）</strong>：关注于对象的行为问题，是对在不同的对象之间划分责任和算法的抽象化；不仅仅关注类和对象的结构，而且重点关注它们之间的<strong>相互作用</strong>。</p>
<p>（11种）策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式</p>
<h2 id="4-简述23种设计模式"><a href="#4-简述23种设计模式" class="headerlink" title="4. 简述23种设计模式"></a>4. 简述23种设计模式</h2><h3 id="1-创建型模式"><a href="#1-创建型模式" class="headerlink" title="1. 创建型模式"></a>1. 创建型模式</h3><h4 id="1）工厂模式"><a href="#1）工厂模式" class="headerlink" title="1）工厂模式"></a>1）工厂模式</h4><p>在工厂模式中，我们在创建对象时<strong>不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</strong></p>
<p>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p>
<blockquote>
<p>应用实例：您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。而至于需要哪个牌子的汽车，就到哪个牌子的工厂。</p>
</blockquote>
<h4 id="2）抽象工厂模式"><a href="#2）抽象工厂模式" class="headerlink" title="2）抽象工厂模式"></a>2）抽象工厂模式</h4><p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。</p>
<p>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p>
<p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
<blockquote>
<p>应用实例：对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，都是成套的，即一系列具体产品。假设一种情况，在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OO 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。</p>
</blockquote>
<h4 id="3）单例模式"><a href="#3）单例模式" class="headerlink" title="3）单例模式"></a>3）单例模式</h4><p>单例模式（Singleton Pattern）是Java中最简单的设计模式之一。</p>
<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<blockquote>
<p>应用实例：一个班级只能有一个班主任。</p>
</blockquote>
<h4 id="4）建造者模式（构建者模式）"><a href="#4）建造者模式（构建者模式）" class="headerlink" title="4）建造者模式（构建者模式）"></a>4）建造者模式（构建者模式）</h4><p>建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。</p>
<p>一个Builder类会一步一步构造最终的对象。该Builder类是独立于其他对象的。相当于是把各个部件（对象）组合在一起生成一个对象。</p>
<p>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p>
<blockquote>
<p>应用实例：<br>1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的“套餐”；<br>2、Java 中的 StringBuilder。需要往这个对象中加多少内容，自己说了算。</p>
</blockquote>
<h4 id="5）原型模式"><a href="#5）原型模式" class="headerlink" title="5）原型模式"></a>5）原型模式</h4><p>原型模式（Prototype Pattern）是<strong>用于创建重复的对象</strong>，同时又能保证性能。</p>
<p>这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，<strong>一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆</strong>，在需要的时候更新数据库，以此来减少数据库调用。</p>
<p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
<blockquote>
<p>应用实例：<br>1、细胞分裂；<br>2、Java中的 Object clone() 方法。</p>
</blockquote>
<h3 id="2-结构型模式"><a href="#2-结构型模式" class="headerlink" title="2. 结构型模式"></a>2. 结构型模式</h3><h4 id="1）适配器模式"><a href="#1）适配器模式" class="headerlink" title="1）适配器模式"></a>1）适配器模式</h4><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。</p>
<p>这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。</p>
<p>将一个类的接口转换成客户希望的另外一个接口。<strong>适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</strong></p>
<blockquote>
<p>应用实例：<br>1、读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡；<br>2、美国电器110V，中国220V，就要有一个变压器将110V转化为220V。</p>
</blockquote>
<h4 id="2）装饰器模式"><a href="#2）装饰器模式" class="headerlink" title="2）装饰器模式"></a>2）装饰器模式</h4><p><strong>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。</strong></p>
<p>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</p>
<p>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p>
<blockquote>
<p>应用实例：<br>1、孙悟空有72变，当他变成”庙宇”后，他的根本还是一只猴子，但是他又有了庙宇的功能；<br>2、将一个形状装饰上不同的颜色，同时又不改变形状。</p>
</blockquote>
<h4 id="3）代理模式"><a href="#3）代理模式" class="headerlink" title="3）代理模式"></a>3）代理模式</h4><p>在<strong>代理模式（Proxy Pattern）中，一个类代表另一个类的功能</strong>。</p>
<p>在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。</p>
<p>为其他对象提供一种代理以控制对这个对象的访问。</p>
<blockquote>
<p>应用实例：<br>1、Windows里面的快捷方式；<br>2、买火车票不一定在火车站买，也可以去代售点；<br>3、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制；<br>4、Spring AOP。</p>
</blockquote>
<p>注意事项：</p>
<p>1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。</p>
<p>2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</p>
<h4 id="4）外观模式"><a href="#4）外观模式" class="headerlink" title="4）外观模式"></a>4）外观模式</h4><p>外观模式（Facade Pattern）<strong>隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口</strong>。</p>
<p>这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。</p>
<p><strong>为子系统中的一组接口提供一个一致的界面</strong>，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>
<blockquote>
<p>应用实例：<br>去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。</p>
</blockquote>
<h4 id="5）桥接模式-20条消息-桥接模式（Bridge-Pattern）-（最通俗易懂的案例）-你上来晒太阳的的博客-CSDN博客-桥接模式"><a href="#5）桥接模式-20条消息-桥接模式（Bridge-Pattern）-（最通俗易懂的案例）-你上来晒太阳的的博客-CSDN博客-桥接模式" class="headerlink" title="5）桥接模式(20条消息) 桥接模式（Bridge Pattern）-（最通俗易懂的案例）_你上来晒太阳的的博客-CSDN博客_桥接模式"></a>5）桥接模式<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39296283/article/details/104953668">(20条消息) 桥接模式（Bridge Pattern）-（最通俗易懂的案例）_你上来晒太阳的的博客-CSDN博客_桥接模式</a></h4><p>桥接模式（Bridge Pattern）是<strong>用于把抽象化与实现化解耦</strong>，使得二者可以独立变化。它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。</p>
<p>这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。</p>
<p><strong>将抽象部分与实现部分分离</strong>，使它们都可以独立的变化。</p>
<p>又称为柄体（Handle and Body）模式或接口（Interface）模式。</p>
<blockquote>
<p>应用实例：<br>1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择；<br>2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的；<br>3、如果要绘制不同的颜色，如红色、绿色、蓝色的矩形、圆形、椭圆、正方形，我们需要根据实际需要对形状和颜色进行组合，那么颜色、形状就是抽象部分，组合后的就是实现部分。</p>
</blockquote>
<p>注意事项：对于两个独立变化的维度，使用桥接模式再适合不过了。</p>
<h4 id="6）组合模式"><a href="#6）组合模式" class="headerlink" title="6）组合模式"></a>6）组合模式</h4><p>组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了<strong>对象组的树形结构</strong>。</p>
<p>这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。</p>
<p>将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<blockquote>
<p>应用实例：<br>1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作数也可以是操作数、操作符和另一个操作数。<br>2、在JAVAAWT和SWING中，对于Button和Checkbox是树叶，Container是树枝。</p>
</blockquote>
<h4 id="7）享元模式"><a href="#7）享元模式" class="headerlink" title="7）享元模式"></a>7）享元模式</h4><p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。</p>
<p>享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。</p>
<p>运用共享技术有效地支持大量细粒度的对象。</p>
<blockquote>
<p>应用实例：<br>1、Java中的String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面；<br>2、数据库的数据池。</p>
</blockquote>
<h3 id="3-行为型模式"><a href="#3-行为型模式" class="headerlink" title="3.行为型模式"></a>3.行为型模式</h3><h4 id="1）策略模式"><a href="#1）策略模式" class="headerlink" title="1）策略模式"></a>1）策略模式</h4><p><strong>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。</strong></p>
<p>在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的context对象。策略对象改变context对象的执行算法。</p>
<p>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。</p>
<blockquote>
<p>应用实例：<br>1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略；<br>2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。</p>
</blockquote>
<h4 id="2）模板模式"><a href="#2）模板模式" class="headerlink" title="2）模板模式"></a>2）模板模式</h4><p>在模板模式（Template Pattern）中，<strong>一个抽象类公开定义了执行它的方法的方式&#x2F;模板。</strong>它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。</p>
<p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<blockquote>
<p>应用实例：<br>1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异；<br>2、西游记里面菩萨定好的81难，这就是一个顶层的逻辑骨架；<br>3、spring中对Hibernate的支持，将一些已经定好的方法封装起来，比如开启事务、获取Session、关闭Session等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。</p>
</blockquote>
<h4 id="3）观察者模式"><a href="#3）观察者模式" class="headerlink" title="3）观察者模式"></a>3）观察者模式</h4><p>当对象间存在一对多关系时，则使用观察者模式（ObserverPattern）。比如，<strong>当一个对象被修改时，则会自动通知它的依赖对象。</strong></p>
<p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
<blockquote>
<p>应用实例：<br>1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价；<br>2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。</p>
</blockquote>
<h4 id="4）迭代器模式"><a href="#4）迭代器模式" class="headerlink" title="4）迭代器模式"></a>4）迭代器模式</h4><p>迭代器模式（Iterator Pattern）是Java和.Net编程环境中非常常用的设计模式。这种模式用于<strong>顺序访问集合对象的元素，不需要知道集合对象的底层表示。</strong></p>
<p>迭代器模式属于行为型模式。</p>
<p>提供一种方法顺序访问一个聚合对象中各个元素，而又无须暴露该对象的内部表示。</p>
<blockquote>
<p>应用实例：JAVA中的iterator。</p>
</blockquote>
<h4 id="5）责任链模式"><a href="#5）责任链模式" class="headerlink" title="5）责任链模式"></a>5）责任链模式</h4><p>顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。</p>
<p>在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。</p>
<p><strong>避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</strong></p>
<blockquote>
<p>应用实例：红楼梦中的”击鼓传花”。</p>
</blockquote>
<h4 id="6）命令模式"><a href="#6）命令模式" class="headerlink" title="6）命令模式"></a>6）命令模式</h4><p>命令模式（Command Pattern）是一种数据驱动的设计模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。</p>
<p>将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。</p>
<blockquote>
<p>应用实例：电视机是请求的接收者，遥控器是请求的发送者，遥控器上有一些按钮，不同的按钮对应电视机的不同操作。抽象命令角色由一个命令接口来扮演，有三个具体的命令类实现了抽象命令接口，这三个具体命令类分别代表三种操作：打开电视机、关闭电视机和切换频道。</p>
</blockquote>
<h4 id="7）备忘录模式"><a href="#7）备忘录模式" class="headerlink" title="7）备忘录模式"></a>7）备忘录模式</h4><p>备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。</p>
<p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p>
<blockquote>
<p>应用实例：<br>1、后悔药；<br>2、打游戏时的存档；<br>3、Windows里的ctri+z；<br>4、IE中的后退；<br>5、数据库的事务管理。</p>
</blockquote>
<h4 id="8）状态模式"><a href="#8）状态模式" class="headerlink" title="8）状态模式"></a>8）状态模式</h4><p>在状态模式（State Pattern）中，<strong>类的行为是基于它的状态改变的。</strong></p>
<p>在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的context对象。</p>
<p>允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。</p>
<blockquote>
<p>应用实例：<br>1、打篮球的时候运动员可以有正常状态、不正常状态和超常状态；<br>2、曾侯乙编钟中，’钟是抽象接口’，’钟A’等是具体状态，’曾侯乙编钟’是具体环境（Context）。</p>
</blockquote>
<h4 id="9）访问者模式"><a href="#9）访问者模式" class="headerlink" title="9）访问者模式"></a>9）访问者模式</h4><p>在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。</p>
<p>主要将数据结构与数据操作分离。</p>
<p>主要解决：稳定的数据结构和易变的操作耦合问题。</p>
<blockquote>
<p>应用实例：您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。</p>
</blockquote>
<h4 id="10）中介者模式"><a href="#10）中介者模式" class="headerlink" title="10）中介者模式"></a>10）中介者模式</h4><p>中介者模式（Mediator Pattern）是用来<strong>降低多个对象和类之间的通信复杂性</strong>。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。</p>
<p>用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p>
<blockquote>
<p>应用实例：<br>1、中国加入WTO之前是各个国家相互贸易，结构复杂，现在是各个国家通过WTO来互相贸易；<br>2、机场调度系统；<br>3、MVC框架，其中C（控制器）就是M（模型）和V（视图）的中介者。</p>
</blockquote>
<h4 id="11）解释器模式"><a href="#11）解释器模式" class="headerlink" title="11）解释器模式"></a>11）解释器模式</h4><p>解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在SQL解析、符号处理引擎等。</p>
<p>给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。</p>
<blockquote>
<p>应用实例：编译器、运算表达式计算。</p>
</blockquote>
<h2 id="5-单例bean的线程安全问题了解吗？"><a href="#5-单例bean的线程安全问题了解吗？" class="headerlink" title="5.单例bean的线程安全问题了解吗？"></a>5.单例bean的线程安全问题了解吗？</h2><p>大部分时候我们并没有在项目中使用多线程，所以很少有人会关注这个问题。单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候是存在资源竞争的。</p>
<p>常见的有两种解决办法：</p>
<ol>
<li>在 bean 中尽量避免定义可变的成员变量。</li>
<li>在类中定义一个 <code>ThreadLocal</code> 成员变量，将需要的可变成员变量保存在 <code>ThreadLocal</code> 中（推荐的一种方式）。</li>
</ol>
<p>不过，大部分 bean 实际都是无状态（没有实例变量）的（比如 Dao、Service），这种情况下， bean 是线程安全的。</p>
<h2 id="6-单例模式中为什么要用双重检测"><a href="#6-单例模式中为什么要用双重检测" class="headerlink" title="6.单例模式中为什么要用双重检测"></a>6.单例模式中为什么要用双重检测</h2><p>第一层 if (instance &#x3D;&#x3D; null)是为了减少线程对同步锁锁的竞争，第二层if(instance&#x3D;&#x3D;nul)是保证单例。即</p>
<p>（1）if (instance &#x3D;&#x3D; null) 的懒汉式多线程下是不安全的；因为没有锁</p>
<p>（2）synchronized&#x2F;lock + if (instance &#x3D;&#x3D; null) 的懒汉式多线程下是安全的；</p>
<p>（3）if (instance &#x3D;&#x3D; null) + synchronized + if (instance &#x3D;&#x3D; null) 的懒汉式在（2）的情况下减少对同步锁的竞争，提高效率。</p>
<p>① synchronized&#x2F;lock + if (instance &#x3D;&#x3D; null) 变为 if (instance &#x3D;&#x3D; null) + synchronized&#x2F;lock，但是这样修改后，第一批进入的线程破坏单例模式。因为多个判断为null，然后实例对象，再进行加锁。</p>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>（1）外层 if (instance &#x3D;&#x3D; null) 保证，除了第一批进入的 t（t&lt;&#x3D;m） 次调用，其他的 n-t 次调用都无法进入，减少对于 synchronized&#x2F;lock 同步锁的竞争，提高效率。</p>
<p>（2）synchronized&#x2F;lock 保证对于第一批进入的 t 次调用，对于同步锁的竞争，只有一个线程可以得到同步锁，其他的 t - 1 个线程都在等待，唯一的线程新建对象的原子性。</p>
<p>（3）内层if(instance &#x3D;&#x3D; null) 保证，第一个获取同步锁进来的线程创建完对象之后，释放同步锁之后，第一批进来的 t-1 线程，即使得到同步锁，也不能再创建对象了，所有对于后面的 t - 1 个线程，它们会一个线程得到同步锁，然后内层 if (instance &#x3D;&#x3D; null) 为false，然后释放同步锁，然后又一个线程得到同步锁，然后内层 if (instance &#x3D;&#x3D; null) 为false，然后释放同步锁，直至 t-1 个都完成。</p>
<h2 id="7-单例模式的应用场景"><a href="#7-单例模式的应用场景" class="headerlink" title="7.单例模式的应用场景"></a>7.单例模式的应用场景</h2><p>为了解决一个全局使用的类频繁地创建与销毁。节省系统资源。</p>
<p>许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。</p>
<p>1.比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。</p>
<p>2.Windows的任务管理器</p>
<p>3.在一个程序中往往都只会使用一个线程池，因此线程池的创建也用单例模式</p>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="一、Redis知识全景图"><a href="#一、Redis知识全景图" class="headerlink" title="一、Redis知识全景图"></a>一、Redis知识全景图</h2><p><strong>“两大维度，三大主线”。</strong></p>
<p><img src="E:\学习笔记\图片\79da7093ed998a99d9abe91e610b74e7.jpg" alt="img"></p>
<p>“两大维度”就是指系统维度和应用维度，“三大主线”也就是指高性能、高可靠和高可扩展（可以简称为“三高”）。</p>
<p>在应用维度上，按照两种方式学习: “应用场景驱动”和“典型案例驱动”，一个是“面”的梳理，一个是“点”的掌握。</p>
<p>从系统维度上，需要了解 Redis 的各项关键技术的设计原理，</p>
<p>按照三大主线梳理技术知识</p>
<ul>
<li><p>高性能主线，包括线程模型、数据结构、持久化、网络框架；</p>
</li>
<li><p>高可靠主线，包括主从复制、哨兵机制；</p>
</li>
<li><p>高可扩展主线，包括数据分片、负载均衡。</p>
</li>
</ul>
<p><strong>Redis 的问题画像图</strong></p>
<p><img src="E:\学习笔记\图片\70a5bc1ddc9e3579a2fcb8a5d44118b4.jpeg" alt="img"></p>
<h2 id="二、基本架构"><a href="#二、基本架构" class="headerlink" title="二、基本架构"></a>二、基本架构</h2><p><strong>典型的键值数据库，属于内存键值数据库</strong></p>
<p>特性：</p>
<p>1.Redis 能够在实际业务场景中得到广泛的应用，就是得益于支持多样化类型的 value。大体来说，一个键值数据库包括了访问框架、索引模块、操作模块和存储模块四部分</p>
<img src="E:\学习笔记\图片\ec18bf4b8afef2fa8b99af252d95a2d5.jpg" alt="img" style="zoom: 25%;" />

<p>把这个简单的键值数据库称为 <strong>SimpleKV</strong>。</p>
<h3 id="采用什么访问模式？"><a href="#采用什么访问模式？" class="headerlink" title="采用什么访问模式？"></a><strong>采用什么访问模式？</strong></h3><p>访问模式通常有两种：一种是通过<strong>函数库调用的方式</strong>供外部应用使用，比如，上图中的 libsimplekv.so，就是以动态链接库的形式链接到我们自己的程序中，提供键值存储功能；另一种是通过<strong>网络框架以 Socket 通信的形式</strong>对外提供键值对操作，这种形式可以提供广泛的键值存储服务。在上图中，我们可以看到，网络框架中包括 Socket Server 和协议解析。</p>
<h3 id="如何定位键值对的位置？"><a href="#如何定位键值对的位置？" class="headerlink" title="如何定位键值对的位置？"></a><strong>如何定位键值对的位置</strong>？</h3><p>当 SimpleKV 解析了客户端发来的请求，知道了要进行的键值对操作，此时，SimpleKV 需要查找所要操作的键值对是否存在，这依赖于键值数据库的<strong>索引模块</strong>。索引的作用是让键值数据库根据 key 找到相应 value 的存储位置，进而执行操作。</p>
<p>一般而言，内存键值数据库（例如 Redis）采用哈希表作为索引，很大一部分原因在于，其键值数据基本都是保存在内存中的，而内存的高性能随机访问特性可以很好地与哈希表 O(1) 的操作复杂度相匹配。</p>
<h3 id="不同操作的具体逻辑是怎样的？"><a href="#不同操作的具体逻辑是怎样的？" class="headerlink" title="不同操作的具体逻辑是怎样的？"></a><strong>不同操作的具体逻辑是怎样的？</strong></h3><p>SimpleKV 的索引模块负责根据 key 找到相应的 value 的存储位置。对于不同的操作来说，找到存储位置之后，需要进一步执行的操作的具体逻辑会有所差异。SimpleKV 的操作模块就实现了不同操作的具体逻辑：</p>
<ul>
<li>对于 GET&#x2F;SCAN 操作而言，此时根据 value 的存储位置返回 value 值即可；</li>
<li>对于 PUT 一个新的键值对数据而言，SimpleKV 需要为该键值对分配内存空间；</li>
<li>对于 DELETE 操作，SimpleKV 需要删除键值对，并释放相应的内存空间，这个过程由分配器完成。</li>
</ul>
<h3 id="如何实现重启后快速提供服务？"><a href="#如何实现重启后快速提供服务？" class="headerlink" title="如何实现重启后快速提供服务？"></a><strong>如何实现重启后快速提供服务？</strong></h3><p>SimpleKV 采用了常用的内存分配器 glibc 的 malloc 和 free，因此，SimpleKV 并不需要特别考虑内存空间的管理问题。但是，键值数据库的键值对通常大小不一，glibc 的分配器在处理随机的大小内存块分配时，表现并不好。一旦保存的键值对数据规模过大，就可能会造成较严重的内存碎片问题。因此，<strong>分配器</strong>是键值数据库中的一个关键因素。对于以内存存储为主的 Redis 而言，这点尤为重要。Redis 的内存分配器提供了多种选择，分配效率也不一样。</p>
<p>一种方式是，对于每一个键值对，SimpleKV 都对其进行落盘保存，这虽然让 SimpleKV 的数据更加可靠，但是，因为每次都要写盘，SimpleKV 的性能会受到很大影响。</p>
<p>另一种方式是，SimpleKV 只是周期性地把内存中的键值数据保存到文件中，这样可以避免频繁写盘操作的性能影响。但是，一个潜在的代价是 SimpleKV 的数据仍然有丢失的风险。</p>
<p><img src="E:\学习笔记\图片\30e0e0eb0b475e6082dd14e63c13ed44.jpg" alt="img"></p>
<p>从这张对比图中，我们可以看到，从 SimpleKV 演进到 Redis，有以下几个重要变化：</p>
<ul>
<li>Redis 主要通过网络框架进行访问，而不再是动态库了，这也使得Redis可以作为一个基础性的网络服务进行访问，扩大了 Redis 的应用范围。</li>
<li>Redis 数据模型中的 value 类型很丰富，因此也带来了更多的操作接口，例如面向列表的 LPUSH&#x2F;LPOP，面向集合的 SADD&#x2F;SREM 等。</li>
<li>Redis 的持久化模块能支持两种方式：日志（AOF）和快照（RDB），这两种持久化方式具有不同的优劣势，影响到 Redis 的访问性能和可靠性。</li>
<li>SimpleKV 是个简单的单机键值数据库，但是，Redis 支持高可靠集群和高可扩展集群，因此，Redis 中包含了相应的集群功能支撑模块。</li>
</ul>
<p>SimpleKV和Redis的对比： </p>
<p>【数据结构】上缺乏广泛的数据结构支持：比如支持范围查询的SkipList，和Stream等等数据结构 </p>
<p>【高可用】上缺乏，哨兵或者master-slaver模式的高可用设计 </p>
<p>【横向扩展】上缺乏集群和分片功能 </p>
<p>【在内存安全性】上，缺乏内存过载时候的key淘汰算法的支持 </p>
<p>【内存利用率】没有充分对数据结构优化提高内存利用率，例如使用压缩性的数据结构 </p>
<p>【功能扩展】需要具备后续功能的拓展 </p>
<p>【不具备事务性】无法保证多个操作的原子性</p>
<p>【内存分配器】SimpleKV就是glibc，Redis的分配器选择更多。</p>
<h2 id="三、数据结构"><a href="#三、数据结构" class="headerlink" title="三、数据结构"></a>三、数据结构</h2><h3 id="Redis数据库为什么快"><a href="#Redis数据库为什么快" class="headerlink" title="Redis数据库为什么快"></a>Redis数据库为什么快</h3><p>一方面，这是因为它是<strong>内存数据库</strong>，所有操作都在内存上完成，内存的访问速度本身就很快。另一方面，这要归功于它的<strong>数据结构</strong>。这是因为，键值对是按一定的数据结构来组织的，操作键值对最终就是对数据结构进行增删改查操作，所以高效的数据结构是 Redis 快速处理数据的基础。</p>
<p>说到这儿，你肯定会说：“这个我知道，不就是 String（字符串）、List（列表）、Hash（哈希）、Set（集合）和 Sorted Set（有序集合）吗？”其实，这些只是 Redis 键值对中值的数据类型，也就是数据的保存形式。而这里，我们说的数据结构，是要去看看它们的底层实现。简单来说，底层数据结构一共有 6 种，分别是简单动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组。它们和数据类型的对应关系如下图所示：</p>
<p><img src="E:\学习笔记\图片\8219f7yy651e566d47cc9f661b399f01.jpg" alt="img"></p>
<p>List、Hash、Set 和 Sorted Set 这四种数据类型，都有两种底层实现结构。通常情况下，我们会把这四种类型称为集合类型，它们的特点是一个键对应了一个集合的数据。</p>
<h3 id="键和值用什么结构组织？"><a href="#键和值用什么结构组织？" class="headerlink" title="键和值用什么结构组织？"></a><strong>键和值用什么结构组织？</strong></h3><p>为了实现从键到值的快速访问，<strong>Redis 使用了一个哈希表来保存所有键值对。</strong>一个哈希表，其实就是一个数组，数组的每个元素称为一个<strong>哈希桶</strong>。所以，我们常说，一个哈希表是由多个哈希桶组成的，每个哈希桶中保存了键值对数据。</p>
<p>看到这里，你可能会问了：“如果值是集合类型的话，作为数组元素的哈希桶怎么来保存呢？”其实，<strong>哈希桶中的元素保存的并不是值本身，而是指向具体值的指针</strong>。这也就是说，不管值是 String，还是集合类型，哈希桶中的元素都是指向它们的指针。</p>
<p>在下图中，可以看到，哈希桶中的 entry 元素中保存了<em>key和</em>value指针，分别指向了实际的键和值，这样一来，即使值是一个集合，也可以通过*value指针被查找到。</p>
<p><img src="E:\学习笔记\图片\1cc8eaed5d1ca4e3cdbaa5a3d48dfb5f.jpg" alt="img"></p>
<p>因为这个哈希表保存了所有的键值对，所以，我也把它称为<strong>全局哈希表</strong>。哈希表的最大好处很明显，就是让我们<strong>可以用 O(1) 的时间复杂度来快速查找到键值对</strong>——我们只需要计算键的哈希值，就可以知道它所对应的哈希桶位置，然后就可以访问相应的 entry 元素。</p>
<p>但是在往 Redis 中写入大量数据后，就可能发现操作有时候会突然变慢了</p>
<h3 id="为什么哈希表操作变慢了？"><a href="#为什么哈希表操作变慢了？" class="headerlink" title="为什么哈希表操作变慢了？"></a><strong>为什么哈希表操作变慢了？</strong></h3><p>当你往哈希表中写入更多数据时，哈希冲突是不可避免的问题。Redis 解决哈希冲突的方式，就是<strong>链式哈希</strong>。</p>
<p><img src="E:\学习笔记\图片\8ac4cc6cf94968a502161f85d072e428.jpg" alt="img"></p>
<p>但是，这里依然存在一个问题，哈希冲突链上的元素只能通过指针逐一查找再操作。如果哈希表里写入的数据越来越多，哈希冲突可能也会越来越多，这就会导致某些哈希冲突链过长，进而导致这个链上的元素查找耗时长，效率降低。对于追求“快”的 Redis 来说，这是不太能接受的。所以，Redis 会对哈希表做 <strong>rehash</strong> 操作。</p>
<p>rehash 也就是增加现有的哈希桶数量，让逐渐增多的 entry 元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突。那具体怎么做呢？</p>
<p>为了使 rehash 操作更高效，Redis 默认使用了两个全局哈希表：哈希表 1 和哈希表 2。一开始，当你刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash，这个过程分为三步：</p>
<ul>
<li>给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；</li>
<li>把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；</li>
<li>释放哈希表 1 的空间。</li>
</ul>
<p>到此，我们就可以从哈希表1切换到哈希表 2，用增大的哈希表 2 保存更多数据，而原来的哈希表 1 留作下一次 rehash 扩容备用。</p>
<p>第二步涉及大量的数据拷贝，如果一次性把哈希表 1 中的数据都迁移完，会造成 Redis 线程阻塞，无法服务其他请求。此时，Redis 就无法快速访问数据了。为了避免这个问题，Redis 采用了<strong>渐进式 rehash</strong>。</p>
<p>简单来说就是在第二步拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries。</p>
<h3 id="集合数据操作效率"><a href="#集合数据操作效率" class="headerlink" title="集合数据操作效率"></a>集合数据操作效率</h3><p>首先，与集合的<strong>底层数据结构</strong>有关。例如，使用哈希表实现的集合，要比使用链表实现的集合访问效率更高。其次，操作效率和这些<strong>操作本身的执行特点</strong>有关，比如读写一个元素的操作要比读写所有元素的效率高。</p>
<h3 id="有哪些底层数据结构？"><a href="#有哪些底层数据结构？" class="headerlink" title="有哪些底层数据结构？"></a>有哪些底层数据结构？</h3><p><strong>整数数组、双向链表、哈希表、压缩列表和跳表。</strong></p>
<h4 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h4><p>实际上类似于一个数组，数组中的每一个元素都对应保存一个数据。和数组不同的是，压缩列表在表头有三个字段zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 zlend，表示列表结束。</p>
<p><img src="E:\学习笔记\图片\9587e483f6ea82f560ff10484aaca4a0.jpg" alt="img"></p>
<p>在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是 O(1)。而查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了。</p>
<h4 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h4><p>跳跃列表的每一层都是一个有序的链表，链表中每个节点都包含两个指针，一个指向同一层的下一个节点，另一个指向下一层的同一个节点。最低层的链表将包含 zset 中的所有元素。</p>
<p>有序链表只能逐一查找元素，导致操作起来非常缓慢，于是就出现了跳表。具体来说，<strong>跳表在链表的基础上，增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位</strong>，如下图所示：</p>
<p><img src="E:\学习笔记\图片\1eca7135d38de2yy16681c2bbc4f3fb4.jpg" alt="img"></p>
<p>为了提高查找速度，我们来增加一级索引：从第一个元素开始，每两个元素选一个出来作为索引。这些索引再通过指针指向原始的链表。例如，从前两个元素中抽取元素 1 作为一级索引，从第三、四个元素中抽取元素 11 作为一级索引。此时，我们只需要 4 次查找就能定位到元素 33 了。</p>
<p>如果我们还想再快，可以再增加二级索引：从一级索引中，再抽取部分元素作为二级索引。例如，从一级索引中抽取 1、27、100 作为二级索引，二级索引指向一级索引。这样，我们只需要 3 次查找，就能定位到元素 33 了。</p>
<p>当数据量很大时，跳表的查找复杂度就是 **O(logN)**。</p>
<p>按照查找的时间复杂度给这些数据结构分类</p>
<p><img src="E:\学习笔记\图片\fb7e3612ddee8a0ea49b7c40673a0cf0.jpg" alt="img"></p>
<p><strong>整数数组和压缩列表在查找时间复杂度方面并没有很大的优势，那为什么 Redis 还会把它们作为底层数据结构呢？</strong></p>
<p>1、<strong>内存利用率</strong>，数组和压缩列表都是非常紧凑的数据结构，它比链表占用的内存要更少。Redis是内存数据库，大量数据存到内存中，此时需要做尽可能的优化，提高内存的利用率。 2、<strong>数组对CPU高速缓存支持更友好</strong>，所以Redis在设计时，集合数据元素较少情况下，默认采用内存紧凑排列的方式存储，同时利用CPU高速缓存不会降低访问速度。当数据元素超过设定阈值后，避免查询时间复杂度太高，转为哈希和跳表数据结构存储，保证查询效率。</p>
<h3 id="有序集合（zset）"><a href="#有序集合（zset）" class="headerlink" title="有序集合（zset）"></a>有序集合（zset）</h3><p>有序集合（zset）同样使用了两种不同的存储结构，分别是 zipList（压缩列表）和 skipList（跳跃列表），当 zset 满足以下条件时使用压缩列表：</p>
<ul>
<li>成员的数量小于128 个；</li>
<li>每个 member （成员）的字符串长度都小于 64 个字节。</li>
</ul>
<p>当有序结合不满足使用压缩列表的条件时，就会使用 skipList （跳表）结构来存储数据。</p>
<h2 id="四、高性能IO模型：为什么单线程Redis能那么快？"><a href="#四、高性能IO模型：为什么单线程Redis能那么快？" class="headerlink" title="四、高性能IO模型：为什么单线程Redis能那么快？"></a>四、高性能IO模型：为什么单线程Redis能那么快？</h2><p><strong>一方面</strong>，Redis 的大部分操作在内存上完成，再加上它采用了高效的数据结构，例如哈希表和跳表，这是它实现高性能的一个重要原因。<strong>另一方面</strong>，就是 Redis 采用了多路复用机制，使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率。</p>
<h2 id="五、Redis持久化（数据尽量少丢失）"><a href="#五、Redis持久化（数据尽量少丢失）" class="headerlink" title="五、Redis持久化（数据尽量少丢失）"></a>五、Redis持久化（数据尽量少丢失）</h2><p>Redis 的持久化主要有两大机制，即 <strong>AOF（Append Only File）日志</strong>和 <strong>RDB 快照。</strong></p>
<p><strong>AOF 日志是如何实现的？</strong></p>
<p>AOF 是<strong>写后日志</strong>，记录的是 Redis 收到的每一条命令</p>
<p><strong>好处</strong></p>
<ul>
<li>可以<strong>避免出现记录错误命令的情况</strong>。</li>
<li>它是在命令执行后才记录日志，所以<strong>不会阻塞当前的写操作。</strong></li>
</ul>
<p><strong>风险</strong></p>
<p>1.刚执行完一个命令，还没有来得及记日志就宕机了，那么这个命令和相应的数据就有丢失的风险</p>
<p>2.AOF 虽然避免了对当前命令的阻塞，但可能会给下一个操作带来阻塞风险。这是因为，AOF 日志也是在主线程中执行的，如果在把日志文件写入磁盘时，磁盘写压力大，就会导致写盘很慢，进而导致后续的操作也无法执行了。</p>
<p>这两个<strong>风险都是和 AOF 写回磁盘的时机相关的</strong>。</p>
<p>这也就意味着，如果我们能够控制一个写命令执行完后 AOF 日志写回磁盘的时机，这两个风险就解除了。</p>
<p><strong>三种写回策略</strong></p>
<p>其实，对于这个问题，AOF 机制给我们提供了三个选择，也就是 AOF 配置项 appendfsync 的三个可选值。</p>
<ul>
<li><strong>Always</strong>，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；</li>
<li><strong>Everysec</strong>，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；</li>
<li><strong>No</strong>，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。</li>
</ul>
<p><img src="E:\学习笔记\图片\72f547f18dbac788c7d11yy167d7ebf8.jpg" alt="img"></p>
<h3 id="日志文件太大了怎么办（AOF-重写机制）"><a href="#日志文件太大了怎么办（AOF-重写机制）" class="headerlink" title="日志文件太大了怎么办（AOF 重写机制）"></a>日志文件太大了怎么办（AOF 重写机制）</h3><p>AOF重写机制指的是，对过大的AOF文件进行重写，以此来压缩AOF文件的大小。 具体的实现是：检查当前键值数据库中的键值对，记录键值对的<strong>最终状态</strong>，从而实现<strong>对某个键值对重复操作后产生的多条操作记录压缩成一条</strong> 的效果。进而实现压缩AOF文件的大小。</p>
<h3 id="AOF的不足"><a href="#AOF的不足" class="headerlink" title="AOF的不足"></a>AOF的不足</h3><p>AOF记录的是操作命令，而不是实际的数据，所以，用 AOF 方法进行故障恢复的时候，需要逐一把操作日志都执行一遍。如果操作日志非常多，Redis 就会恢复得很缓慢，影响到正常使用。</p>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p><strong>RDB 记录的是某一时刻的数据</strong>，Redis 的数据都在内存中，为了提供所有数据的可靠性保证，它执行的是<strong>全量快照</strong>。Redis创建一个子进程，专门用于写入 RDB 文件，<strong>避免了主线程的阻塞</strong>，这也是 Redis RDB 文件生成的默认配置。</p>
<h3 id="如何做快照"><a href="#如何做快照" class="headerlink" title="如何做快照"></a>如何做快照</h3><p><strong>增量快照</strong>，所谓增量快照，就是指，做了一次全量快照后，后续的快照只对修改的数据进行快照记录，这样可以避免每次全量快照的开销。</p>
<p>Redis 4.0 中提出了一个<strong>混合使用 AOF 日志和内存快照的方法</strong>。简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。</p>
<h2 id="六、主从库（服务尽量少中断）"><a href="#六、主从库（服务尽量少中断）" class="headerlink" title="六、主从库（服务尽量少中断）"></a>六、主从库（服务尽量少中断）</h2><p>Redis 提供了主从库模式，以保证数据副本的一致，主从库之间采用的是读写分离的方式。</p>
<ul>
<li>读操作：主库、从库都可以接收；</li>
<li>写操作：首先到主库执行，然后，主库将写操作同步给从库。</li>
</ul>
<p>为什么要采用读写分离？</p>
<p>假如不管是主库还是从库，都能接收客户端的写操作，那么，每次访问不同的实例，则会形成几个不同的副本。而采用了读写分离，只对主库进行写，主库有了最新的数据后，会同步给从库，这样，主从库的数据就是一致的。</p>
<h3 id="主从库间如何进行第一次同步？"><a href="#主从库间如何进行第一次同步？" class="headerlink" title="主从库间如何进行第一次同步？"></a>主从库间如何进行第一次同步？</h3><p>当我们启动多个 Redis 实例的时候，它们相互之间就可以通过 replicaof（Redis 5.0 之前使用 slaveof）命令形成主库和从库的关系，之后会按照三个阶段完成数据的第一次同步。</p>
<p><strong>第一阶段</strong>是主从库间<strong>建立连接、协商同步</strong>的过程。</p>
<p><strong>第二阶段</strong>，主库将所有<strong>数据同步给从库</strong>。</p>
<p>主库执行 bgsave 命令，生成 RDB 文件，接着将文件发给从库。从库接收到 RDB 文件后，会先清空当前数据库，然后加载 RDB 文件。</p>
<p><strong>第三阶段</strong>，主库会把第二阶段执行过程中新收到的写命令，再发送给从库。</p>
<p>为了缓解主从库全量复制时主库的压力，可以采用<strong>主从级联模式</strong>。</p>
<h2 id="七、主从库切换（哨兵）"><a href="#七、主从库切换（哨兵）" class="headerlink" title="七、主从库切换（哨兵）"></a>七、主从库切换（哨兵）</h2><p>如果主库挂了，我们就需要运行一个新主库，比如说把一个从库切换为主库，把它当成主库。<strong>哨兵机制</strong>是实现主从库自动切换的关键机制。从本质上说，哨兵就是一个运行在特定模式下的 Redis 实例。</p>
<h3 id="哨兵机制的基本流程"><a href="#哨兵机制的基本流程" class="headerlink" title="哨兵机制的基本流程"></a>哨兵机制的基本流程</h3><p>哨兵其实就是一个运行在特殊模式下的 Redis 进程，主从库实例运行的同时，它也在运行。哨兵主要负责的就是三个任务：<strong>监控</strong>、<strong>选主</strong>（选择主库）和<strong>通知</strong>。</p>
<h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p>哨兵进程在运行时，周期性地给所有的主从库发送 PING 命令，检测它们</p>
<p>是否仍然在线运行。若在规定时间内没有响应，则被标记为<strong>下线状态</strong>；假如主库没有响应，则开始<strong>自动换库</strong>的流程。</p>
<h4 id="主观下线和客观下线"><a href="#主观下线和客观下线" class="headerlink" title="主观下线和客观下线"></a>主观下线和客观下线</h4><h4 id="主观下线"><a href="#主观下线" class="headerlink" title="主观下线"></a><strong>主观下线</strong></h4><p>哨兵进程会使用 PING 命令检测它自己和主、从库的网络连接情况，用来判断实例的状态。主库响应超时，则先被标记为“主观下线”。假如是主库，开启主从切换。从库直接标为“主观下线”。</p>
<h4 id="为了避免误判"><a href="#为了避免误判" class="headerlink" title="为了避免误判"></a><strong>为了避免误判</strong></h4><p>哨兵通常会采用多实例组成的<strong>集群模式进行部署</strong>，这也被称为<strong>哨兵集群</strong>。引入多个哨兵实例一起来判断，就可以<strong>避免单个哨兵因为自身网络状况不好，而误判主库下线的情况</strong>。</p>
<p>只有大多数的哨兵实例，都判断主库已经“主观下线”了，主库才会被标记为“<strong>客观下线</strong>”</p>
<h3 id="选主（自动换库）"><a href="#选主（自动换库）" class="headerlink" title="选主（自动换库）"></a>选主（自动换库）</h3><h4 id="如何选定新主库？"><a href="#如何选定新主库？" class="headerlink" title="如何选定新主库？"></a>如何选定新主库？</h4><p>在多个从库中，先按照一定的<strong>筛选</strong>条件，把不符合条件的从库去掉。然后，我们再按照一定的规则，给剩下的从库逐个<strong>打分</strong>，将得分最高的从库选为新主库。</p>
<p>1.在选主时，除了要检查从库的当前在线状态，还要判断它之前的<strong>网络连接状态</strong>。</p>
<p>具体怎么判断：使用配置项 down-after-milliseconds * 10。其中，<strong>down-after-milliseconds</strong> 是我们认定<strong>主从库断连的最大连接超时时间</strong>。如果在 down-after-milliseconds 毫秒内，主从节点都没有通过网络联系上，我们就可以认为主从节点断连了。如果发生断连的次数超过了 10 次，就说明这个从库的网络状况不好，不适合作为新主库。</p>
<p>2.分别从库优先级、从库复制进度以及从库 ID 号对从库进行打分。</p>
<p><strong>第一轮</strong>：优先级最高的从库得分高。用户可以通过 slave-priority 配置项，给不同的从库设置不同优先级。</p>
<p><strong>第二轮</strong>：和旧主库同步程度最接近的从库得分高。</p>
<p>主从库同步时有个命令传播的过程。在这个过程中，master_repl_offset 记录当前的最新写操作在 repl_backlog_buffer 中的位置，而从库会用 slave_repl_offset 这个值记录当前的复制进度。此时，在所有从库中，<strong>有从库的 slave_repl_offset 最接近 master_repl_offset</strong>，那么它的得分就最高，可以作为新主库。</p>
<p><strong>第三轮</strong>：ID 号小的从库得分高。</p>
<p>默认的规定：在优先级和复制进度都相同的情况下，ID 号最小的从库得分最高，会被选为新主库。</p>
<h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><p>在执行通知任务时，哨兵会把新主库的连接信息<strong>发给其他从库</strong>，让它们执行 replicaof 命令，和新主库建立连接，并进行数据复制。同时，哨兵会把新主库的连接信息<strong>通知给客户端</strong>，让它们把请求操作发到新主库上。</p>
<h2 id="八、哨兵集群（哨兵的高可用）"><a href="#八、哨兵集群（哨兵的高可用）" class="headerlink" title="八、哨兵集群（哨兵的高可用）"></a>八、哨兵集群（哨兵的高可用）</h2><p>一旦多个实例组成了哨兵集群，即使有哨兵实例出现故障挂掉了，其他哨兵还能继续协作完成主从库切换的工作。</p>
<h3 id="哨兵之间如何通信"><a href="#哨兵之间如何通信" class="headerlink" title="哨兵之间如何通信"></a>哨兵之间如何通信</h3><p>哨兵实例之间可以相互发现，要归功于 Redis 提供的 pub&#x2F;sub 机制，也就是<strong>发布 &#x2F; 订阅机制</strong>。<strong>每个哨兵都把自己的信息发送给主库，然后从主库订阅其他哨兵的消息。</strong>由哨兵向主库发送 INFO 命令,主库接受到这个命令后，就会把从库列表返回给哨兵。</p>
<h3 id="由哪个哨兵执行主从切换？"><a href="#由哪个哨兵执行主从切换？" class="headerlink" title="由哪个哨兵执行主从切换？"></a>由哪个哨兵执行主从切换？</h3><p>客观下线仲裁过程： </p>
<ol>
<li>任何一个实例只要自身判断主库主观下线后，就会给其他实例发送is-master-down-by-addr命令。</li>
<li>其他实例会根据自己和主库的连接情况，做出Y或N的响应。 </li>
<li>该哨兵实例获得了仲裁所需的赞成票数后【哨兵配置文件中的quorum配置项，数值为几，就需要几张赞成票，包括自己】，就可以标记主库为客观下线。 </li>
<li>该哨兵实例可以再给其他哨兵发送命令，表明希望由自己来执行主从切换，并让其他哨兵进行投票<strong>（Leader选举）</strong>。 在投票过程中，任何一个想成为Leader的哨兵： 1. 拿到半数以上的赞成票。 2. 拿到的票数同时还需要大于等于哨兵配置文件中的quorum值。 如果这轮没有产生Leader，哨兵集群会等待一段时间（哨兵故障转移超时时间的2倍），再重新选举。（通常我们至少会配置 3 个哨兵实例。）</li>
</ol>
<h2 id="九、切片集群（海量数据的存储及并高并发写）"><a href="#九、切片集群（海量数据的存储及并高并发写）" class="headerlink" title="九、切片集群（海量数据的存储及并高并发写）"></a>九、切片集群（海量数据的存储及并高并发写）</h2><h3 id="如何保存更多数据？"><a href="#如何保存更多数据？" class="headerlink" title="如何保存更多数据？"></a>如何保存更多数据？</h3><p>Redis 应对数据量增多的两种方案：纵向扩展（scale up）和横向扩展（scale out）。</p>
<ul>
<li><strong>纵向扩展</strong>：升级单个 Redis 实例的资源配置，包括增加内存容量、增加磁盘容量、使用更高配置的 CPU。就像下图中，原来的实例内存是 8GB，硬盘是 50GB，纵向扩展后，内存增加到 24GB，磁盘增加到 150GB。</li>
<li><strong>横向扩展</strong>：横向增加当前 Redis 实例的个数，就像下图中，原来使用 1 个 8GB 内存、50GB 磁盘的实例，现在使用三个相同配置的实例。</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>纵向扩展</strong></p>
<p>优点：实施起来简单、直接。</p>
<p>缺点：1.当使用 RDB 对数据进行持久化时，如果数据量增加，需要的内存也会增加，主线程 fork 子进程时就可能会阻塞。</p>
<p>2.纵向扩展会受到硬件和成本的限制。</p>
<p><strong>横向扩展</strong></p>
<p>优点：扩展性更好，<strong>在面向百万、千万级别的用户规模时，横向扩展的 Redis 切片集群会是一个非常好的选择。</strong></p>
<h3 id="数据切片和实例的对应分布关系"><a href="#数据切片和实例的对应分布关系" class="headerlink" title="数据切片和实例的对应分布关系"></a>数据切片和实例的对应分布关系</h3><p>从 Redis3.0 开始，官方提供了一个名为 <strong>Redis Cluster</strong> 的方案，用于实现切片集群。Redis Cluster 方案中就规定了数据和实例的对应规则。</p>
<p>Redis Cluster 方案采用哈希槽（Hash Slot，接下来我会直接称之为 Slot），来处理数据和实例之间的映射关系。在 Redis Cluster 方案中，一个切片集群共有 16384 个哈希槽，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中。过程分为两步：</p>
<p>1.首先根据键值对的 key，按照CRC16 算法计算一个 16 bit 的值</p>
<p>2.用这个 16bit 值对 16384 取模，得到 0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽。</p>
<h3 id="客户端如何定位数据？"><a href="#客户端如何定位数据？" class="headerlink" title="客户端如何定位数据？"></a>客户端如何定位数据？</h3><p>哈希槽可以通过CRC16算法计算key得到，Redis实例会把自己的哈希槽信息扩散给和它相连的其他实例，这样每一个实例就都能知道所有的哈希槽映射信息了。客户端和集群实例建立连接后，实例就会把哈希槽的分配信息发给客户端。客户端知道哈希槽的分布之后，会缓存一份到本地。</p>
<p>实例之间还可以通过相互传递消息，获得最新的哈希槽分配信息，但是，客户端是无法主动感知这些变化的。因此，客户端根据哈希槽在查找数据时，如果这个实例上并没有这个键值对映射的哈希槽，那么，这个实例就会给客户端返回下面的 MOVED 命令响应结果，这个结果中就包含了新实例的访问地址。</p>
<h3 id="Redis-Cluster不采用把key直接映射到实例的方式，而采用哈希槽的方式原因："><a href="#Redis-Cluster不采用把key直接映射到实例的方式，而采用哈希槽的方式原因：" class="headerlink" title="Redis Cluster不采用把key直接映射到实例的方式，而采用哈希槽的方式原因："></a>Redis Cluster不采用把key直接映射到实例的方式，而采用哈希槽的方式原因：</h3><p>1.整个集群存储key的数量是无法预估的，key的数量非常多时，直接记录每个key对应的实例映射关系，这个映射表会非常庞大，这个映射表无论是存储在服务端还是客户端都占用了非常大的内存空间。</p>
<p>2.当集群在扩容、缩容、数据均衡时，节点之间会发生数据迁移，迁移时需要修改每个key的映射关系，维护成本高。</p>
<p>3.而在中间增加一层哈希槽，可以把数据和节点解耦，key通过Hash计算，只需要关心映射到了哪个哈希槽，然后再通过哈希槽和实例节点的映射表找到实例节点，相当于消耗了很少的CPU资源。</p>
<h2 id="十、Redis变慢的应对"><a href="#十、Redis变慢的应对" class="headerlink" title="十、Redis变慢的应对"></a>十、Redis变慢的应对</h2><h3 id="1-Redis-自身操作特性的影响"><a href="#1-Redis-自身操作特性的影响" class="headerlink" title="1.Redis 自身操作特性的影响"></a>1.Redis 自身操作特性的影响</h3><p>两类关键操作：<strong>慢查询命令</strong>和<strong>过期 key 操作</strong>。</p>
<h4 id="1-1慢查询命令"><a href="#1-1慢查询命令" class="headerlink" title="1.1慢查询命令"></a>1.1慢查询命令</h4><p>慢查询命令，就是指在 Redis 中执行速度慢的命令，这会导致 Redis 延迟增加。</p>
<p><strong>应对</strong></p>
<p>1.用其他高效命令代替。比如说，如果你需要返回一个 SET 中的所有成员时，不要使用 SMEMBERS 命令，而是要使用 SSCAN 多次迭代返回，<strong>避免一次返回大量数据</strong>，造成线程阻塞。</p>
<p>2.<strong>当需要执行排序、交集、并集操作时，可以在客户端完成</strong>，而不要用 SORT、SUNION、SINTER 这些命令，以免拖慢 Redis 实例。</p>
<p>3.还有一个比较容易忽略的慢查询命令，就是 KEYS。它用于返回和输入模式匹配的所有 key，因为 KEYS 命令需要遍历存储的键值对，所以操作延时高。<strong>KEYS 命令一般不被建议用于生产环境中。</strong></p>
<h4 id="1-2过期-key-操作"><a href="#1-2过期-key-操作" class="headerlink" title="1.2过期 key 操作"></a>1.2过期 key 操作</h4><p>Redis 键值对的 key 可以设置过期时间。默认情况下，Redis 每 100 毫秒会删除一些过期 key，具体的算法如下：</p>
<p>1.采样 ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP 个数的 key，并将其中过期的 key 全部删除；</p>
<p>2.如果超过 25% 的 key 过期了，则重复删除的过程，直到过期 key 的比例降至 25% 以下。</p>
<p>如果触发了上面这个算法的第二条，Redis 就会一直删除以释放内存空间。影响性能。</p>
<p><strong>应对</strong></p>
<p>要检查业务代码在设置 key 过期时间时，是否使用了相同的时间戳，有没有给批量的 key 设置相同的过期秒数。</p>
<p>遇到这种情况时，如果一批 key 的确是同时过期，可以在 过期时间参数上，加上一个一定大小范围内的随机数。</p>
<h2 id="十一、缓冲和数据库不一致"><a href="#十一、缓冲和数据库不一致" class="headerlink" title="十一、缓冲和数据库不一致"></a>十一、缓冲和数据库不一致</h2><h3 id="缓存和数据库的数据不一致是如何发生的？"><a href="#缓存和数据库的数据不一致是如何发生的？" class="headerlink" title="缓存和数据库的数据不一致是如何发生的？"></a>缓存和数据库的数据不一致是如何发生的？</h3><p>“一致性包含了两种情况”</p>
<ul>
<li>缓存中数据和数据库中数据一致</li>
<li>缓冲中没有的数据 ，数据库中必须是最新的</li>
</ul>
<p>当缓存的读写模式不同时，缓存数据不一致的发生情况不一样，我们的应对方法也会有所不同，缓存分成两种情况：<strong>读写缓存</strong>和<strong>只读缓存</strong></p>
<p>对于<strong>读写缓存</strong>来说，要对数据进行增删改，就需要在缓存中进行，同时还要根据采取的写回策略，决定是否同步写回到数据库中。</p>
<ul>
<li>同步直写策略：写缓存时，也同步写数据库，缓存和数据库中的数据一致；</li>
<li>异步写回策略：写缓存时不同步写数据库，等到数据从缓存中淘汰时，再写回数据库。使用这种策略时，如果数据还没有写回数据库，缓存就发生了故障，那么，此时，数据库就没有最新的数据了。</li>
</ul>
<p>因此对于读写缓存，要想保证一致性，就必须采用同步读写策略。还需通过事务保证操作的原子性。</p>
<p>对于<strong>只读缓存</strong>来说：如果有数据新增，会直接写入数据库；而有数据删改时，就需要把只读缓存中的数据标记为无效。这样一来，应用后续再访问这些增删改的数据时，因为缓存中没有相应的数据，就会发生缓存缺失。此时，应用再从数据库中把数据读入缓存，这样后续再访问数据时，就能够直接从缓存中读取了。</p>
<p><strong>对于不同的操作</strong></p>
<p>新增操作：直接在数据库中新增</p>
<p>删改操作：</p>
<p><img src="E:\学习笔记\图片\2c376b536aff9d14d8606499f401cdac.jpg" alt="img"></p>
<p>但是删除缓存的时间很短，第二种情况很难出现。</p>
<p>在大多数业务场景下，我们会把 Redis 作为只读缓存使用。建议是，<strong>优先使用先更新数据库再删除缓存的方法</strong></p>
<h2 id="十二、缓存雪崩、击穿、穿透"><a href="#十二、缓存雪崩、击穿、穿透" class="headerlink" title="十二、缓存雪崩、击穿、穿透"></a>十二、缓存雪崩、击穿、穿透</h2><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩是指大量的应用请求无法在 Redis 缓存中进行处理，紧接着，应用将大量请求发送到数据库层，导致数据库层的压力激增。</p>
<p><strong>第一个原因是</strong>：缓存中有大量数据同时过期，导致大量请求无法得到处理。</p>
<p>解决方案：</p>
<p>1.避免给大量的数据设置相同的过期时间</p>
<p>2.服务降级</p>
<p>所谓的服务降级，是指发生缓存雪崩时，针对不同的数据采取不同的处理方式。</p>
<ul>
<li>当业务应用访问的是非核心数据（例如电商商品属性）时，暂时停止从缓存中查询这些数据，而是直接返回预定义信息、空值或是错误信息；</li>
<li>当业务应用访问的是核心数据（例如电商商品库存）时，仍然允许查询缓存，如果缓存缺失，也可以继续通过数据库读取。</li>
</ul>
<p><strong>第二个原因</strong>：Redis 缓存实例发生故障宕机了，无法处理请求，这就会导致大量请求一下子积压到数据库层，从而发生缓存雪崩。</p>
<p>1.在业务系统中实现服务熔断或请求限流机制。</p>
<p>所谓的服务熔断，是指在发生缓存雪崩时，为了防止引发连锁的数据库雪崩，甚至是整个系统的崩溃，我们暂停业务应用对缓存系统的接口访问。再具体点说，就是业务应用调用缓存接口时，缓存客户端并不把请求发给 Redis 缓存实例，而是直接返回，等到 Redis 缓存实例重新恢复服务后，再允许应用请求发送到缓存系统。</p>
<p>请求限流，就是指，我们在业务系统的请求入口前端控制每秒进入系统的请求数，避免过多的请求被发送到数据库。</p>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿是指，针对某个访问非常频繁的<strong>热点数据</strong>的请求，无法在缓存中进行处理，紧接着，访问该数据的大量请求，一下子都发送到了后端数据库，导致了数据库压力激增，会影响数据库处理其他请求。缓存击穿的情况，经常发生在热点数据过期失效时。</p>
<p>应对方案：对于访问特别频繁的热点数据，不设置过期时间</p>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透是指要访问的数据既不在 Redis 缓存中，也不在数据库中，导致请求在访问缓存时，发生缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据。<strong>虚假访问数据</strong></p>
<p>缓存穿透会发生在什么时候呢？一般来说，有两种情况。</p>
<ul>
<li>业务层误操作：缓存中的数据和数据库中的数据被误删除了，所以缓存和数据库中都没有数据；</li>
<li>恶意攻击：专门访问数据库中没有的数据。</li>
</ul>
<p><strong>解决方案</strong></p>
<p>1.缓存空值或缺省值。</p>
<p>一旦发生缓存穿透，我们就可以针对查询的数据，在 Redis 中缓存一个空值或是和业务层协商确定的缺省值缓存空值或缺省值。一旦发生缓存穿透，我们就可以针对查询的数据，在 Redis 中缓存一个空值或是和业务层协商确定的缺省值</p>
<p>2.使用布隆过滤器快速判断数据是否存在，避免从数据库中查询数据是否存在，减轻数据库压力。</p>
<p>3.在请求入口的前端进行请求检测。（恶意性检测）</p>
<h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p><img src="E:\学习笔记\图片\b5bd931239be18bef24b2ef36c70e9e1.jpg" alt="img"></p>
<p>尽量使用预防式方案：</p>
<p>针对缓存雪崩，合理地设置数据过期时间，以及搭建高可靠缓存集群；</p>
<p>针对缓存击穿，在缓存访问非常频繁的热点数据时，不要设置过期时间；</p>
<p>针对缓存穿透，提前在入口前端实现恶意请求检测，或者规范数据库的数据删除操作，避免误删除。</p>
<h2 id="十三、用Redis实现分布式session"><a href="#十三、用Redis实现分布式session" class="headerlink" title="十三、用Redis实现分布式session"></a>十三、用Redis实现分布式session</h2><ul>
<li>1）在用户初次访问服务器时，给它创建一个唯一的身份标识，并且使用cookie封装这个标识，将它存储在服务器之外的一个redis中，再将令牌返回给用户。</li>
<li>2）用户再次访问服务器时，先在Redis获取到它之前的身份标识，然后在进行访问数据库。</li>
</ul>
<h2 id="十四、-布隆过滤器"><a href="#十四、-布隆过滤器" class="headerlink" title="十四、 布隆过滤器"></a>十四、 布隆过滤器</h2><p>核心包括两部分：</p>
<ul>
<li>一个大型的位数组</li>
<li>若干个不一样的哈希函数，每个哈希函数都能将哈希值算的比较均匀</li>
</ul>
<p>工作原理：</p>
<ul>
<li>添加key时，每个哈希函数都利用这个key计算出一个哈希值，再根据哈希值计算一个位置，并将位数组中这个位置的值设置为1.</li>
<li>询问key时，每个哈希函数都利用这个key计算出一个哈希值，再根据哈希值计算一个位置。然后对比这些哈希函数在位数组中对应位置的数值：<ul>
<li>如果这几个位置中，有一个位置的值是0，则说明一定不存在这个key。</li>
<li>如果这几个为之中，所有的位置都是1，则说明极有可能存在这个key。</li>
</ul>
</li>
</ul>
<h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><h2 id="1-Spring"><a href="#1-Spring" class="headerlink" title="1.Spring"></a>1.Spring</h2><h3 id="1-什么是Spirng"><a href="#1-什么是Spirng" class="headerlink" title="1.什么是Spirng"></a>1.什么是Spirng</h3><p>Spring 是一款开源的轻量级 Java 开发框架，旨在提高开发人员的开发效率以及系统的可维护性。</p>
<h3 id="2-列举一些重要的Spring框架"><a href="#2-列举一些重要的Spring框架" class="headerlink" title="2.列举一些重要的Spring框架"></a>2.列举一些重要的Spring框架</h3><p><strong>Spring Core</strong></p>
<p>核心模块， Spring 其他所有的功能基本都需要依赖于该类库，主要提供 IoC 依赖注入功能的支持。</p>
<p><strong>Spring Aspects</strong></p>
<p>该模块为与 AspectJ 的集成提供支持。</p>
<p><strong>Spring AOP</strong></p>
<p>提供了面向切面的编程实现。</p>
<p><strong>Spring Test</strong></p>
<p>Spring 团队提倡测试驱动开发（TDD）。有了控制反转 (IoC)的帮助，单元测试和集成测试变得更简单。</p>
<h3 id="3-Bean"><a href="#3-Bean" class="headerlink" title="3.Bean"></a>3.Bean</h3><h4 id="3-1什么是bean？"><a href="#3-1什么是bean？" class="headerlink" title="3.1什么是bean？"></a>3.1什么是bean？</h4><p>简单来说，bean 代指的就是那些被 IoC 容器所管理的对象。</p>
<p>我们需要告诉 IoC 容器帮助我们管理哪些对象，这个是通过配置元数据来定义的。配置元数据可以是 XML 文件、注解或者 Java 配置类。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Constructor-arg with &#x27;value&#x27; attribute --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>下图简单地展示了 IoC 容器如何使用配置元数据来管理对象。</p>
<p><img src="E:\学习笔记\图片\062b422bd7ac4d53afd28fb74b2bc94d.png"></p>
<p><code>org.springframework.beans</code>和 <code>org.springframework.context</code> 这两个包是 IoC 实现的基础，如果想要研究 IoC 相关的源码的话，可以去看看</p>
<h4 id="3-2-Component-和-Bean-的区别是什么？"><a href="#3-2-Component-和-Bean-的区别是什么？" class="headerlink" title="3.2.@Component 和 @Bean 的区别是什么？"></a>3.2.@Component 和 @Bean 的区别是什么？</h4><ol>
<li><code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</li>
<li><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径，从中找出标识了需要装配的类，自动装配到 Spring 的 bean 容器中）。<code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean，<code>@Bean</code>告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。</li>
<li><code>@Bean</code> 注解比 <code>@Component</code> 注解的自定义性更强，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</li>
</ol>
<h4 id="3-3-将一个类声明为-bean-的注解有哪些"><a href="#3-3-将一个类声明为-bean-的注解有哪些" class="headerlink" title="3.3.将一个类声明为 bean 的注解有哪些?"></a>3.3.将一个类声明为 bean 的注解有哪些?</h4><p>我们一般使用 <code>@Autowired</code> 注解自动装配 bean，要想把类标识成可用于 <code>@Autowired</code> 注解自动装配的 bean 的类,采用以下注解可实现：</p>
<ul>
<li><code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li>
<li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li>
<li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li>
<li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</li>
</ul>
<h4 id="3-4-Spring是如何管理Bean的？"><a href="#3-4-Spring是如何管理Bean的？" class="headerlink" title="3.4.Spring是如何管理Bean的？"></a>3.4.Spring是如何管理Bean的？</h4><p>Spring通过IOC容器来管理Bean。我们可以通过xml.配置或者注解配置，来指导IOC容器对Bean的管理。因为注解配置比XML配置方便很多，所以现在大多时候会使用注解配置的方式。 </p>
<h4 id="3-5-如何获取Bean"><a href="#3-5-如何获取Bean" class="headerlink" title="3.5.如何获取Bean"></a>3.5.如何获取Bean</h4><p> <strong>通常如何获取bean</strong>   </p>
<p>方法一：在初始化时保存ApplicationContext对象<br>方法二：通过Spring提供的utils类获取ApplicationContext对象<br>方法三：继承自抽象类ApplicationObjectSupport<br>方法四：继承自抽象类WebApplicationObjectSupport<br>方法五：实现接口ApplicationContextAware<br>方法六：通过Spring提供的ContextLoader</p>
<h4 id="3-6-bean-扫描路径"><a href="#3-6-bean-扫描路径" class="headerlink" title="3.6.bean 扫描路径"></a><strong>3.6.bean 扫描路径</strong></h4><p>1:默认扫描启动类所在路径下所有的bean</p>
<p>2：可以在启动类中添加注解,手动指定扫描路径：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.xxx.service1.*&quot;,&quot;com.xxx.service2.**&quot;&#125;)</span></span><br></pre></td></tr></table></figure>

<h4 id="3-7-bean-的作用域有哪些"><a href="#3-7-bean-的作用域有哪些" class="headerlink" title="3.7.bean 的作用域有哪些?"></a>3.7.bean 的作用域有哪些?</h4><p>Spring 中 Bean 的作用域通常有下面几种：</p>
<ul>
<li><strong>singleton</strong> : 唯一 bean 实例，Spring 中的 bean 默认都是单例的，对单例设计模式的应用。</li>
<li><strong>prototype</strong> : 每次请求都会创建一个新的 bean 实例。</li>
<li><strong>request</strong> : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li>
<li><strong>session</strong> : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li>
<li><strong>global-session</strong> ： 全局 session 作用域，仅仅在基于 portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码(例如：HTML)片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。</li>
</ul>
<p><strong>如何配置 bean 的作用域呢？</strong></p>
<p>xml 方式：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注解方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">personPrototype</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-8-bean-的生命周期"><a href="#3-8-bean-的生命周期" class="headerlink" title="3.8.bean 的生命周期?"></a>3.8.bean 的生命周期?</h4><blockquote>
<p>下面的内容整理自：<a target="_blank" rel="noopener" href="https://yemengying.com/2016/07/14/spring-bean-life-cycle/">https://yemengying.com/2016/07/14/spring-bean-life-cycle/</a> ，除了这篇文章，再推荐一篇很不错的文章 ：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zrtqsk/p/3735273.html">https://www.cnblogs.com/zrtqsk/p/3735273.html</a> 。</p>
</blockquote>
<ul>
<li>Bean 容器找到配置文件中 Spring Bean 的定义。</li>
<li>Bean 容器利用 Java Reflection API 创建一个 Bean 的实例。</li>
<li>如果涉及到一些属性值 利用 <code>set()</code>方法设置一些属性值。</li>
<li>如果 Bean 实现了 <code>BeanNameAware</code> 接口，调用 <code>setBeanName()</code>方法，传入 Bean 的名字。</li>
<li>如果 Bean 实现了 <code>BeanClassLoaderAware</code> 接口，调用 <code>setBeanClassLoader()</code>方法，传入 <code>ClassLoader</code>对象的实例。</li>
<li>如果 Bean 实现了 <code>BeanFactoryAware</code> 接口，调用 <code>setBeanFactory()</code>方法，传入 <code>BeanFactory</code>对象的实例。</li>
<li>与上面的类似，如果实现了其他 <code>*.Aware</code>接口，就调用相应的方法。</li>
<li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessBeforeInitialization()</code> 方法</li>
<li>如果 Bean 实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。</li>
<li>如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。</li>
<li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessAfterInitialization()</code> 方法</li>
<li>当要销毁 Bean 的时候，如果 Bean 实现了 <code>DisposableBean</code> 接口，执行 <code>destroy()</code> 方法。</li>
<li>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。</li>
</ul>
<p>图示：</p>
<p><img src="E:\学习笔记\图片\24bc2bad3ce28144d60d9e0a2edf6c7f.jpg" alt="Spring Bean 生命周期"></p>
<p>与之比较类似的中文版本:</p>
<p><img src="E:\学习笔记\图片\b5d264565657a5395c2781081a7483e1.jpg" alt="Spring Bean 生命周期"></p>
<h3 id="4-Spring是怎么解决循环依赖的？"><a href="#4-Spring是怎么解决循环依赖的？" class="headerlink" title="4.Spring是怎么解决循环依赖的？"></a>4.Spring是怎么解决循环依赖的？</h3><p>A在B之前执行</p>
<table>
<thead>
<tr>
<th>依赖情况</th>
<th>依赖注入方式</th>
<th>循环依赖是否被解决</th>
</tr>
</thead>
<tbody><tr>
<td>AB相互依赖（循环依赖）</td>
<td>均采用setter方法注入</td>
<td>是</td>
</tr>
<tr>
<td>AB相互依赖（循环依赖）</td>
<td>均采用构造器注入</td>
<td>否</td>
</tr>
<tr>
<td>AB相互依赖（循环依赖）</td>
<td>A中注入B的方式为setter方法，B中注入A的方式为构造器</td>
<td>是</td>
</tr>
<tr>
<td>AB相互依赖（循环依赖）</td>
<td>B中注入A的方式为setter方法，A中注入B的方式为构造器</td>
<td>否</td>
</tr>
</tbody></table>
<p>Spring对循环依赖的处理有三种情况：</p>
<ul>
<li><p><strong>全部通过构造器注入的循环依赖</strong>：无法处理，直接抛出异常，构造器注入无法利用缓存。</p>
</li>
<li><p><strong>setter方式原型 作用域为prototype</strong>：无法处理。（“prototype”作用域的Bean，每次都要创建新的对象，，Spring容器无法利用缓存，因此无法提前暴露一个创建中的Bean。）</p>
</li>
<li><p><strong>单例模式下的setter循环依赖</strong>：通过<strong>“三级缓存”</strong>处理。核心是利用一个map，map就相当于是一个缓存。</p>
<ul>
<li>singletonFactories：进入实例化阶段的单例对象工厂cache（三级缓存）</li>
<li>earlySingletonObjects：完成实例化但是未进行属性注入及初始化的，提前曝光的单例对象的cache（二级缓存）</li>
<li>singletonObjects：完成初始化的单例对象的cache（一级缓存）</li>
</ul>
<p><strong>情景</strong>：<strong>”A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象“</strong></p>
<p><img src="E:\学习笔记\图片\aHR0cHM6Ly9naXRlZS5jb20vd3hfY2MzNDdiZTY5Ni9ibG9nSW1hZ2UvcmF3L21hc3Rlci9pbWFnZS0yMDIwMDcwNjE2MTcwOTgyOS5wbmc.png" alt="image-20200706161709829"></p>
<ul>
<li>A完成初始化的第一步，并且将自己提前曝光到singletonFactories中，此时进行初始化的第二步，发现自己依赖对象B，此时就尝试去get(B)，发现B还没有被创建，所有走创建流程。</li>
<li>B在初始化第一步的时候发现自己依赖于A，尝试get(A)，依次尝试一二级缓存，都没有A，于是尝试三级缓存。由于A提前将自己曝光了，所以B能够顺利拿到A对象，这样B就可以完成初始化阶段，完全初始化之后将自己放入到一级缓存中。</li>
<li>此时返回A，A此时能拿到B的对象顺利完成自己的初始化阶段，加入一级缓存中。</li>
</ul>
</li>
</ul>
<h3 id="5-Autowires和-Resource注解的区别"><a href="#5-Autowires和-Resource注解的区别" class="headerlink" title="5.@Autowires和@Resource注解的区别"></a>5.@Autowires和@Resource注解的区别</h3><ul>
<li><p>@Autowired</p>
<ul>
<li><p>Spring提供的注解；</p>
</li>
<li><p>默认按类型注入（byType），然后会按名称注入（byName）；</p>
</li>
<li><p>按类型装配依赖对象，默认情况下他要求依赖对象必须存在，如果允许null，可以设置它required属性为false，如果想按名称装配，可以结合@Qualifier注解一起使用。</p>
<p>一个接口有多个实现类的情况下，byType会出现歧义，然后根据byName注入，假如找不到，则报错。</p>
<p><strong>解决方案</strong>：1.将注入的对象命名为实现类的名字</p>
<p>​					2.配合@Qualifier，指定要注入的对象的名字</p>
<p>​					3.配合@Primary，在一个类上面加@Primary，意思是当犹豫不决是那种各类型的时候，就会					选带了这个注解的</p>
</li>
</ul>
</li>
<li><p>@Resource</p>
<ul>
<li>JDK提供的注解</li>
<li>默认按名称注入（byName），也支持类型注入（byType）</li>
<li>有两个属性：name和type。如果没有指定name属性，当注解标注在字段&#x2F;属性的setter方法上，就按字段&#x2F;属性名来寻找依赖对象。</li>
<li>如果没有指定name属性，按照默认的名称找不到依赖对象时，会退回到按类型装配。但一旦指定了name，就只能按名称装配。</li>
</ul>
</li>
<li><p>当一个接口存在多个实现类的情况下，<code>@Autowired</code> 和<code>@Resource</code>都需要通过名称才能正确匹配到对应的 Bean。<code>Autowired</code> 可以通过 <code>@Qualifier</code> 注解来显示指定名称，<code>@Resource</code>可以通过 <code>name</code> 属性来显示指定名称。</p>
</li>
</ul>
<h3 id="6-谈谈自己对于-Spring-IoC-的了解"><a href="#6-谈谈自己对于-Spring-IoC-的了解" class="headerlink" title="6.谈谈自己对于 Spring IoC 的了解"></a>6.谈谈自己对于 Spring IoC 的了解</h3><p><strong>IoC（Inverse of Control:控制反转）</strong> 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。</p>
<ul>
<li><p>在不采用这种思想的情况下，我们需要自已维护对象与对象之间的依赖关系，很容易造成对象之间的耦合度过高,在一个大型的项目中这十分的不利于代码的维护。IOC则可以解决这种问题，它可以帮我们维护对象与对象之间的依赖关系，降低对象之间的耦合度。</p>
</li>
<li><p>说到IOC就不得不说DI，DI是 依赖注入的意思，它是IOC实现的实现方式，就是说IOC是通过DI来实现的。由于IOC这个词汇比较抽象而DI却更直观，所以很多时候我们就用DI来代替它，在很多时候我们简单地将IOC和DI划等号，这是一种习惯。而实现依赖注入的关键是IoC容器，它的本质就是一个工厂.</p>
</li>
<li><p><strong>控制</strong> ：指的是对象创建（实例化、管理）的权力</p>
</li>
<li><p><strong>反转</strong> ：控制权交给外部环境（Spring 框架、IoC 容器）</p>
</li>
</ul>
<p>IOC的实现方式是依赖注入：1.构造注入 2. setter方法注入 3.接口注入</p>
<p><img src="E:\学习笔记\图片\frc-365faceb5697f04f31399937c059c162.png"></p>
<p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。</p>
<p>在 Spring 中，IoC容器是 Spring 用来实现 IoC 的载体，IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。</p>
<p><img src="E:\学习笔记\图片\image-20220324160057902.png" alt="image-20220324160057902"></p>
<h3 id="7-谈谈自己对于-AOP-的了解"><a href="#7-谈谈自己对于-AOP-的了解" class="headerlink" title="7.谈谈自己对于 AOP 的了解"></a>7.谈谈自己对于 AOP 的了解</h3><p>AOP(Aspect-Oriented Programming:面向切面编程)是一种编程思想，面向对象编程将程序抽象成各个层次的对象，面向切面编程是将程序抽象成各个切面。</p>
<p>所谓切面，相当于对象间的横切点，我们可以将其抽象为单独的模块。在多个纵向（顺序）流程中出现相同的子流程代码，这些代码称为横切逻辑代码，也是切面。</p>
<p>能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p>
<p>Spring AOP 就是基于<strong>动态代理</strong>的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 <strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类（继承）来作为代理，如下图所示：</p>
<p><img src="E:\学习笔记\图片\926dfc549b06d280a37397f9fd49bf9d.jpg" alt="SpringAOPProcess"></p>
<p>当然也可以使用 <strong>AspectJ</strong> ！Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p>
<ul>
<li>PS：AOP的应用场景：<ul>
<li>通过AOP实现应用程序的日志功能；</li>
<li>在Spring内部，一些支持模块也是通过AOP来实现的，比如事务处理。</li>
</ul>
</li>
<li>AOP只能对IOC容器中的Bean进行增强，对于不受容器管理的对象不能增强。</li>
<li>由于CGlib采用动态创建子类的方式生成代理对象，所以不能对final修饰的类进行代理。</li>
</ul>
<h4 id="既然有CGlib，为什么Spring还要使用JDK动态代理呢？"><a href="#既然有CGlib，为什么Spring还要使用JDK动态代理呢？" class="headerlink" title="既然有CGlib，为什么Spring还要使用JDK动态代理呢？"></a><strong>既然有CGlib，为什么Spring还要使用JDK动态代理呢？</strong></h4><ul>
<li>CGlib创建对象的性能高，但是耗时长。</li>
<li>对于单例的对象无需频繁创建代理对象，采用CGlib比较合适。</li>
<li>而对于多例的对象，则选择JDK动态代理更合适。</li>
</ul>
<h4 id="AOP-领域中的特性术语："><a href="#AOP-领域中的特性术语：" class="headerlink" title="AOP 领域中的特性术语："></a><strong>AOP 领域中的特性术语：</strong></h4><ul>
<li><strong>通知</strong>（Advice）: AOP 框架中的增强处理。通知描述了切面何时执行以及如何执行增强处理。</li>
<li><strong>连接点</strong>（join point）: 连接点表示应用执行过程中能够插入切面的一个点，这个点可以是方法的调用、异常的抛出。在 Spring AOP 中，连接点总是方法的调用。</li>
<li><strong>切点</strong>（PointCut）: 可以插入增强处理的连接点。比如所有的controller，切点就是@Pointcut(“within(com.test.act.web..*) “)•切面（Aspect）: 切面是通知和切点的结合。</li>
<li><strong>引入</strong>（Introduction）：引入允许我们向现有的类添加新的方法或者属性。</li>
<li><strong>织入</strong>（Weaving）: 将增强处理添加到目标对象中，并创建一个被增强的对象，这个过程就是织入。</li>
</ul>
<h4 id="13-AOP的实现方式"><a href="#13-AOP的实现方式" class="headerlink" title="13.AOP的实现方式"></a>13.AOP的实现方式</h4><ul>
<li>JDK动态代理：这是Java提供的动态代理技术，可以在运行时创建接口的代理实例。Spring AOP默认采用这种方式，在接口的代理实例中织入代码。</li>
<li>CGLib动态代理：采用底层的字节码技术，在运行时创建子类代理的实例。当目标对象不存在接口时，Spring AOP就会采用这种方式，在子类实例中织入代码。</li>
</ul>
<h4 id="14-Spring-AOP-和-AspectJ-AOP-有什么区别？"><a href="#14-Spring-AOP-和-AspectJ-AOP-有什么区别？" class="headerlink" title="14.Spring AOP 和 AspectJ AOP 有什么区别？"></a>14.Spring AOP 和 AspectJ AOP 有什么区别？</h4><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p>
<p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p>
<p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多。</p>
<h3 id="8-Spring中一个请求经过拦截器、过滤器、Aop的顺序"><a href="#8-Spring中一个请求经过拦截器、过滤器、Aop的顺序" class="headerlink" title="8.Spring中一个请求经过拦截器、过滤器、Aop的顺序"></a>8.Spring中一个请求经过拦截器、过滤器、Aop的顺序</h3><p><strong>过滤器拦截的是URL请求，并没有定义业务逻辑执行的前后，仅仅是请求到达就执行。</strong></p>
<p><strong>拦截器拦截的是URL请求，有被拦截逻辑执行前后。</strong></p>
<p><strong>Aop能够针对具体的代码，实现更加复杂的业务逻辑。</strong></p>
<p>三者功能类似，但各有优势，从过滤器–》拦截器–》切面，拦截规则越来越细致，<strong>执行顺序依次是过滤器、拦截器、切面。</strong>一般情况下数据被过滤的时机越早对服务的性能影响越小，因此我们在编写相对比较公用的代码时，优先考虑过滤器，然后是拦截器，最后是aop。比如权限校验，一般情况下，所有的请求都需要做登陆校验，此时就应该使用过滤器在最顶层做校验；日志记录，一般日志只会针对部分逻辑做日志记录，而且牵扯到业务逻辑完成前后的日志记录，因此使用过滤器不能细致地划分模块，此时应该考虑拦截器，然而拦截器也是依据URL做规则匹配，因此相对来说不够细致，因此我们会考虑到使用AOP实现，AOP可以针对代码的方法级别做拦截，很适合日志功能。</p>
<h3 id="9-Spring-框架中用到了哪些设计模式？"><a href="#9-Spring-框架中用到了哪些设计模式？" class="headerlink" title="9.Spring 框架中用到了哪些设计模式？"></a>9.Spring 框架中用到了哪些设计模式？</h3><p>关于下面一些设计模式的详细介绍，可以看笔主前段时间的原创文章<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485303&idx=1&sn=9e4626a1e3f001f9b0d84a6fa0cff04a&chksm=cea248bcf9d5c1aaf48b67cc52bac74eb29d6037848d6cf213b0e5466f2d1fda970db700ba41&token=255050878&lang=zh_CN#rd">《面试官:“谈谈 Spring 中都用到了那些设计模式?”。》</a> 。</p>
<ul>
<li><strong>工厂设计模式</strong> : Spring 使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li>
<li><strong>代理设计模式</strong> : Spring AOP功能的实现。</li>
<li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li>
<li><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li>
<li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li>
<li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li>
<li><strong>适配器模式</strong> : Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li>
<li>……</li>
</ul>
<p><strong>代理模式和装饰者模式</strong></p>
<p>让别人帮助你做你并不关心的事情，叫<strong>代理模式</strong></p>
<p>为让自己的能力增强，使得增强后的自己能够使用更多的方法，拓展在自己基础之上的功能的，叫<strong>装饰器模式</strong></p>
<p>1、装饰器模式强调的是增强自身，在被装饰之后你能够在被增强的类上使用增强后的功能。增强后你还是你，只不过能力更强了而已；代理模式强调要让别人帮你去做一些本身与你业务没有太多关系的职责（记录日志、设置缓存）。代理模式是为了实现对象的控制，因为被代理的对象往往难以直接获得或者是其内部不想暴露出来。</p>
<p>2、装饰模式是以对客户端透明的方式扩展对象的功能，是继承方案的一个替代方案；代理模式则是给一个对象提供一个代理对象，并由代理对象来控制对原有对象的引用；</p>
<p>3、装饰模式是为装饰的对象增强功能；而代理模式对代理的对象施加控制，但不对对象本身的功能进行增强；</p>
<h3 id="10-工厂设计模式"><a href="#10-工厂设计模式" class="headerlink" title="10.工厂设计模式"></a>10.工厂设计模式</h3><p>Spring使用工厂模式可以通过 <code>BeanFactory</code> 或 <code>ApplicationContext</code> 创建 bean 对象。</p>
<p><strong>两者对比：</strong></p>
<ul>
<li><code>BeanFactory</code> ：延迟注入(使用到某个bean的时候才会注入),相比于<code>ApplicationContext</code> 来说会占用更少的内存，程序启动速度更快。</li>
<li><code>ApplicationContext</code> ：容器启动的时候，不管你用没用到，一次性创建所有 bean 。<code>BeanFactory</code> 仅提供了最基本的依赖注入支持，<code> ApplicationContext</code> 扩展了 <code>BeanFactory</code> ,除了有<code>BeanFactory</code>的功能还有额外更多功能，所以一般开发人员使用<code> ApplicationContext</code>会更多。</li>
</ul>
<p>ApplicationContext的三个实现类：</p>
<ol>
<li><code>ClassPathXmlApplication</code>：把上下文文件当成类路径资源。</li>
<li><code>FileSystemXmlApplication</code>：从文件系统中的 XML文件载入上下文定义信息。</li>
<li><code>XmlWebApplicationContext</code>：从Web系统中的XML文件载入上下文定义信息。</li>
</ol>
<h3 id="11-单例模式"><a href="#11-单例模式" class="headerlink" title="11.单例模式"></a>11.单例模式</h3><p>属于创建类型的一种常用的软件设计模式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<p><strong>Spring 通过 <code>ConcurrentHashMap</code> 实现单例注册表的特殊方式实现单例模式。</strong></p>
<p><strong>注意：</strong></p>
<ul>
<li>1、单例类只能有一个实例。</li>
<li>2、单例类必须自己创建自己的唯一实例。</li>
<li>3、单例类必须给所有其他对象提供这一实例。</li>
</ul>
<h3 id="12-Spring自动装配"><a href="#12-Spring自动装配" class="headerlink" title="12.Spring自动装配"></a>12.Spring自动装配</h3><p>一个Java类中，假如依赖其他的对象（Bean类型的属性），那么就去容器中寻找这个Bean，然后自动注入到当前的实例中。</p>
<h3 id="22-模板方法"><a href="#22-模板方法" class="headerlink" title="22.模板方法"></a>22.模板方法</h3><p>模板方法模式是一种行为设计模式，它定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。 模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤的实现方式。</p>
<p>Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。一般情况下，我们都是使用继承的方式来实现模板模式，但是 Spring 并没有使用这种方式，而是使用Callback 模式与模板方法模式配合，既达到了代码复用的效果，同时增加了灵活性。</p>
<h3 id="23-Spring-事务"><a href="#23-Spring-事务" class="headerlink" title="23.Spring 事务"></a>23.Spring 事务</h3><p>Spring&#x2F;SpringBoot 模块下专门有一篇是讲 Spring 事务的，总结的非常详细，通俗易懂。</p>
<h4 id="Spring-管理事务的方式有几种？"><a href="#Spring-管理事务的方式有几种？" class="headerlink" title="Spring 管理事务的方式有几种？"></a>Spring 管理事务的方式有几种？</h4><ul>
<li><strong>编程式事务</strong> ： 在代码中硬编码(不推荐使用) : 通过 <code>TransactionTemplate</code>或者 <code>TransactionManager</code> 手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。</li>
<li><strong>声明式事务</strong> ： 在 XML 配置文件中配置或者直接基于注解（推荐使用） : 实际是通过 AOP 实现（基于<code>@Transactional</code> 的全注解方式使用最多）</li>
</ul>
<h4 id="Spring-事务中哪几种事务传播行为"><a href="#Spring-事务中哪几种事务传播行为" class="headerlink" title="Spring 事务中哪几种事务传播行为?"></a>Spring 事务中哪几种事务传播行为?</h4><p><strong>事务传播行为是为了解决业务层方法之间互相调用的事务问题</strong>。</p>
<p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</p>
<p>正确的事务传播行为可能的值如下:</p>
<p><strong>1.<code>TransactionDefinition.PROPAGATION_REQUIRED</code></strong></p>
<p>使用的最多的一个事务传播行为，我们平时经常使用的<code>@Transactional</code>注解默认使用就是这个事务传播行为。如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</p>
<p><strong><code>2.TransactionDefinition.PROPAGATION_REQUIRES_NEW</code></strong></p>
<p>创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，<code>Propagation.REQUIRES_NEW</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</p>
<p><strong>3.<code>TransactionDefinition.PROPAGATION_NESTED</code></strong></p>
<p>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于<code>TransactionDefinition.PROPAGATION_REQUIRED</code>。</p>
<p><strong>4.<code>TransactionDefinition.PROPAGATION_MANDATORY</code></strong></p>
<p>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</p>
<p>这个使用的很少。</p>
<p>若是错误的配置以下 3 种事务传播行为，事务将不会发生回滚：</p>
<ul>
<li><strong><code>TransactionDefinition.PROPAGATION_SUPPORTS</code></strong>: 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li><strong><code>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</code></strong>: 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li><strong><code>TransactionDefinition.PROPAGATION_NEVER</code></strong>: 以非事务方式运行，如果当前存在事务，则抛出异常。</li>
</ul>
<h4 id="Spring-事务中的隔离级别有哪几种"><a href="#Spring-事务中的隔离级别有哪几种" class="headerlink" title="Spring 事务中的隔离级别有哪几种?"></a>Spring 事务中的隔离级别有哪几种?</h4><p>和事务传播行为这块一样，为了方便使用，Spring 也相应地定义了一个枚举类：<code>Isolation</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Isolation</span> &#123;</span><br><span class="line"></span><br><span class="line">    DEFAULT(TransactionDefinition.ISOLATION_DEFAULT),</span><br><span class="line"></span><br><span class="line">    READ_UNCOMMITTED(TransactionDefinition.ISOLATION_READ_UNCOMMITTED),</span><br><span class="line"></span><br><span class="line">    READ_COMMITTED(TransactionDefinition.ISOLATION_READ_COMMITTED),</span><br><span class="line"></span><br><span class="line">    REPEATABLE_READ(TransactionDefinition.ISOLATION_REPEATABLE_READ),</span><br><span class="line"></span><br><span class="line">    SERIALIZABLE(TransactionDefinition.ISOLATION_SERIALIZABLE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    Isolation(<span class="type">int</span> value) &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我依次对每一种事务隔离级别进行介绍：</p>
<ul>
<li><strong><code>TransactionDefinition.ISOLATION_DEFAULT</code></strong> :使用后端数据库默认的隔离级别，MySQL 默认采用的 <code>REPEATABLE_READ</code> 隔离级别 Oracle 默认采用的 <code>READ_COMMITTED</code> 隔离级别.</li>
<li><strong><code>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</code></strong> :最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></li>
<li><strong><code>TransactionDefinition.ISOLATION_READ_COMMITTED</code></strong> : 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li>
<li><strong><code>TransactionDefinition.ISOLATION_REPEATABLE_READ</code></strong> : 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li>
<li><strong><code>TransactionDefinition.ISOLATION_SERIALIZABLE</code></strong> : 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<h4 id="Transactional-rollbackFor-x3D-Exception-class-注解了解吗？"><a href="#Transactional-rollbackFor-x3D-Exception-class-注解了解吗？" class="headerlink" title="@Transactional(rollbackFor &#x3D; Exception.class)注解了解吗？"></a>@Transactional(rollbackFor &#x3D; Exception.class)注解了解吗？</h4><p><code>Exception</code> 分为运行时异常 <code>RuntimeException</code> 和非运行时异常。事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。</p>
<p>当 <code>@Transactional</code> 注解作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。</p>
<p>在 <code>@Transactional</code> 注解中如果不配置<code>rollbackFor</code>属性,那么事务只会在遇到<code>RuntimeException</code>的时候才会回滚，加上 <code>rollbackFor=Exception.class</code>,可以让事务在遇到非运行时异常时也回滚。</p>
<h3 id="24-Spring-框架中用到了哪些设计模式"><a href="#24-Spring-框架中用到了哪些设计模式" class="headerlink" title="24.Spring 框架中用到了哪些设计模式"></a>24.Spring 框架中用到了哪些设计模式</h3><ul>
<li><strong>工厂设计模式</strong> : Spring 使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li>
<li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li>
<li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li>
<li><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li>
<li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li>
<li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li>
<li><strong>适配器模式</strong> : Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li>
</ul>
<h3 id="25-AOP、拦截器、过滤器"><a href="#25-AOP、拦截器、过滤器" class="headerlink" title="25.AOP、拦截器、过滤器"></a>25.AOP、拦截器、过滤器</h3><h4 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h4><p><strong>过滤器</strong>：基于 Servlet，通过函数回调方式实现，可以过滤请求和图片文件等，每个请求一个过滤器只能过滤一次。</p>
<p><strong>拦截器</strong>：基于 java 的反射机制，代理模式实现，只能拦截请求，可以访问上下文等对象，功能强大，一个请求可多次拦截。</p>
<p>拦截器是 Spring 中AOP的一种实现方法。另一种方法通过 Pointcut、Advice实现</p>
<h4 id="1）AOP"><a href="#1）AOP" class="headerlink" title="1）AOP"></a>1）AOP</h4><p>AOP是面向切面编程，AOP的基本单元是Aspect(切面)</p>
<h4 id="2）拦截器"><a href="#2）拦截器" class="headerlink" title="2）拦截器"></a>2）拦截器</h4><p>拦截器是在Service或者一个方法前调用一个方法，或者在方法后调用一个方法。比如动态代理就是拦截器的简单实现，在你调用方法前打印出字符串（或者做其它业务逻辑的操作），也可以在你调用方法后打印出字符串，甚至在你抛出异常的时候做业务逻辑的操作。</p>
<p><strong>特点</strong></p>
<ul>
<li>拦截器是基于java反射机制实现的</li>
<li>拦截器是spring特有的，能使用Spring里的任何资源、对象，例如Service对象、数据源、事务管理等</li>
<li>拦截器既可以用于Web程序，也可以用于Application、Swing程序中</li>
<li>拦截器能够深入到方法前后、异常抛出前后，伸缩性较大</li>
</ul>
<h4 id="3）过滤器"><a href="#3）过滤器" class="headerlink" title="3）过滤器"></a>3）过滤器</h4><p>Filter 过滤器是 JavaWeb 的三大组件之一。（Servlet、Filter、Listener）；Filter 过滤器它是 JavaEE 的规范，可以<strong>在浏览器以及目标资源之间起到一个过滤的作用</strong>，它的<strong>作用</strong>是：拦截请求，过滤响应；</p>
<p><strong>web 中的过滤器</strong>：当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。Filter过滤器主要用来过滤用户的请求，允许用户对请求进行前置处理和后置处理，比如实现 URL 级别的权限控制、过滤非法请求等等。</p>
<p><strong>特点</strong></p>
<ul>
<li>Filter是基于回调函数</li>
<li>Filter是Servlet规范固定的，只能用于Web程序中</li>
<li>Filter在只在Servlet启动前后起作用，范围较窄</li>
</ul>
<h4 id="4）过滤器与拦截器的联系与区别"><a href="#4）过滤器与拦截器的联系与区别" class="headerlink" title="4）过滤器与拦截器的联系与区别"></a>4）过滤器与拦截器的联系与区别</h4><ul>
<li>拦截器是基于java的反射机制，使用代理模式，而过滤器是基于函数回调。</li>
<li>拦截器不依赖servlet容器，过滤器依赖于servlet容器。</li>
<li>拦截器只能对action起作用，而过滤器可以对几乎所有的请求起作用（可以保护资源）。</li>
<li>拦截器可以访问action上下文，堆栈里面的对象，而过滤器不可以。</li>
<li>执行顺序：过滤前-拦截前-Action处理-拦截后-过滤后。</li>
</ul>
<h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><p><strong>过滤器 → 拦截器 → 切面</strong></p>
<h2 id="2-Spring-MVC"><a href="#2-Spring-MVC" class="headerlink" title="2.Spring MVC"></a>2.Spring MVC</h2><h3 id="1-说说自己对于-Spring-MVC-的了解"><a href="#1-说说自己对于-Spring-MVC-的了解" class="headerlink" title="1.说说自己对于 Spring MVC 的了解?"></a>1.说说自己对于 Spring MVC 的了解?</h3><p><strong>Spring MVC 是 Spring 提供的一个基于 MVC 设计模式的轻量级 Web 开发框架</strong></p>
<p>MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p>
<p>早期：整个 Web 应用几乎全部用 JSP 页面组成，只用少量的 JavaBean 来处理数据库连接、访问等操作。控制逻辑和表现逻辑混杂在一起，导致代码重用率极低。</p>
<p>后来：“Java Bean(Model)+ JSP（View）+Servlet（Controller） 模式，但是抽象和封装程度还远远不够，可维护性和重用性不高。</p>
<p>最后出现MVC， 使用更加简单和方便，开发效率更高，并且 Spring MVC 运行速度更快。一般把后端项目分为 Service 层（处理业务）、Dao 层（数据库操作）、Entity 层（实体类）、Controller 层(控制层，返回数据给前台页面)。</p>
<p>MVC是一种设计的思想，是多种设计模式的组合（组合模式、观察者模式、策略模式）</p>
<p><strong>组合模式</strong></p>
<p>​	组合模式只在视图层活动， 视图层的实现用的就是组合模式，这里指的实现是底层的实现，是由编程框架厂商做的事情，用不着普通程序员插手。</p>
<p>​	组合模式的类层次结构是树状的， 而我们做Web时视图层是html页面，html的结构正是树状，这其实就是一个组合模式的应用，只是浏览器厂商已经把界面相关的工作帮我们做掉了，但它确确实实是我们应用MVC的其中一部分，只是我们感觉不到罢了，这也是我们觉得View是实现起来最简单最没有歧义的一层的原因。</p>
<p>​	除网页以外的其他用户界面程序，如WPF、Android、<a href="https://link.zhihu.com/?target=http://ASP.NET">http://ASP.NET</a>等等都是使用树状结构来组织界面控件对象的，因为组合模式就是从界面设计的通用解决方案总提炼出来的。</p>
<p><strong>观察者模式</strong></p>
<p>观察者模式有两部分组成，被观察的对象和观察者，观察者也被称为监听者。<strong>对应到MVC中，Model是被观察的对象，View是观察者，Model层一旦发生变化，View层即被通知更新。</strong>View层和Model层互相之间是持有引用的。</p>
<p><strong>观察者模式</strong></p>
<p>策略模式是View和Controller之间的关系，Controller是View的一个策略，Controller对于View是可替换的， View和Controller的关系是一对多，在实际的开发场景中，也经常会碰到一个View被多个Controller引用</p>
<p>总结一下，关于MVC各层之间关系所对应的设计模式</p>
<p>View层，单独实现了组合模式</p>
<p>Model层和View层，实现了观察者模式</p>
<p>View层和Controller层，实现了策咯模式</p>
<h4 id="2-MVC和三层架构的区别"><a href="#2-MVC和三层架构的区别" class="headerlink" title="2.MVC和三层架构的区别"></a>2.MVC和三层架构的区别</h4><h5 id="1-MVC设计模式："><a href="#1-MVC设计模式：" class="headerlink" title="1.MVC设计模式："></a>1.MVC设计模式：</h5><p><img src="E:\学习笔记\图片\20190603152425689.png" alt="img"></p>
<h4 id="视图View"><a href="#视图View" class="headerlink" title="视图View"></a>视图View</h4><p>负责页面的显示，与用户的交互。包含各种表单。 实现视图用到的技术有html&#x2F;css&#x2F;jsp&#x2F;js等前端技术。</p>
<p>用户交互：用户鼠标点击页面；填写页面中各种表单……..等等</p>
<h4 id="模型Model"><a href="#模型Model" class="headerlink" title="模型Model"></a>模型Model</h4><p>模型负责各个功能的实现（如登录、增加、删除功能）。模型用JavaBean实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">JavaBeans :</span><br><span class="line"></span><br><span class="line">1.是Java中一种特殊的类（换言之：JavaBean就是一个Java类）.</span><br><span class="line"></span><br><span class="line">一个Java类 ，满足以下要求，则可称为一个JavaBean</span><br><span class="line"></span><br><span class="line">  a. public修饰的类，提供public 无参构造方法</span><br><span class="line"></span><br><span class="line">  b. 所有属性 都是private</span><br><span class="line"></span><br><span class="line">  c. 提供getter和setter方法 </span><br><span class="line"></span><br><span class="line">2.从使用层面来看，JavaBean分为2大类：</span><br><span class="line"></span><br><span class="line">  a. 封装业务逻辑的JavaBean （eg:LoginDao.java 封装了登录逻辑）</span><br><span class="line"></span><br><span class="line">  b. 封装数据的JavaBean （实体类：eg：Student.java  Vedio.java 。往往对应于数据库中的一张表，即数据库中有个Student表，项目中就有个Student.java类）</span><br><span class="line"></span><br><span class="line">3.JavaBean 是一个可以重复使用的组件，通过编写一个组件来实现某种通用功能，“一次编写、任何地方执行、任何地方重用”。</span><br></pre></td></tr></table></figure>

<h4 id="控制器Controller"><a href="#控制器Controller" class="headerlink" title="控制器Controller"></a>控制器Controller</h4><p>控制器负责将视图与模型一一对应起来。相当于一个模型分发器。所谓分发就是：①接收请求，并将该请求跳转（转发，重定向）到模型进行处理。②模型处理完毕后，再通过控制器，返回给视图中的请求处。建议使用Servlet实现控制器。</p>
<h5 id="2-三层架构："><a href="#2-三层架构：" class="headerlink" title="2.三层架构："></a>2.三层架构：</h5><p>首先来说，三层架构与MVC的目标一致：都是为了解耦和、提高代码复用。MVC是一种设计模式，而三层架构是一种软件架构。</p>
<p>三层架构分为：<strong>表现层（UI）(web层)<strong>、</strong>业务逻辑层（BLL）(service层)<strong>、</strong>数据访问层（DAL）(dao层)</strong> ，再加上<strong>实体类库（Model）</strong></p>
<p>1.实体类库（Model），在Java中，往往将其称为Entity实体类。数据库中用于存放数据，而我们通常选择会用一个专门的类来抽象出数据表的结构，类的属性就一对一的对应这表的属性。</p>
<p>·一般来说，Model实体类库层需要被DAL层，BIL层和UI层引用。</p>
<p>2.数据访问层（DAL），主要是存放对数据类的访问，即对数据库的添加、删除、修改、更新等基本操作</p>
<p> ·DAL就是根据业务需求，构造SQL语句，构造参数，调用帮助类，获取结果，DAL层被BIL层调用</p>
<p>3.业务逻辑层（BLL）</p>
<p>BLL层好比是桥梁，将UI表示层与DAL数据访问层之间联系起来。所要负责的，就是处理涉及业务逻辑相关的问题，比如在调用访问数据库之前，先处理数据、判断数据。</p>
<p>BLL层只被UIL层引用</p>
<p>用户表现层（UIL）,就是用户看到的主界面。<br>                        各层引用关系如下图所示：</p>
<p><img src="E:\学习笔记\图片\2019060316210156.png" alt="img"></p>
<p>MVC与三层架构的对应关系，图示如下：</p>
<p><img src="E:\学习笔记\图片\20190603151709124.png" alt="img"></p>
<h3 id="2-Spring-MVC执行流程"><a href="#2-Spring-MVC执行流程" class="headerlink" title="2.Spring MVC执行流程"></a>2.Spring MVC执行流程</h3><p><img src="E:\学习笔记\图片\de6d2b213f112297298f3e223bf08f28.png"></p>
<p><strong>流程说明（重要）：</strong></p>
<ol>
<li>客户端（浏览器）发送请求，直接请求到 <code>DispatcherServlet</code>。</li>
<li><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的 <code>Handler</code>。</li>
<li>解析到对应的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器）后，开始由 <code>HandlerAdapter</code> 适配器处理。</li>
<li><code>HandlerAdapter</code> 会根据 <code>Handler</code>来调用真正的处理器开处理请求，并处理相应的业务逻辑。</li>
<li>处理器处理完业务后，会返回一个 <code>ModelAndView</code> 对象，<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li>
<li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</li>
<li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</li>
<li>把 <code>View</code> 返回给请求者（浏览器）</li>
</ol>
<h3 id="Service、-Controller是线程安全的吗"><a href="#Service、-Controller是线程安全的吗" class="headerlink" title="@Service、@Controller是线程安全的吗"></a>@Service、@Controller是线程安全的吗</h3><p>不是，怎么解决，设置scope，且有变量的话，同Theadlocal修饰</p>
<h2 id="3-SpringBoot"><a href="#3-SpringBoot" class="headerlink" title="3.SpringBoot"></a>3.SpringBoot</h2><h3 id="1-Spring-boot-相对-Spring有什么优势"><a href="#1-Spring-boot-相对-Spring有什么优势" class="headerlink" title="1.Spring boot 相对 Spring有什么优势"></a>1.Spring boot 相对 Spring有什么优势</h3><p>传统Spirng的弊端</p>
<ul>
<li>Spring事物管理，MVC，启用第三方库都需要XML或Java进行显示配置，配置过重</li>
<li>写配置挤占了实际写应用的逻辑的时间</li>
<li>项目依赖管理，要考虑用那些库，还要知道哪些版本和库不会有冲突，影响开发效率</li>
</ul>
<p>Spring boot的优势</p>
<ul>
<li>自动配置：针对很多Spring常见的应用功能，SpringBoot能自动提供相关配置</li>
<li>起步依赖：告诉SpringBoot需要什么功能，它就能引入需要的库，提供的<code>starters</code> 简化构建配置</li>
<li>CLI命令行界面：通过SpringBootCLI,借此你只需写代码就能完成完整的应用程序，无须传统项目构建</li>
<li>Actuator: 提供在运行时检视应用程序内部情况的能力创建独立的<code>Spring</code>应用。</li>
<li>嵌入式<code>Tomcat</code>、<code>Jetty</code>、 <code>Undertow</code>容器（无需部署war文件）。</li>
</ul>
<h3 id="2-自动装配的原理"><a href="#2-自动装配的原理" class="headerlink" title="2.自动装配的原理"></a>2.自动装配的原理</h3><h4 id="1-什么是-SpringBoot-自动装配？"><a href="#1-什么是-SpringBoot-自动装配？" class="headerlink" title="1.什么是 SpringBoot 自动装配？"></a>1.什么是 SpringBoot 自动装配？</h4><p>SpringBoot 定义了一套接口规范，这套规范规定：SpringBoot 在启动时会扫描外部引用 jar 包中的<code>META-INF/spring.factories</code>文件，将文件中配置的类型信息加载到 Spring 容器（此处涉及到 JVM 类加载机制与 Spring 的容器知识），并执行类中定义的各种操作。对于外部 jar 来说，只需要按照 SpringBoot 定义的标准，就能将自己的功能装置进 SpringBoot。</p>
<p><strong>没有 Spring Boot 的情况下</strong>，如果我们需要引入第三方依赖，需要手动配置，非常麻烦。但是，Spring Boot 中，我们直接引入一个 starter 即可。</p>
<h4 id="2-SpringBoot-是如何实现自动装配的？如何实现按需加载？"><a href="#2-SpringBoot-是如何实现自动装配的？如何实现按需加载？" class="headerlink" title="2.SpringBoot 是如何实现自动装配的？如何实现按需加载？"></a>2.SpringBoot 是如何实现自动装配的？如何实现按需加载？</h4><p><img src="E:\学习笔记\图片\image-20220504024438186.png" alt="image-20220504024438186"></p>
<p> 通过SpringBoot 的核心注解 <code>SpringBootApplication</code> 。</p>
<p><code>@SpringBootApplication</code>可以看作是 <strong><code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code></strong> 注解的集合。根据 SpringBoot 官网，这三个注解的作用分别是：</p>
<ul>
<li><code>@EnableAutoConfiguration</code>：启用 SpringBoot 的自动配置机制，是实现自动装配的核心注解。</li>
<li><code>@Configuration</code>：允许在上下文中注册额外的 bean 或导入其他配置类</li>
<li><code>@ComponentScan</code>： 扫描被<code>@Component</code> (<code>@Service</code>,<code>@Controller</code>)注解的 bean，放入Bean容器，注解默认会扫描启动类所在的包下所有的类 ，可以自定义不扫描某些 bean。如下图所示，容器中将排除<code>TypeExcludeFilter</code>和<code>AutoConfigurationExcludeFilter</code>。</li>
</ul>
<h4 id="3-EnableAutoConfiguration-实现自动装配的核心注解"><a href="#3-EnableAutoConfiguration-实现自动装配的核心注解" class="headerlink" title="3.@EnableAutoConfiguration:实现自动装配的核心注解"></a>3.@EnableAutoConfiguration:实现自动装配的核心注解</h4><p><strong>调用过程</strong></p>
<p><code>EnableAutoConfiguration</code> —&gt;<code>AutoConfigurationImportSelector</code>—&gt;<code>ImportSelector</code>—&gt;<code>selectImports</code>—&gt;<code>getAutoConfigurationEntry()</code></p>
<p>1.<code>EnableAutoConfiguration</code> 只是一个简单地注解，自动装配核心功能的实现实际是通过 <code>AutoConfigurationImportSelector</code>类。</p>
<p>2.<code>AutoConfigurationImportSelector</code> 类实现了 <code>ImportSelector</code>接口，也就实现了这个接口中的 <code>selectImports</code>方法，该方法主要用于<strong>获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中</strong>。</p>
<p>3.<code>selectImports</code>方法中调用了<code>getAutoConfigurationEntry()</code>方法，这个方法主要负责加载自动配置类的。通过此方法将自动配置类加载进容器。</p>
<h4 id="4-自动装配过程"><a href="#4-自动装配过程" class="headerlink" title="4.自动装配过程"></a>4.自动装配过程</h4><p><strong>第 1 步</strong>:</p>
<p>判断自动装配开关是否打开。</p>
<p><strong>第 2 步</strong> ：</p>
<p>用于获取<code>EnableAutoConfiguration</code>注解中的 <code>exclude</code> 和 <code>excludeName</code>。</p>
<p><strong>第 3 步</strong></p>
<p>获取需要自动装配的所有配置类，读取<code>META-INF/spring.factories</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring-boot/spring-boot-project/spring-boot-autoconfigure/src/main/resources/META-INF/spring.factories</span><br></pre></td></tr></table></figure>

<p><strong>第 4 步</strong> ：</p>
<p>到这里可能面试官会问你:“<code>spring.factories</code>中这么多配置，每次启动都要全部加载么？”。</p>
<p>经历了一遍筛选，<code>@ConditionalOnXXX</code> 中的所有条件都满足，该类才会生效。</p>
<p>Spring Boot 提供的条件注解(<strong>简单了解</strong>)</p>
<ul>
<li><code>@ConditionalOnBean</code>：当容器里有指定 Bean 的条件下</li>
<li><code>@ConditionalOnMissingBean</code>：当容器里没有指定 Bean 的情况下</li>
<li><code>@ConditionalOnSingleCandidate</code>：当指定 Bean 在容器中只有一个，或者虽然有多个但是指定首选 Bean</li>
<li><code>@ConditionalOnClass</code>：当类路径下有指定类的条件下</li>
<li><code>@ConditionalOnMissingClass</code>：当类路径下没有指定类的条件下</li>
<li><code>@ConditionalOnProperty</code>：指定的属性是否有指定的值</li>
<li><code>@ConditionalOnResource</code>：类路径是否有指定的值</li>
<li><code>@ConditionalOnExpression</code>：基于 SpEL 表达式作为判断条件</li>
<li><code>@ConditionalOnJava</code>：基于 Java 版本作为判断条件</li>
<li><code>@ConditionalOnJndi</code>：在 JNDI 存在的条件下差在指定的位置</li>
<li><code>@ConditionalOnNotWebApplication</code>：当前项目不是 Web 项目的条件下</li>
<li><code>@ConditionalOnWebApplication</code>：当前项目是 Web 项 目的条件下</li>
</ul>
<h4 id="5-如何实现一个-Starter？"><a href="#5-如何实现一个-Starter？" class="headerlink" title="5.如何实现一个 Starter？"></a>5.如何实现一个 Starter？</h4><p>第一步，创建<code>threadpool-spring-boot-starter</code>工程</p>
<p><img src="E:\学习笔记\图片\1ff0ebe7844f40289eb60213af72c5a6_tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
<p>第二步，引入 Spring Boot 相关依赖</p>
<p><img src="E:\学习笔记\图片\5e14254276604f87b261e5a80a354cc0_tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
<p>第三步，创建<code>ThreadPoolAutoConfiguration</code></p>
<p><img src="E:\学习笔记\图片\1843f1d12c5649fba85fd7b4e4a59e39_tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
<p>第四步，在<code>threadpool-spring-boot-starter</code>工程的 resources 包下创建<code>META-INF/spring.factories</code>文件</p>
<p><img src="E:\学习笔记\图片\97b738321f1542ea8140484d6aaf0728_tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
<p>最后新建工程引入<code>threadpool-spring-boot-starter</code></p>
<p><img src="E:\学习笔记\图片\edcdd8595a024aba85b6bb20d0e3fed4_tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
<p>测试通过！！！</p>
<p><img src="E:\学习笔记\图片\9a265eea4de742a6bbdbbaa75f437307_tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
<h4 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h4><p>Spring Boot 通过<code>@EnableAutoConfiguration</code>开启自动装配，通过 SpringFactoriesLoader 最终加载<code>META-INF/spring.factories</code>中的自动配置类实现自动装配，自动配置类其实就是通过<code>@Conditional</code>按需加载的配置类，想要其生效必须引入<code>spring-boot-starter-xxx</code>包实现起步依赖</p>
<h3 id="3-spring-boot的启动流程"><a href="#3-spring-boot的启动流程" class="headerlink" title="3.spring boot的启动流程"></a>3.spring boot的启动流程</h3><p><img src="E:\学习笔记\图片\20200806150352650.png" alt="img"></p>
<p>主要分为三个部分：</p>
<p>第一部分进行SpringApplication的初始化模块，配置一些基本的环境变量、资源、构造器、监听器；</p>
<p>第二部分实现了应用具体的启动方案，包括启动流程的监听模块、加载配置环境模块、及核心的创建上下文环境模块；</p>
<p>第三部分是自动化配置模块。</p>
<p>每个SpringBoot程序都有一个主入口，也就是main方法，main里面调用SpringApplication.run()启动整个spring-boot程序，该方法所在类需要使用@SpringBootApplication注解。</p>
<p>进入run（）方法，生成一个SpringApplication对象，对象中有初始化的initialize方法初始化web容器，并加载一些初始化值（主要包括：1. 初始化资源加载器；2. 初始化主要资源加载类集合并去重;3. 得到当前WEB应用类型；4. 设置应用上下文初始化器；5. 设置监听器），得到主应用程序启动类，之后去执行run方法。</p>
<p>1.创建计时器，开始计时</p>
<p>2.配置系统属性（Headless）</p>
<p>3.初始化监听器</p>
<p>4.调用监听方法starting</p>
<p>5.加载命令行的参数值</p>
<p>6.创建并配置应用环境</p>
<p>7.配置忽略Bean信息</p>
<p>8.打印Banner信息</p>
<p>9.创建应用上下文</p>
<p>10.获取异常报告器</p>
<p>11.准备（配置）应用上下文</p>
<p>12.刷新应用上下文</p>
<p>13.刷新完成后的后置处理</p>
<p>14.停止计时</p>
<p>15.调用监听方法started</p>
<p>16.加载自定义初始化信息</p>
<p>17.调用监听方法running</p>
<h2 id="4-SpringCloud"><a href="#4-SpringCloud" class="headerlink" title="4.SpringCloud"></a>4.SpringCloud</h2><p><code>Spring Cloud</code> 就是微服务系统架构的一站式解决方案，在平时我们构建微服务的过程中需要做如 <strong>服务发现注册</strong> 、<strong>配置中心</strong> 、<strong>消息总线</strong> 、<strong>负载均衡</strong> 、<strong>断路器</strong> 、<strong>数据监控</strong> 等操作，而 Spring Cloud 为我们提供了一套简易的编程模型，使我们能在 Spring Boot 的基础上轻松地实现微服务项目的构建。</p>
<h3 id="1-服务注册与发现"><a href="#1-服务注册与发现" class="headerlink" title="1.服务注册与发现"></a>1.服务注册与发现</h3><p>CAP原则又称CAP定理，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）。 CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。</p>
<ul>
<li><strong>Zookeeper保证的是CP</strong></li>
</ul>
<p>zookeeper中，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。问题在于，选举leader的时间太长，30～120s，且<strong>选举期间整个zk集群都是不可用的，这就导致在选举期间注册服务瘫痪</strong>。在云部署的环境下，因为网络问题使得zk集群失去master节点是较大概率会发生的事件，虽然服务最终能够恢复，但是漫长的选举时间导致的注册长期不可用是不能容忍的。</p>
<ul>
<li><strong>Eureka保证的是AP</strong></li>
</ul>
<p>Eureka设计时优先保证可用性。Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册时，如果发现连接失败，则会自动切换至其他节点，只要有一台Eureka还在，就能保住注册服务的可用性，只不过查到的信息可能不是最新的，除此之外，Eureka还有一种自我保护机制，如果在15分钟内超过85％的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况：</p>
<p>​	1．Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务</p>
<p>​	2．Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其他节点上（即保证当前节点依然可用）</p>
<p>​	3．当网络稳定时，当前实例新的注册信息会被同步到其他节点中</p>
<p>因此，Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪</p>
<h3 id="2-负载均衡"><a href="#2-负载均衡" class="headerlink" title="2.负载均衡"></a>2.负载均衡</h3><p>负载均衡（Load Balance），在微服务或分布式集群中经常用的一种应用。简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA（高可用）。</p>
<p>负载均衡简单分类：</p>
<ul>
<li><p>集中式LB</p>
<p>即在服务的消费方和提供方之间使用独立的LB设施，如Nginx，由该设施负责把访问请求通过某种策略转发至服务的提供方！</p>
</li>
<li><p>进程式LB</p>
<p>将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选出一个合适的服务器。</p>
</li>
</ul>
<h3 id="3-调用微服务的两种方法"><a href="#3-调用微服务的两种方法" class="headerlink" title="3.调用微服务的两种方法"></a>3.调用微服务的两种方法</h3><p>1．通过微服务名字【ribbon】</p>
<p>2．通过接口和注解【feign】</p>
<h4 id="Ribbon和Feign的区别"><a href="#Ribbon和Feign的区别" class="headerlink" title="Ribbon和Feign的区别"></a>Ribbon和Feign的区别</h4><p>Spring Cloud Ribbon是基于Netflix Ribbon实现的一套<strong>客户端</strong>负载均衡的工具。</p>
<p>Ribbon和Feign都是用于调用其他服务的，不过方式不同。Feign采用的是基于接口的注解Feign整合了Ribbon</p>
<p>1.启动类使用的注解不同，Ribbon用的是@RibbonClient，Feign用的是@EnableFeignClients。</p>
<p>2.服务的指定位置不同，Ribbon是在@RibbonClient注解上声明，Feign则是在定义抽象方法的接口中使用@FeignClient声明。</p>
<p>3.调用方式不同，Ribbon需要自己构建http请求，模拟http请求然后使用RestTemplate发送给其他服务，步骤相当繁琐。</p>
<p> Feign则是在Ribbon的基础上进行了一次改进，采用接口的方式，将需要调用的其他服务的方法定义成抽象方法即可，</p>
<p> 不需要自己构建http请求。不过要注意的是抽象方法的注解、方法签名要和提供服务的方法完全一致。</p>
<h3 id="4-Hystrix"><a href="#4-Hystrix" class="headerlink" title="4.Hystrix"></a>4.Hystrix</h3><p>Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时，异常等，<strong>Hystrix能够</strong>保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以<strong>提高分布式系统的弹性</strong>。<br>“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个服务预期的，可处理的备选响应（FallBack），而不是长时间的等待或者抛出调用方法无法处理的异常，这样就可以保证了服务调用方的线程不会被长时间，不必要的占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。</p>
<p>功能：</p>
<ul>
<li><p>服务降级</p>
</li>
<li><p>服务熔断</p>
<p>当扇出链路中某个微服务不可用或者响应超时，则对该微服务进行服务降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后恢复调用链路。熔断机制的注解为 <code>@HystrixCommand</code></p>
</li>
<li><p>服务限流</p>
</li>
<li><p>接近实时的监控</p>
</li>
<li><p>……</p>
</li>
</ul>
<h3 id="5-Zuul"><a href="#5-Zuul" class="headerlink" title="5.Zuul"></a>5.Zuul</h3><p>Zuul包含了对请求的路由和过滤两个最主要的功能：<br>其中路由功能负责将外部请求转发到具体的微服务实例上，是实现外部访问统一入口的基础，而过滤器功能则负责对请求的处理过程进行干预，是实现请求校验，服务聚合等功能的基础。Zuul和Eureka进行整合，将Zuul自身注册为Eureka服务治理下的应用，同时从Eureka中获得其他微服务的消息，也即以后的访问微服务都是通过Zuul跳转后获得。<br><strong>注意</strong>：Zuul服务最终还是会注册进Eureka</p>
<h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><h3 id="1-什么是-Mybatis？"><a href="#1-什么是-Mybatis？" class="headerlink" title="1 什么是 Mybatis？"></a>1 什么是 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Mybatis&spm=1001.2101.3001.7020">Mybatis</a>？</h3><ol>
<li>Mybatis 是一个半 ORM（对象关系映射）框架，它内部封装了 JDBC，开发时只需要关注 SQL 语句本身，不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。程序员直接编写原生态 sql，可以严格控制 sql 执行性能，灵活度高</li>
<li>MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO 映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集</li>
<li>通过 xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过 java 对象和 statement 中 sql 的动态参数进行映射生成最终执行的 sql 语句，最后由 mybatis 框架执行 sql 并将结果映射为 java 对象并返回（从执行 sql 到返回 result 的过程）</li>
</ol>
<h3 id="2-Mybaits-的优点"><a href="#2-Mybaits-的优点" class="headerlink" title="2 Mybaits 的优点?"></a>2 Mybaits 的优点?</h3><ol>
<li>基于 SQL 语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL 写在 XML 里，解除 sql 与程序代码的耦合，便于统一管理；提供 XML 标签，支持编写动态 SQL 语句，并可重用</li>
<li>与 JDBC 相比，减少了50%以上的代码量，消除了 JDBC 大量冗余的代码，不需要手动开关连接</li>
<li>很好的与各种数据库兼容（因为 MyBatis 使用 JDBC 来连接数据库，所以只要 JDBC 支持的数据库 MyBatis 都支持）</li>
<li>能够与 Spring 很好的集成</li>
<li>提供映射标签，支持对象与数据库的 ORM 字段关系映射；提供对象关系映射标签，支持对象关系组件维护</li>
</ol>
<h3 id="3-MyBatis-框架的缺点"><a href="#3-MyBatis-框架的缺点" class="headerlink" title="3 MyBatis 框架的缺点?"></a>3 MyBatis 框架的缺点?</h3><ol>
<li>SQL 语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写 SQL 语句的功底有一定要求</li>
<li>SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库</li>
</ol>
<h2 id="structs"><a href="#structs" class="headerlink" title="structs"></a>structs</h2><p>springmvc 和 struts 的区别<br>spring mvc 是单例的 ，线程安全。strtus2基于类的属性进行发的，定义属性可以整个类通用，是多例的。在和Spring一起使用的时候，Action交给Spring进行管理，默认的就是单例，所以才会有人说Struts2默认是单例的。<br>所以在Spring整合Struts2开发时，如果需要用使用Struts2多例，就在spring的action bean配置的时候设置scope&#x3D;”prototype”。一个请求对应一个实例，线程是安全的。<br>springmvc 的核心是dispactcherServlet ，strtus 的核心控制器是filterdispather。<br>spring mvc 是基于方法操作数据，strtus 是基于类操作数据。<br>spring mvc 接收数据是根据方法的参数来接收，strtus 接收数据是根据类里的属性接收，<br>spring mvc 使用起来更简单，struts使用起来复杂。<br>spring mvc的请求路径根据注解和视图解析器就可以确定。status 的请求路径是根据strus 的配置文件里的 action 标签来确定的。</p>
<h2 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h2><p>Hibernate 是 Gavin King 和他的开发团队在 2001 年推出一个开源免费的、基于 ORM 技术的 Java 持久化框架。</p>
<h3 id="Hibernate和Mybatis的对比"><a href="#Hibernate和Mybatis的对比" class="headerlink" title="Hibernate和Mybatis的对比"></a>Hibernate和Mybatis的对比</h3><h4 id="Hibernate是全自动，而Mybatis是半自动（最大的区别）"><a href="#Hibernate是全自动，而Mybatis是半自动（最大的区别）" class="headerlink" title="Hibernate是全自动，而Mybatis是半自动（最大的区别）"></a>Hibernate是全自动，而Mybatis是半自动（最大的区别）</h4><p>​	hibernate完全可以通过对象关系模型实现对数据库的操作，拥有完整的JavaBean对象与数据库的映射结构来自动生成sql。</p>
<p>​	mybatis仅有基本的字段映射，对象数据以及对象实际关系仍然需要通过手写sql来实现和管理。</p>
<h4 id="开发难度对比"><a href="#开发难度对比" class="headerlink" title="开发难度对比"></a><strong>开发难度对比</strong></h4><p>　　Hibernate的开发难度大于MyBatis，主要由于Hibernate比较复杂，庞大，学习周期比较长。</p>
<p>　　MyBatis则相对简单，并且MyBatis主要依赖于sql的书写，让开发者刚进更熟悉。</p>
<h4 id="数据库移植性比较"><a href="#数据库移植性比较" class="headerlink" title="数据库移植性比较"></a><strong>数据库移植性比较</strong></h4><p>　　Hibernate与数据库具体的关联在XML中，所以HQL对具体是用什么数据库并不是很关心</p>
<p>　　MyBatis由于所有sql都是依赖数据库书写的，所以扩展性、迁移性比较差。</p>
<h4 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h4><p>​	Hibernate具有自己的日志统计。涉及广泛，包括：sql记录、关系异常、优化警告、缓存提示、脏数据警告等；</p>
<p>​	Mysql没有自己的日志统计，所以要借助Log4j来记录日志。</p>
<h4 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h4><p>​	MyBatis的二级缓存配置都是在每个具体的表-对象映射中进行详细配置，这样针对不同的表可以自定义不同的缓存机制。并且Mybatis可以在命名空间中共享相同的缓存配置和实例，通过Cache-ref来实现。</p>
<p>​	而Hibernate对查询对象有着良好的管理机制，用户无需关心SQL。所以在使用二级缓存时如果出现脏数据，系统会报出错误并提示。</p>
<h4 id="SQL优化-1"><a href="#SQL优化-1" class="headerlink" title="SQL优化"></a>SQL优化</h4><p>由于mybatis的sql都是写在xml里，因此优化sql比hibernate方便很多。而hibernate的sql很多都是自动生成的，无法直接维护sql。</p>
<h2 id="K8S"><a href="#K8S" class="headerlink" title="K8S"></a>K8S</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li><strong>自我修复</strong>：一旦某一个容器崩溃，能够在1秒左右迅速启动新的容器</li>
<li><strong>弹性伸缩</strong>：可以根据需要，自动对集群中正在运行的容器数量进行调整</li>
<li><strong>服务发现</strong>：服务可以通过自动发现的形式找到它所依赖的服务</li>
<li><strong>负载均衡</strong>：如果一个服务启动了多个容器，能够自动实现请求的负载均衡</li>
<li><strong>版本回退</strong>：如果发现新发布的程序版本有问题，可以立即回退到原来的版本</li>
<li><strong>存储编排</strong>：可以根据容器自身的需求自动创建存储卷</li>
</ul>
<h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><h3 id="Netty是什么？"><a href="#Netty是什么？" class="headerlink" title="Netty是什么？"></a>Netty是什么？</h3><p>Netty是一款<strong>异步</strong>的事件驱动的<strong>网络应用程序框架</strong>，支持快速地开发可维护的<strong>高性能</strong>的<strong>面向协议</strong>的服务器和客户端。</p>
<h3 id="为什么要使用Netty"><a href="#为什么要使用Netty" class="headerlink" title="为什么要使用Netty"></a>为什么要使用Netty</h3><p>在分布式场景下，很多服务被部署在多台服务器上，服务之间的调用开销增大（之前的场景下，例如原来用户下一个订单需要登录，浏览产品详情，加入购物车，支付，扣库存等一系列操作，在单体应用的时候它们<strong>都在一台机器的同一个进程中，说白了就是模块之间的函数调用，效率超级高</strong>），现在通过<strong>远程调用</strong>，而Netty是基于NIO的网络框架，能够高效的处理请求调用，因此很多RPC框架中使用Netty作为基础通信组件。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>Netty对NIO的API进行了封装，通过以下手段让性能又得到了一定程度的提升</p>
<ol>
<li>使用多路复用技术，提高处理连接的并发性</li>
<li>零拷贝：<ul>
<li>Netty的接收和发送数据采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝<img src="E:\学习笔记\图片\640-1663573406027.png" alt="图片"><img src="E:\学习笔记\图片\640.png" alt="图片"></li>
<li>Netty提供了组合Buffer对象，可以聚合多个ByteBuffer对象进行一次操作</li>
<li>Netty的文件传输采用了transferTo方法，它可以直接将文件缓冲区的数据发送到目标Channel，避免了传统通过循环write方式导致的内存拷贝问题</li>
</ul>
</li>
<li>内存池：为了减少堆外直接内存的分配和回收产生的资源损耗问题，Netty提供了基于内存池的缓冲区重用机制</li>
<li>使用主从Reactor多线程模型，提高并发性</li>
<li>采用了串行无锁化设计，在IO线程内部进行串行操作，避免多线程竞争导致的性能下降</li>
<li>默认使用Protobuf的序列化框架</li>
<li>灵活的TCP参数配置</li>
</ol>
<h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><p>Netty的零拷贝主要体现在五个方面</p>
<ol>
<li>Netty的接收和发送ByteBuf使用直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。如果使用JVM的堆内存进行Socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中，然后才写入Socket中。相比于使用直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。</li>
<li>Netty的文件传输调用FileRegion包装的transferTo方法，可以直接将文件缓冲区的数据发送到目标Channel，避免通过循环write方式导致的内存拷贝问题。</li>
<li>Netty提供CompositeByteBuf类, 可以将多个ByteBuf合并为一个逻辑上的ByteBuf, 避免了各个ByteBuf之间的拷贝。</li>
<li>通过wrap操作, 我们可以将byte[]数组、ByteBuf、ByteBuffer等包装成一个Netty ByteBuffer对象, 进而避免拷贝操作。</li>
<li>ByteBuf支持slice操作，可以将ByteBuf分解为多个共享同一个存储区域的ByteBuf, 避免内存的拷贝。</li>
</ol>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="0-JVM运行时数据区域"><a href="#0-JVM运行时数据区域" class="headerlink" title="0. JVM运行时数据区域"></a>0. JVM运行时数据区域</h2><img src="E:/面试/myJava.assets/Untitled 10.png" alt="Untitled" style="zoom:67%;" />

<p><strong>1. 虚拟机栈</strong></p>
<ul>
<li>线程私有。</li>
<li>生命周期与线程相同。</li>
<li>为虚拟机执行Java方法服务。</li>
<li><strong>虚拟机栈中执行每个方法的时候，都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用到结束就对应于一个栈桢在虚拟机栈中的入栈和出栈过程。</strong></li>
<li>会出现OOM（内存溢出）。</li>
<li>会有StackOverFlowError（栈溢出)。</li>
</ul>
<p>【注】：局部变量表存放了编译器可知的各种Java虚拟机基本数据类型、对象引用、returnAddress类型。</p>
<p><strong>2. 本地方法栈</strong></p>
<p>本地方法一般由C&#x2F;C++、汇编编写，被编译为基于本机硬件或操作系统的程序。</p>
<ul>
<li>线程私有</li>
<li>与虚拟机栈的作用类似。</li>
<li>为虚拟机使用到的本地方法服务。</li>
<li>会出现OOM。</li>
<li>StackOverFlowError。</li>
</ul>
<p><strong>3. Java堆</strong></p>
<ul>
<li>线程共享；</li>
<li>JVM内存中最大的一块；</li>
<li>在虚拟机启动时创建；</li>
<li>唯一目的：存放对象实例（非静态成员变量存在这）；所有的对象实例以及数组都应当在堆上分配；</li>
<li><strong>是GC的主要区域</strong>；通常分为年轻代和老年代；</li>
<li>会有OOM。</li>
<li>不需要连续的内存</li>
</ul>
<p><strong>4. 方法区</strong></p>
<ul>
<li>线程共享；</li>
<li>存储已被虚拟机加载的类型信息（就是<strong>类</strong>）、<strong>常量</strong>、<strong>静态变量</strong>(<strong>static</strong>)、即时编译器编译后的代码缓存等数据。</li>
<li>运行时常量池：是方法区的一部分。Class文件中的常量池表（用于存放编译器生成的各种字面量与符号引用）。这部分内容将在类加载后存放到方法区的运行时常量池中。</li>
<li>JDK1.8开始，方法区被移至元空间，位于本地内存，元空间存储类的元信息，静态变量和常量池等放入堆中。</li>
</ul>
<p><strong>5.程序计数器</strong></p>
<ul>
<li>线程私有；</li>
<li>记录 正在执行的虚拟机字节码指令的地址；通过改变计数器的值来确定下一条指令；</li>
<li>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地方法，这个计数器值则应为空。</li>
<li><strong>不会出现OOM</strong>。（唯一一个）</li>
</ul>
<p><strong>6. Java中的堆和栈有什么区别？</strong></p>
<ul>
<li><strong>栈</strong>内存主要用来存放基本数据类型与引用变量。</li>
<li><strong>栈</strong>内存的管理是通过压栈和弹栈操作来完成的，以栈帧为基本单位来管理程序的调用关系，每当有函数调用时，都会通过压栈方式创建新的栈帧，每当函数调用结束后都会通过弹栈的方式释放栈帧。</li>
<li><strong>堆</strong>内存用来存放运行时创建的对象。</li>
<li>一般来讲，通过new关键字创建出来的对象都存放在<strong>堆</strong>内存中。由于JVM是基于堆栈的虚拟机，而每个Java程序都运行在一个单独的JVM实例上，每一个实例唯一对应一个堆，一个Java程序内的多个线程也就运行在同一个JVM。</li>
</ul>
<h2 id="1-JVM包含哪几部分？"><a href="#1-JVM包含哪几部分？" class="headerlink" title="1. JVM包含哪几部分？"></a>1. JVM包含哪几部分？</h2><ul>
<li>类加载器</li>
<li>运行时数据区（内存分区）</li>
<li>执行引擎</li>
<li>本地库接口</li>
</ul>
<img src="E:/面试/myJava.assets/image-20220504025446361.png" alt="image-20220504025446361" style="zoom: 50%;" />

<h2 id="2-JVM是如何运行的？"><a href="#2-JVM是如何运行的？" class="headerlink" title="2. JVM是如何运行的？"></a>2. JVM是如何运行的？</h2><ul>
<li><ol>
<li>JVM装入运行环境和配置——找jre——自己目录→父级目录→注册中的</li>
</ol>
</li>
<li><ol start="2">
<li>装载JVM</li>
</ol>
</li>
<li><ol start="3">
<li>初始化JVM，获得本地调用接口</li>
</ol>
</li>
<li><ol start="4">
<li>运行Java程序——运行方式：jar和class</li>
</ol>
</li>
</ul>
<h2 id="3-Java程序是怎么运行的？"><a href="#3-Java程序是怎么运行的？" class="headerlink" title="3. Java程序是怎么运行的？"></a>3. Java程序是怎么运行的？</h2><ul>
<li><strong>编译</strong>：写好的源代码文件经过Java编译器编译成字节码文件后，</li>
<li><strong>加载</strong>：通过类加载器加载到内存中，才能被实例化，</li>
<li><strong>解释</strong>：然后到Java虚拟机中解释执行，</li>
<li><strong>执行</strong>：最后通过操作系统CPU执行获取结果。</li>
</ul>
<p>概括来说，写好的 Java 源代码文件经过 Java 编译器编译成字节码文件后，通过类加载器加载到内存中，才能被实例化，然后到 Java 虚拟机中解释执行，最后通过操作系统操作 CPU 执行获取结果。</p>
<p><img src="E:\学习笔记\图片\image-20220504021408271.png" alt="image-20220504021408271"></p>
<h2 id="4-本地方法栈有什么用？"><a href="#4-本地方法栈有什么用？" class="headerlink" title="4. 本地方法栈有什么用？"></a>4. 本地方法栈有什么用？</h2><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。</p>
<p>《Java虚拟机规范》对本地方法栈中方法使用的语言、使用方式与数据结构并没有任何强制规定，因此具体的虚拟机可以根据需要自由实现它，甚至有的Java虚拟机（譬如Hot-Spot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。</p>
<h2 id="5-没有程序计数器会怎么样？"><a href="#5-没有程序计数器会怎么样？" class="headerlink" title="5. 没有程序计数器会怎么样？"></a>5. 没有程序计数器会怎么样？</h2><p><strong>程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器，即正在执行的指令地址。</strong>在Java虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<p>没有程序计数器，Java程序中的流程控制将无法得到正确的控制，多线程也无法正确的轮换。</p>
<p>由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p>
<p>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。</p>
<h2 id="6-Java代码的编译过程——1个准备过程、3个处理过程"><a href="#6-Java代码的编译过程——1个准备过程、3个处理过程" class="headerlink" title="6. Java代码的编译过程——1个准备过程、3个处理过程"></a>6. Java代码的编译过程——1个准备过程、3个处理过程</h2><p>从Javac代码的总体结构来看，编译过程大致可以分为1个准备过程和3个处理过程，它们分别如下所示。</p>
<ol>
<li><p>准备过程：初始化插入式注解处理器。</p>
</li>
<li><p>解析与填充符号表过程，包括：</p>
<ul>
<li>词法、语法分析，将源代码的字符流转变为标记集合，构造出抽象语法树。</li>
<li>填充符号表，产生符号地址和符号信息。</li>
</ul>
</li>
<li><p>插入式注解处理器的注解处理过程：</p>
<p>在Javac源码中，插入式注解处理器的初始化过程是在initPorcessAnnotations()方法中完成的，而它的执行过程则是在processAnnotations()方法中完成。这个方法会判断是否还有新的注解处理器需要执行，如果有的话，通过JavacProcessing-Environment类的doProcessing()方法来生成一个新的JavaCompiler对象，对编译的后续步骤进行处理。</p>
</li>
<li><p>分析与字节码生成过程，包括：</p>
<ul>
<li>标注检查，对语法的静态信息进行检查。</li>
<li>数据流及控制流分析，对程序动态运行过程进行检查。</li>
<li>解语法糖，将简化代码编写的语法糖还原为原有的形式。</li>
<li>字节码生成，将前面各个步骤所生成的信息转化成字节码。</li>
</ul>
</li>
</ol>
<p>上述3个处理过程里，执行插入式注解时又可能会产生新的符号，如果有新的符号产生，就必须转回到之前的解析、填充符号表的过程中重新处理这些新符号，从总体来看，三者之间的关系与交互顺序如图所示。</p>
<p><img src="E:\学习笔记\图片\image-20220504021709622.png" alt="image-20220504021709622"></p>
<h2 id="7-类加载过程"><a href="#7-类加载过程" class="headerlink" title="7. 类加载过程"></a>7. 类加载过程</h2><p>![Untitled](E:\学习笔记\图片\Untitled 13.png)</p>
<p>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个部分统称为连接（Linking）。</p>
<p><strong>前5个阶段为类加载过程</strong>。</p>
<ul>
<li><p><strong>1.  加载</strong></p>
<ul>
<li>通过一个类的<strong>全限定名</strong>来获取定义此类的<strong>二进制字节流</strong>。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的<strong>运行时数据结构</strong>。</li>
<li>在内存中生成一个代表这个类的<code>java.lang.Class</code> 对象<strong>，作为方法区这个类的各种数据的</strong>访问入口。</li>
<li>加载阶段结束后，Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了，方法区中的数据存储格式完全由虚拟机实现自行定义</li>
</ul>
</li>
<li><p><strong>2.  验证</strong></p>
<ul>
<li>文件格式验证——验证<strong>字节流class</strong>是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。</li>
<li>元数据验证——对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求。</li>
<li>字节码验证——通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。</li>
<li>符号引用验证——可以看作是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。</li>
</ul>
</li>
<li><p><strong>3.准备</strong></p>
<ul>
<li><p>为类变量（即静态变量，被static修饰的变量）分配内存并设置初始值，初始值为0，放进方法区中。</p>
</li>
<li><p>被final修饰的常量，初始为指定的值。</p>
</li>
<li><p>实例变量在此阶段不会分配内存，在实例化时（并非类加载阶段），放进堆里。</p>
</li>
<li><p>从概念上讲，这些变量所使用的内存都应当在方法区中进行分配，但必须注意到方法区本身是一个逻辑上的区域，在JDK7及之前，HotSpot使用永久代来实现方法区时，实现是完全符合这种逻辑概念的。而在JDK 8及之后，类变量则会随着Class对象一起存放在Java堆中，这时候“类变量在方法区”就完全是一种对逻辑概念的表述了。</p>
</li>
</ul>
</li>
<li><p><strong>4.  解析</strong>——JVM将<strong>常量池内的符号引用替换为直接引用</strong>的过程</p>
<ul>
<li>PS：<strong>符号引用</strong>（Symbolic References）：**被final修饰的常量，初始为指定的值。(逻辑概念)**，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中。</li>
<li>PS：<strong>直接引用</strong>（Direct References）：<strong>直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。（物理概念）</strong>直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。</li>
</ul>
</li>
<li><p><strong>5.  初始化</strong></p>
<ul>
<li><p>类的初始化阶段是类加载过程的最后一个步骤，之前介绍的几个类加载的动作里，除了在加载阶段用户应用程序可以通过自定义类加载器的方式局部参与外，其余动作都完全由Java虚拟机来主导控制。<strong>直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将主导权移交给应用程序。</strong></p>
</li>
<li><p>进行准备阶段时，变量已经赋过一次系统要求的初始零值，而<strong>在初始化阶段，则会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。</strong>我们也可以从另外一种更直接的形式来表达：<strong>初始化阶段就是执行类构造器&lt;clinit&gt;()方法的过程。</strong>&lt;clinit&gt;()并不是程序员在Java代码中直接编写的方法，它是Javac编译器的自动生成物。</p>
</li>
<li><p><strong>Java程序初始化顺序</strong></p>
<p>1、父类的静态变量<br>2、父类的静态代码块<br>3、子类的静态变量<br>4、子类的静态代码块<br>5、父类的非静态变量<br>6、父类的非静态代码块<br>7、父类的构造方法<br>8、子类的非静态变量<br>9、子类的非静态代码块<br>10、子类的构造方法</p>
</li>
</ul>
</li>
</ul>
<h2 id="8-对象是如何被创建的"><a href="#8-对象是如何被创建的" class="headerlink" title="8. 对象是如何被创建的"></a>8. 对象是如何被创建的</h2><p>在jvm中的加载流程如下所示：</p>
<p><img src="E:\学习笔记\图片\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2oxMjMxMjMw,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>Step1：类加载检查</strong></p>
<p>JVM 虚拟机遇到⼀条 new 指令时，⾸先会检查在常量池中是否可以定位到这个类的符号引⽤（比如 org.simple.Person），并且检查这个符号引⽤代表的类是否已被加载、解析和初始化过。</p>
<p>如果没有，那必须先执⾏相应的类加载过程。</p>
<p>Step2：分配内存</p>
<p>当类加载完成后，就可以确定对象所需的内存大小了。给对象分配内存。</p>
<p>Step3：初始化零值</p>
<p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）。</p>
<p>这⼀步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使⽤，也就是说，程序能访问到这些字段的数据类型所对应的零值。</p>
<p>Step4：设置对象头</p>
<p>初始化零值完成之后，虚拟机要对对象进⾏必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息，这些信息都存放在对象头中。</p>
<p>另外，根据虚拟机当前运⾏状态的不同，如是否启⽤偏向锁等，对象头会有不同的设置⽅式。</p>
<p>Step5：执行 init 方法</p>
<p>此时从虚拟机的视⻆来看，⼀个新的对象已经产⽣了，但从 Java 程序的视⻆来看，对象创建才刚开始， ⽅法还没有执⾏，所有的字段都还为零。</p>
<p>所以⼀般来说，执⾏ new 指令之后会接着执⾏初始化方法，把对象按照程序员的意愿进⾏初始化，这样⼀个真正可⽤的对象才算完全创建成功。</p>
<h2 id="9-元空间和永久代、元空间在栈内还是栈外？"><a href="#9-元空间和永久代、元空间在栈内还是栈外？" class="headerlink" title="9. 元空间和永久代、元空间在栈内还是栈外？"></a>9. 元空间和永久代、元空间在栈内还是栈外？</h2><p>元空间和永久代都是方法区的实现方式，在jdk 1.8中取消了永久代的概念，引入了元空间。</p>
<p>区别：永久代位于虚拟机栈中，而元空间位于本地内存，存放类的元信息。</p>
<p>为什么取消永久代？</p>
<p>1.永久代的大小不好确定，容易出现OOM，容易触发full gc，元空间位于本地内存，不会满</p>
<p>2.永久代会随着full fc发生移动，增加full gc的复杂度。</p>
<p><strong>栈外</strong>。元空间占用的是本地内存。</p>
<ul>
<li>注：JDK8之后，用元空间代替了永久代。</li>
</ul>
<h2 id="10-JVM的类加载器？"><a href="#10-JVM的类加载器？" class="headerlink" title="10. JVM的类加载器？"></a>10. JVM的类加载器？</h2><p>JVM设计的时候，把类加载阶段中的“<strong>通过一个类的全限定名来获取描述该类的二进制字节流</strong>”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为“<strong>类加载器</strong>”。</p>
<p>对于任意一个类，都必须由<strong>类加载器和这个类本身</strong>一起共同确立其在Java虚拟机中的唯一性，每一个类加载器都拥有一个独立的类命名空间。</p>
<h2 id="11-类的初始化时机"><a href="#11-类的初始化时机" class="headerlink" title="11.类的初始化时机"></a>11.类的初始化时机</h2><h3 id="类的主动引用会引起初始化"><a href="#类的主动引用会引起初始化" class="headerlink" title="类的主动引用会引起初始化"></a>类的主动引用会引起初始化</h3><ol>
<li>new一个类的对象</li>
<li>调用类<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F&spm=1001.2101.3001.7020">静态变量</a>，和静态方法</li>
<li>对类进行<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%8F%8D%E5%B0%84&spm=1001.2101.3001.7020">反射</a>调用</li>
<li>启动main方法所在的类</li>
<li>当初始化一个类，如果其父类没有被初始化，则先会初始化他的父类</li>
</ol>
<h3 id="类的被动引用不会引起初始化"><a href="#类的被动引用不会引起初始化" class="headerlink" title="类的被动引用不会引起初始化"></a>类的被动引用不会引起初始化</h3><ol>
<li>子类调用父类的静态变量，子类不会被初始化，只有父类被初始化。对于静态字段，只有直接定义这个字段的类才会被初始化。</li>
<li>通过数组定义来引用类，不会触发类的初始化</li>
<li>访问类的常量，不会初始化类（常量在编译阶段就存入调用类的常量池中了）</li>
</ol>
<h2 id="12-方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？"><a href="#12-方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？" class="headerlink" title="12.方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？"></a>12.方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</h2><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong> ：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的 <code>ClassLoader</code> 已经被回收。</li>
<li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p>
<h2 id="11-双亲委派机制？"><a href="#11-双亲委派机制？" class="headerlink" title="11. 双亲委派机制？"></a>11. 双亲委派机制？</h2><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ul>
<li><p><strong>启动类加载器（引导类加载器）</strong>：加载存放在<JAVA_HOME>\lib目录，或者指定路径存放的可识别的类库。无法被Java程序直接引用，是用原生代码（C语言）来实现的，并不继承自 java.lang.ClassLoader。</p>
</li>
<li><p><strong>扩展类加载器</strong>：加载<JAVA_HOME>\lib\ext目录或指定路径的所有类库。开发者可以直接在程序中使用扩展类加载器加载Class文件。</p>
</li>
<li><p><strong>应用程序加载器</strong>：加载用户类路径(ClassPath)上所有的类库。开发者可以直接在代码中使用这个类加载器。程序中默认的类加载器。</p>
</li>
<li><p><strong>自定义类加载器</strong><br>（1）开发人员可以通过继承 java.lang.ClassLoader类的方式实现自己的类加载器，以满足一些特殊的需求。</p>
<h4 id="java-class-ClassLoader类"><a href="#java-class-ClassLoader类" class="headerlink" title="java.class.ClassLoader类"></a>java.class.ClassLoader类</h4><p><strong>（1）作用：</strong></p>
<ul>
<li>java.lang.ClassLoader类的基本职责就是根据一个指定的类的名称，找到或者生成其对应的字节代码，然后从这些字节代码中定义出一个Java类，即java.lang.Class类的一个实例。</li>
<li>ClassLoader还负责加载 Java 应用所需的资源，如图像文件和配置文件等</li>
</ul>
<p><strong>（2）常用方法：</strong></p>
<ul>
<li>getParent() 返回该类加载器的父类加载器。</li>
<li>loadClass(String name) 加载名称为 name的类，返回的结果是java.lang.Class类的实例。<br><strong>此方法负责加载指定名字的类，首先会从已加载的类中去寻找，如果没有找到；从parent ClassLoader[ExtClassLoader]中加载；如果没有加载到，则从Bootstrap ClassLoader中尝试加载(findBootstrapClassOrNull方法), 如果还是加载失败，则自己加载。如果还不能加载，则抛出异常ClassNotFoundException。</strong></li>
<li>findClass(String name) 查找名称为 name的类，返回的结果是java.lang.Class类的实例。</li>
<li>findLoadedClass(String name) 查找名称为 name的已经被加载过的类，返回的结果是 java.lang.Class类的实例。</li>
</ul>
</li>
</ul>
<img src="E:/面试/myJava.assets/image-20220504025254409.png" alt="image-20220504025254409" style="zoom: 40%;" />

<p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。</p>
<p><strong>双亲委派模型的工作过程</strong>是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求式，子加载器才会尝试自己去完成加载。</p>
<p><strong>好处</strong>：Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系。避免类的重复加载，保证加载的类是同一个。</p>
<p>避免核心类被纂改，通过委派模式，传递到启动类加载器，假如启动类加载器在核心API发现这个名字的类，就不会加载自定义的。</p>
<h3 id="双亲委派机制被打破的例子"><a href="#双亲委派机制被打破的例子" class="headerlink" title="双亲委派机制被打破的例子"></a>双亲委派机制被打破的例子</h3><ul>
<li><strong>JNDI</strong>通过引入线程上下文类加载器，可以在 Thread.setContextClassLoader 方法设置，默认是应用程序类加载器，来加载 SPI 的代码。有了线程上下文类加载器，就可以完成父类加载器请求子类加载器完成类加载的行为。<strong>打破的原因</strong>，是为了 JNDI 服务的类加载器是启动器类加载，为了完成高级类加载器请求子类加载器（即上文中的线程上下文加载器）加载类。（Java Naming and Directory Interface, Java命名和目录接口）</li>
<li><strong>Tomcat</strong>，应用的类加载器优先自行加载应用目录下的 class，并不是先委派给父加载器，加载不了才委派给父加载器。tomcat之所以造了一堆自己的classloader，大致是出于下面<strong>三类目的</strong>：<ul>
<li>对于各个 webapp 中的 class 和 lib ，需要相互隔离，不能出现一个应用中加载的类库会影响另一个应用的情况，而对于许多应用，需要有共享的lib以便不浪费资源。</li>
<li>与 jvm 一样的安全性问题。使用单独的 classloader 去装载 tomcat 自身的类库，以免其他恶意或无意的破坏；</li>
<li>热部署。</li>
</ul>
</li>
<li><strong>OSGi</strong>，实现模块化热部署，为每个模块都自定义了类加载器，需要更换模块时，模块与类加载器一起更换。其类加载的过程中，有平级的类加载器加载行为。<strong>打破的原因</strong>是为了实现模块热替换。</li>
<li><strong>JDK 9</strong>，Extension ClassLoader 被 Platform ClassLoader 取代，当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。<strong>打破的原因</strong>，是为了添加模块化的特性。</li>
</ul>
<h2 id="12-Java的垃圾回收机制"><a href="#12-Java的垃圾回收机制" class="headerlink" title="12. Java的垃圾回收机制"></a>12. Java的垃圾回收机制</h2><h3 id="12-0-Java的引用类型（判断对象能否被回收）"><a href="#12-0-Java的引用类型（判断对象能否被回收）" class="headerlink" title="12.0 Java的引用类型（判断对象能否被回收）"></a>12.0 Java的引用类型（判断对象能否被回收）</h3><ul>
<li><strong>强引用</strong>：new，在Java中最常见的就是强引用，<strong>把一个对象赋给一个引用变量</strong>，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是<strong>不可能被垃圾回收机制回收的</strong>，即使该对象以后永远都不会被用到JVM也不会回收。因此强引用是造成Java内存泄漏的主要原因之一。</li>
<li><strong>软引用</strong>：软引用需要用SoftReference类来实现，对于只有软引用的对象来说，<strong>当系统内存足够时它不会被回收</strong>，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。</li>
<li><strong>弱引用</strong>：弱引用需要用WeakReference类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，<strong>总会回收该对象占用的内存</strong>。</li>
<li><strong>虚引用</strong>：虚引用需要PhantomReference类来实现，它不能单独使用，必须和引用队列联合使用。虚引用的主要作用是跟踪对象被垃圾回收的状态。</li>
</ul>
<h3 id="12-1-哪些内存需要回收？"><a href="#12-1-哪些内存需要回收？" class="headerlink" title="12.1 哪些内存需要回收？"></a>12.1 哪些内存需要回收？</h3><p>主要关注<strong>堆和方法区</strong>。</p>
<h3 id="12-2-怎么定义垃圾？"><a href="#12-2-怎么定义垃圾？" class="headerlink" title="12.2 怎么定义垃圾？"></a>12.2 怎么定义垃圾？</h3><ul>
<li><p><strong>引用计数法</strong>：在Java中，引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，很显然一个简单的办法是通过引用计数来判断一个对象是否可以回收。简单说，即一个对象如果没有任何与之关联的引用，即他们的引用计数都不为0，则说明对象不太可能再被用到，那么这个对象就是可回收对象。</p>
</li>
<li><p><strong>可达性分析</strong></p>
<p>通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”，如果 某个对象到GC Roots间没有任何引用链相连，则证明此对象是不可能再被使用的。</p>
<ul>
<li>可作为GC Roots的对象：<ul>
<li><strong>虚拟栈</strong>中引用的对象</li>
<li><strong>方法区</strong>中类<strong>静态属性</strong>引用的对象</li>
<li><strong>方法区</strong>中<strong>常量</strong>引用的对象</li>
<li><strong>本地方法栈</strong>中<strong>JNI</strong>引用的对象</li>
<li><strong>JVM内部</strong>的引用</li>
<li>所有被<strong>同步锁</strong>(Synchronized关键字)持有的对象</li>
<li>反应Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>回收方法区</strong>：</p>
<ul>
<li>主要回收<strong>废弃的常量</strong>和<strong>不再使用的类型</strong><ul>
<li>废弃的常量：没有对象引用此常量</li>
<li>不再使用的类型：<ul>
<li>该类所有的实例都已被回收（包括子类的实例）</li>
<li>加载该类的类加载器已被回收</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="12-3-垃圾收集算法"><a href="#12-3-垃圾收集算法" class="headerlink" title="12.3 垃圾收集算法"></a>12.3 垃圾收集算法</h3><ul>
<li><p><strong>分代收集理论</strong>——经验法则</p>
<ul>
<li>弱分代假说：绝大多数对象都是朝生夕灭的</li>
<li>强分代假说：熬过越多次垃圾收集过程的对象越难消亡</li>
</ul>
<p>基于以上两点，收集器应该将Java堆划分出不同的区域，然后将回收对象依据年龄等分配到不同的区域中存储。但是可能会有跨代引用，于是就有了</p>
<ul>
<li>跨代引用假说：跨代引用相对于同代引用来说仅占极少数。</li>
</ul>
<p>只需在新生代上建立一个全局的数据结构（记忆集），这个结构把老年代划分为若干小块，标识出老年代的哪一块内存会存在跨代引用。当发生MinorGC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。</p>
</li>
<li><p><strong>分代收集</strong>——将堆分为新生代和老年代，不同的区域采用不同的回收算法。新生代：标记-复制算法；老年代：标记-清除或者标记-整理算法。</p>
</li>
<li><p><strong>标记-清除</strong>——效率不稳定、空间碎片化。最基础的垃圾回收算法，分为两个阶段，标注和清除。标记阶段标记出所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。</p>
<ul>
<li>分配：顺序查找空间，找到&gt;&#x3D;size的空间，分割空间</li>
<li>不足：效率低，产生时间碎片</li>
</ul>
</li>
<li><p><strong>标记-复制</strong>——为了解决Mark-Sweep算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉。新生代MinorGC使用这个。</p>
<ul>
<li>不足：内存只使用了1&#x2F;2</li>
</ul>
</li>
<li><p><strong>标记-整理</strong>——结合了以上两个算法，为了避免缺陷而提出。标记阶段和Mark-Sweep算法相同，标记后不是清理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。老年代FullGC使用这个。</p>
<ul>
<li>优点：无空间碎片</li>
<li>不足：需要移动，效率低</li>
</ul>
</li>
</ul>
<h2 id="13-新生代、老年代"><a href="#13-新生代、老年代" class="headerlink" title="13.新生代、老年代"></a>13.新生代、老年代</h2><p>垃圾回收时，将堆分为两个区域：新生代、老年代。</p>
<p>年轻代又划分为：1个Eden、2个Survivor（from和to）</p>
<h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>​	是所有新对象产生的地方，当尺寸随堆的大小变化，默认为堆的1&#x2F;15。</p>
<p>​	每次新生代使用1个Eden区和1个Survivor区，新对象先进入Eden，当Eden没有空间时，会触发回收机制，称作Minor GC，经过一次Minor GC，若对象还存在，则放入Survivor区，年龄加1。同时回收时清除正在使用的Survivor区域，将存活对象放入另一个Survivor区，并整理保证空间连续，Survivor中的对象每撑过一轮Minor GC，年龄加1。</p>
<h3 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h3><p>存放年龄大于15的对象。</p>
<p>在老年代触发的GC叫做Major GC，也称为Full GC。Full GC包含新生代的GC。</p>
<h2 id="14-为什么新生代要设置两个Survivor区域？"><a href="#14-为什么新生代要设置两个Survivor区域？" class="headerlink" title="14.为什么新生代要设置两个Survivor区域？"></a>14.为什么新生代要设置两个Survivor区域？</h2><p>解决内存碎片化。</p>
<h2 id="15-为什么老年代不能使用标记复制？"><a href="#15-为什么老年代不能使用标记复制？" class="headerlink" title="15. 为什么老年代不能使用标记复制？"></a>15. 为什么老年代不能使用标记复制？</h2><p>因为老年代保留的对象都是难以消亡的，而标记复制算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。</p>
<h2 id="16-垃圾收集器"><a href="#16-垃圾收集器" class="headerlink" title="16. 垃圾收集器"></a>16. 垃圾收集器</h2><img src="E:/面试/myJava.assets/image-20220605030553617.png" alt="image-20220605030553617" style="zoom: 45%;" />

<h3 id="1-Serial收集器"><a href="#1-Serial收集器" class="headerlink" title="1. Serial收集器"></a>1. Serial收集器</h3><ul>
<li><strong>新生代；单线程；复制算法。</strong></li>
</ul>
<p>它的“单线程”的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强调在它进行垃圾收集时，必须<strong>暂停其他所有工作线程</strong>，直到它收集结束。</p>
<p><img src="E:\学习笔记\图片\image-20220605030735446.png" alt="image-20220605030735446"></p>
<ul>
<li><strong>优点</strong>：简单。对于内存资源受限的环境，它是所有收集器里<strong>额外内存消耗最小</strong>的；对于单核处理器或处理器核心数较少的环境来说，Serial收集器由于<strong>没有线程交互的开销</strong>，专心做垃圾收集自然可以获得最高的单线程收集效率。</li>
<li><strong>缺点</strong>：单线程，stop the world并且时间长。</li>
<li><strong>场景</strong>：对于运行在<strong>客户端</strong>模式下的虚拟机来说是一个很好的选择。</li>
</ul>
<h3 id="2-ParNew收集器"><a href="#2-ParNew收集器" class="headerlink" title="2. ParNew收集器"></a>2. ParNew收集器</h3><ul>
<li><strong>新生代；多线程；复制算法</strong>。</li>
</ul>
<p>实质上是Serial的多线程并行版本。除了同时使用多个线程进行垃圾回收之外，其余的行为与实现都与Serial收集器一样。</p>
<p><img src="E:\学习笔记\图片\image-20220605031907374.png" alt="image-20220605031907374"></p>
<ul>
<li>默认开启的收集线程数与处理器核心数量相同。</li>
<li>场景：<strong>服务端</strong></li>
</ul>
<h3 id="3-Parallel-Scavenge收集器"><a href="#3-Parallel-Scavenge收集器" class="headerlink" title="3. Parallel Scavenge收集器"></a>3. Parallel Scavenge收集器</h3><ul>
<li><p><strong>新生代；多线程；标记-复制</strong>。</p>
</li>
<li><p>目标是达到一个可控制的吞吐量，所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值。<img src="E:/面试/myJava.assets/image-20220605172820260.png" alt="image-20220605172820260" style="zoom:50%;" /></p>
</li>
<li><p>高吞吐量则可以最高效率地利用处理器资源，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的分析任务。</p>
</li>
</ul>
<h3 id="4-Serial-Old收集器"><a href="#4-Serial-Old收集器" class="headerlink" title="4. Serial Old收集器"></a>4. Serial Old收集器</h3><ul>
<li><strong>老年代；单线程；标记-整理</strong>。</li>
<li>这个收集器的主要意义是供<strong>客户端模式</strong>下的HotSpot虚拟机使用。</li>
<li>如果在<strong>服务端模式</strong>下，它也可能有两种用途：<ul>
<li>一种是在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用；</li>
<li>另外一种就是作为CMS收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用。</li>
</ul>
</li>
</ul>
<p><img src="E:\学习笔记\图片\image-20220606000647278.png" alt="image-20220606000647278"></p>
<h3 id="5-Parallel-Old收集器"><a href="#5-Parallel-Old收集器" class="headerlink" title="5. Parallel Old收集器"></a>5. Parallel Old收集器</h3><ul>
<li><strong>是Parallel Scavenge的老年代版本；吞吐量优先；多线程；标记-整理</strong>。</li>
</ul>
<p><img src="E:\学习笔记\图片\image-20220606000835133.png" alt="image-20220606000835133"></p>
<h3 id="6-CMS垃圾回收器"><a href="#6-CMS垃圾回收器" class="headerlink" title="6.CMS垃圾回收器"></a>6.CMS垃圾回收器</h3><ul>
<li>CMS收集器是一种以获取最短回收停顿时间为目标的收集器。</li>
<li><strong>标记-清除</strong></li>
</ul>
<p>CMS的运作过程分为四个步骤：</p>
<ul>
<li><strong>1）初始标记</strong><ul>
<li>仅仅标记一下GC Roots能直接关联到的对象，速度很快。会“Stop The World”。</li>
</ul>
</li>
<li><strong>2）并发标记</strong><ul>
<li>从GCRoots的直接关联开始遍历整个对象图。比较耗时。但是不用停顿其他用户线程，可以与GC线程并发运行。</li>
</ul>
</li>
<li><strong>3）重新标记</strong><ul>
<li>为了修正并发标记期间，因用户程序继续运作而导致标记产A生变动的那一部分对象的标记记录。会“Stop The World”。</li>
<li>耗时比初始标记长，但比并发标记短</li>
</ul>
</li>
<li><strong>4）并发清除</strong><ul>
<li>清理删除标记阶段判断的已经死亡的对象。</li>
<li>并发进行，不需要移动存活对象。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>并发阶段，占用线程，降低总吞吐量</li>
<li>无法处理“<strong>浮动垃圾</strong>”，有可能导致另一次完全“Stop The World”的Full GC产生。——解决：留待下一次垃圾收集时再清理掉。</li>
<li>产生大量<strong>碎片</strong>，不得不触发Full GC——移动整理来消除碎片。</li>
</ul>
</li>
<li>PS：<strong>浮动垃圾</strong>：在CMS的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，<strong>只好留待下一次垃圾收集时再清理掉</strong>。这一部分垃圾就称为“浮动垃圾”。</li>
</ul>
<h3 id="7-G1垃圾收集器"><a href="#7-G1垃圾收集器" class="headerlink" title="7.G1垃圾收集器"></a>7.G1垃圾收集器</h3><p>整体上是标记-整理，局部是基于标记-复制。</p>
<p>G1仍遵循分代收集理论，但G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间、老年代空间。收集器能够对扮演不同角色的Region采用不同的策略区处理。</p>
<p>G1收集器建立了<strong>可预测的停顿时间模型，每次回收的空间都是Region大小的整数倍，这样可以避免在整个Java堆中进行全区域的垃圾回收。</strong></p>
<p><strong>CSET</strong> ：G1收集器出现之前的收集器，垃圾回收的目标范围要么是整个新生代(Minor GC) 或 老年代(Major GC)、要么是整个Java堆(Full GC)。而G1跳出了这个限制，任何部分来组成**回收集(CSet)**进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大。这就是G1收集器的Mixed GC模式。</p>
<p><strong>G1收集器的运作过程：</strong></p>
<ul>
<li><strong>初始标记</strong>：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运作时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，并且是借助运行Minor GC的时候同步完成的，所以G1收集器在这个阶段并没有额外的停顿。</li>
<li><strong>并发标记</strong>：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这个阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。</li>
<li><strong>最终标记</strong>：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后的那少量的SATB记录。</li>
<li><strong>筛选回收</strong>：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来指定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作设计存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。</li>
</ul>
<p><strong>G1中是否还有新生代和老年代的概念</strong></p>
<p>保留新生代和老年代的概念，但是不在进行物理上的隔离。</p>
<p><strong>G1适合的场景</strong></p>
<p>G1适合内存比较大的场景。重新定义堆空间，打破了原有的分代模型，可以回收部分空间，避免了在整个Java堆中进行全域的收集，因此适用于内存较大的场景，因为内存小的话，局部的回收，不足以满足空间的需求。</p>
<h2 id="17-内存分配策略"><a href="#17-内存分配策略" class="headerlink" title="17.内存分配策略"></a>17.内存分配策略</h2><ul>
<li><p>新对象优先在新生代分配</p>
</li>
<li><p>大对象直接进入老年代</p>
</li>
<li><p>年龄大于阈值（15）进入老年代</p>
</li>
<li><p>动态对象年龄判定</p>
<p>Survivor中的相同年龄的所有对象大小总和大于Survivor空间的一半，则年龄大于或等于该年龄的所有对象直接进入老年代。</p>
</li>
</ul>
<h2 id="18-什么时候触发GC，如何减少Full-GC的次数？"><a href="#18-什么时候触发GC，如何减少Full-GC的次数？" class="headerlink" title="18. 什么时候触发GC，如何减少Full GC的次数？"></a>18. 什么时候触发GC，如何减少Full GC的次数？</h2><ul>
<li><p><strong>触发GC</strong></p>
<ol>
<li><p>新生代的Eden区的空间耗尽时，触发Minor GC</p>
</li>
<li><p>调用System.gc()  （不建议）</p>
</li>
<li><p>老年代空间不足</p>
</li>
<li><p>空间分配担保失败</p>
<p><strong>空间分配担保：</strong>Minor GC之前先检查老年代的连续空间是否大于新生代所有对象总空间之和，若成立，则GC安全；否则，查看是否允许空间分配担保失败，若允许，检查老年代空间是否大于历次晋升到老年代的对象总空间的平均大小，如果大于，则进行Minor GC，否则进行Full GC。</p>
</li>
<li><p>JDK1.7之前的永久代空间不足</p>
</li>
<li><p>在CMS等并发收集器中，每隔一段时间检查一下老年代内存的使用量，超过一定比例则进行Full GC回收。</p>
</li>
</ol>
</li>
<li><p><strong>减少Full GC次数的措施</strong></p>
<ul>
<li>增加方法区的空间</li>
<li>增加老年代的空间</li>
<li>减少新生代的空间</li>
<li>禁止使用System.gc()方法</li>
<li>使用标记-整理算法，尽量保持较大的连续内存空间</li>
<li>排查代码中无用的大对象</li>
</ul>
</li>
</ul>
<h2 id="19-JVM一次完整的GC流程？"><a href="#19-JVM一次完整的GC流程？" class="headerlink" title="19. JVM一次完整的GC流程？"></a>19. JVM一次完整的GC流程？</h2><ul>
<li><p>1）新创建的对象会被分配在<strong>新生代</strong>中。</p>
<ul>
<li>新生代按照8：1：1将新生代划分成Eden区、两个Survivor区。</li>
<li>当Eden满之后，<strong>Minor GC就触发</strong>了。</li>
</ul>
</li>
<li><p>2）在Minor GC前，JVM先比较<strong>新生代中对象</strong>和<strong>老年代剩余空间的大小</strong>：</p>
<ul>
<li>如果老年代剩余空间 &gt; 新生代中对象的大小：直接GC。</li>
<li>如果老年代剩余空间 &lt; 新生代中对象的大小：就要看“老年代空间分配担保规则”：<ul>
<li>老年代剩余空间 &gt; 历次MinorGC后剩余对象的大小，进行Minor GC；</li>
<li>老年代剩余空间 &lt; 历次MinorGC后剩余对象的大小，进行<strong>Full GC</strong>，把老年代空出来再检查。</li>
</ul>
</li>
</ul>
</li>
<li><p>3）开启老年代空间担保分配规则只能说是大概率上来说，Minor GC剩余的对象能够放到老年代，但也有可能出现意外：</p>
<p>Minor GC之后的对象：</p>
<ul>
<li>足够放到Survivor区，GC结束；</li>
<li>不够放到Survivor区，接着进入老年代，<ul>
<li>如果老年代能放下，GC结束。</li>
<li>老年代放不下，只能<strong>触发Full GC</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p>4）3种OOM（Out Of Memory）：</p>
<ul>
<li>Full GC之后，老年代仍然放不下剩余对象；</li>
<li>未开启老年代分配担保机制，且第一次Full GC后，老年代仍放不下剩余对象；</li>
<li>开启老年代分配担保，但是担保不通过，一次Full GC后，老年代仍放不下剩余对象。</li>
</ul>
</li>
</ul>
<h2 id="20-触发GC之后，会立刻进行GC吗？"><a href="#20-触发GC之后，会立刻进行GC吗？" class="headerlink" title="20.触发GC之后，会立刻进行GC吗？"></a>20.触发GC之后，会立刻进行GC吗？</h2><p>不会。</p>
<h4 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h4><p>虚拟机为“会长时间执行”的程序设置了<strong>安全点</strong>，这就决定了用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是强制要求必须执行到达安全点之后才能够暂停。</p>
<p>对于安全点，另一个需要考虑的问题就是如何在GC发生时让所有线程（这里不包括执行JNI调用的线程）都“跑”到最近的安全点上再停顿下来。</p>
<p>两种解决方案：</p>
<ul>
<li><p>抢先式中断（Preemptive Suspension）</p>
<p>抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机采用这种方式来暂停线程从而响应GC事件。</p>
</li>
<li><p>主动式中断（Voluntary Suspension）</p>
<p>主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。（即每次到安全点，就去询问当前是否进行GC，是的话，将线程挂起）</p>
</li>
</ul>
<p>但是这种情况下，<strong>程序“不执行”的时候呢？</strong></p>
<p>所谓的程序不执行就是没有分配处理器时间，典型的场景便是用户线程处于Sleep状态或者Blocked状态，这时候线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂起自己，虚拟机也显然不可能持续等待线程重新被激活分配处理器时间。</p>
<h4 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h4><p><strong>安全区域</strong>是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。我们也可以把安全区域看作被扩展拉伸了的安全点。</p>
<p><strong>当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域</strong>，那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的阶段），如果完成了，那线程就当作没事发生过，继续执行；否则它就必须一直等待，直到收到可以离开安全区域的信号为止。</p>
<h2 id="21-Full-GC会导致什么？"><a href="#21-Full-GC会导致什么？" class="headerlink" title="21. Full GC会导致什么？"></a>21. Full GC会导致什么？</h2><p>会 “Stop The World”，即在GC期间全程暂停用户的应用程序。</p>
<h2 id="22-内存泄漏"><a href="#22-内存泄漏" class="headerlink" title="22. 内存泄漏"></a>22. 内存泄漏</h2><ul>
<li>程序运行过程中分配内存给临时变量，用完之后却没有被GC回收，始终占用着内存，既不能被使用也不能分配给其他程序。</li>
<li>原因：长生命周期的对象持有短生命周期对象的引用。</li>
<li>分类——根据发生的方式：<ul>
<li>常发性——内存泄漏的代码多次被执行到，每次执行都泄露</li>
<li>偶发性——特定条件才被执行到</li>
<li>一次性——只会执行一次</li>
<li>隐式——程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。——很长时间才停止运行。</li>
</ul>
</li>
<li>避免：<ul>
<li>尽早释放无用对象的内存</li>
<li>避免在循环中创建对象</li>
<li>使用字符串处理时避免使用String，应使用StringBuffer</li>
<li>尽量少使用静态变量，因为静态变量存放在永久代，基本不参与垃圾回收</li>
</ul>
</li>
</ul>
<h3 id="ThreadLocal-内存泄露问题是怎么导致的？"><a href="#ThreadLocal-内存泄露问题是怎么导致的？" class="headerlink" title="ThreadLocal 内存泄露问题是怎么导致的？"></a>ThreadLocal 内存泄露问题是怎么导致的？</h3><p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</p>
<p>这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。<code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法</p>
<h2 id="23-内存溢出（PPM）"><a href="#23-内存溢出（PPM）" class="headerlink" title="23. 内存溢出（PPM）"></a>23. 内存溢出（PPM）</h2><ul>
<li>程序运行过程中申请的内存大于系统能提供的内存。</li>
<li><strong>原因</strong>：<ul>
<li>内存中加载的数据量过于庞大</li>
<li>集合类中有对对象的引用，使用完后未清空，使得JVM不能回收</li>
<li>代码中存在死循环或循环产生过多重复的对象实体</li>
<li>使用的第三方软件中的bug</li>
<li>启动参数内存值设定的过小</li>
</ul>
</li>
<li>内存溢出的<strong>解决方案</strong>：<ul>
<li>1）修改JVM启动参数，直接增加内存</li>
<li>2）检查错误日志，查看OOM错误前是否有其他异常或错误</li>
<li>3）对代码进行走查和分析，找到可能发生OOM的位置</li>
<li>4）使用内存查看工具动态查看内存使用情况</li>
</ul>
</li>
<li><strong>哪些区域会OOM</strong><ul>
<li>1）<strong>Java堆</strong><ul>
<li>不断创建对象，并且保证GCRoots到对象之间有可达路径</li>
</ul>
</li>
<li>2）<strong>虚拟机栈</strong>和<strong>本地方法栈</strong></li>
<li>3）<strong>方法区</strong>和<strong>运行时常量池</strong><ul>
<li>方法区溢出原因：经常运行时生成大量动态类的应用场景。</li>
</ul>
</li>
<li>4）<strong>本地直接内存</strong></li>
</ul>
</li>
</ul>
<h2 id="24-栈溢出原因"><a href="#24-栈溢出原因" class="headerlink" title="24. 栈溢出原因"></a>24. 栈溢出原因</h2><ul>
<li>栈是线程私有的，栈的生命周期和线程一样，每个方法在执行的时候就会创建一个栈帧，它包含局部变量表、操作数栈、动态链接、方法出口等信息，局部变量表又包括基本数据类型和对象的引用；</li>
<li>当线程请求的栈深度超过了虚拟机允许的最大深度时，会抛出StackOverFlowError异常，方法递归调用可能会出现该问题；</li>
<li>调整参数-xss去调整jvm栈的大小</li>
<li>大量循环或死循环</li>
<li>全局变量过多</li>
<li>数组、List、map数据过大</li>
</ul>
<h2 id="25-高耗CPU怎么排查？"><a href="#25-高耗CPU怎么排查？" class="headerlink" title="25. 高耗CPU怎么排查？"></a><strong>25. 高耗CPU怎么排查？</strong></h2><p>使用<strong>top命令</strong>查看目前服务所占cpu情况。</p>
<p>接下来排查系统代码中哪些逻辑导致CPU过高。</p>
<p><strong>第一步：通过ps命令查看这个程序的线程信息</strong>。</p>
<p>​		执行命令：ps -mp [pid]-o THREAD, tid, time</p>
<p>​		属性介绍：tid代表线程ID，time代表这个线程的已运行时间，27291为对应pid的值。</p>
<p><strong>第二步：将TID(代码线程ID)转为16进制</strong></p>
<p>​		因为jvm运行信息都是16进制，所以，这里需要将十进制转为16进制。</p>
<p><strong>第三步：jstack查看进程信息</strong></p>
<ul>
<li><strong>执行命令：jstack[pid] | grep [tid] -A 30</strong></li>
</ul>
<p>​		内容介绍：27291 为pid进程，6d05 为需要查看的线程tid</p>
<p>​		输出信息有较为明显的的代码信息。</p>
<ul>
<li><strong>根据上面输出信息可以很快定位到本地代码存在的问题。</strong></li>
</ul>
<p><strong>PS：容易造成cpu占用过高的情况</strong></p>
<p>1.代码中写死循环时,一直占用cpu</p>
<p>2.如在循环中不停的创建对象,也会导致GC频繁 。</p>
<h2 id="26-JVM调优参数总结"><a href="#26-JVM调优参数总结" class="headerlink" title="26. JVM调优参数总结"></a>26. JVM调优参数总结</h2><p>Xmn、Xms、Xmx、Xss都是JVM对内存的配置参数。</p>
<h3 id="堆内存分配"><a href="#堆内存分配" class="headerlink" title="堆内存分配"></a>堆内存分配</h3><ul>
<li><p>JVM<strong>初始</strong>分配的内存由-Xms指定，默认是物理内存的1&#x2F;64</p>
</li>
<li><p>JVM<strong>最大</strong>分配的内存由-Xmx指定，默认是物理内存的1&#x2F;4</p>
</li>
</ul>
<p>默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制；空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。</p>
<p>因此服务器一般设置-Xms、-Xmx相等以避免在每次GC 后调整堆的大小。对象的堆内存由称为垃圾回收器的自动内存管理系统回收。</p>
<h3 id="堆设置"><a href="#堆设置" class="headerlink" title="堆设置"></a>堆设置</h3><p>-<strong>Xms</strong>:初始堆大小</p>
<p>-<strong>Xmx</strong>:最大堆大小</p>
<p>-<strong>Xmn</strong>:新生代大小</p>
<p>-<strong>XX:NewRatio</strong>：设置<strong>新生代和老年代的比值</strong>。如：为2，表示年轻代与老年代比值为1:2</p>
<p>-XX:SurvivorRatio：新生代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：为3，表示Eden : Survivor&#x3D;3:2，一个Survivor区占整个新生代的1&#x2F;5。</p>
<p>-XX:MaxTenuringThreshold：设置转入老年代的存活次数。如果是0，则直接跳过新生代进入老年代</p>
<p>-XX:PermSize、-XX:MaxPermSize：分别设置永久代最小大小与最大大小（Java8以前）</p>
<p>-XX:MetaspaceSize、-XX:MaxMetaspaceSize：分别设置元空间最小大小与最大大小（Java8以后）</p>
<h3 id="收集器设置"><a href="#收集器设置" class="headerlink" title="收集器设置"></a>收集器设置</h3><p>-XX:+UseSerialGC：设置串行收集器</p>
<p>-XX:+UseParallelGC：设置并行收集器</p>
<p>-XX:+UseParalledlOldGC：设置并行老年代收集器</p>
<p>-XX:+UseConcMarkSweepGC设置并发收集器</p>
<h3 id="垃圾回收统计信息"><a href="#垃圾回收统计信息" class="headerlink" title="垃圾回收统计信息"></a>垃圾回收统计信息</h3><p>-XX:+PrintGC</p>
<p>-XX:+PrintGCDetails</p>
<p>-XX:+PrintGCTimeStamps</p>
<p>-Xloggc:filename</p>
<h3 id="并行收集器设置"><a href="#并行收集器设置" class="headerlink" title="并行收集器设置"></a>并行收集器设置</h3><p>-XX:ParallelGCThreads&#x3D;n:设置并行收集器收集时使用的CPU数。并行收集线程数。</p>
<p>-XX:MaxGCPauseMillis&#x3D;n:设置并行收集最大暂停时间</p>
<p>-XX:GCTimeRatio&#x3D;n:设置垃圾回收时间占程序运行时间的百分比。公式为1&#x2F;(1+n)</p>
<h3 id="并发收集器设置"><a href="#并发收集器设置" class="headerlink" title="并发收集器设置"></a>并发收集器设置</h3><p>-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。</p>
<p>-XX:ParallelGCThreads&#x3D;n:设置并发收集器新生代收集方式为并行收集时，使用的CPU数。并行收集线程数。</p>
<h3 id="非堆内存分配"><a href="#非堆内存分配" class="headerlink" title="非堆内存分配"></a>非堆内存分配</h3><p>JVM使用-XX:PermSize设置非堆内存初始值，默认是物理内存的1&#x2F;64；</p>
<p>由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1&#x2F;4。</p>
<p>-Xss 设置每个线程可使用的内存大小，即栈的大小。在相同物理内存下，减小这个值能生成更多的线程，当然操作系统对一个进程内的线程数还是有限制的，不能无限生成。线程栈的大小是个双刃剑，如果设置过小，可能会出现栈溢出，特别是在该线程内有递归、大的循环时出现溢出的可能性更大，如果该值设置过大，就有影响到创建栈的数量，如果是多线程的应用，就会出现内存溢出的错误。</p>
<h2 id="27-如何查看字节码文件（命令）"><a href="#27-如何查看字节码文件（命令）" class="headerlink" title="27.如何查看字节码文件（命令）"></a>27.如何查看字节码文件（命令）</h2><p><code>javap -verbose XXX.class</code></p>
<h2 id="28-对象的访问定位有哪两种方式"><a href="#28-对象的访问定位有哪两种方式" class="headerlink" title="28.对象的访问定位有哪两种方式?"></a>28.对象的访问定位有哪两种方式?</h2><p>Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有<strong>① 使用句柄</strong>和<strong>② 直接指针</strong>两种：</p>
<p><strong>句柄：</strong> 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；</p>
<p><strong>直接指针：</strong> 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。</p>
<p><strong>各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</strong></p>
<h2 id="29-内存逃逸"><a href="#29-内存逃逸" class="headerlink" title="29.内存逃逸"></a>29.内存逃逸</h2><p>JVM的内存分配主要在是运行时数据区(Runtime Data Areas)，而运行时数据区又分为了：方法区，堆区，PC寄存器，Java虚拟机栈(就是栈区，官方文档还是叫Java虚拟机栈)，本地方法区，而内存逃逸主要是对象的动态作用域的改变而引起的，故而内存逃逸的分析就是分析对象的动态作用域。</p>
<p><code>方法逃逸</code>：</p>
<ul>
<li><p>什么是方法逃逸呢？举个栗子，在一个方法中定义一个对象后(方法内局部的)，这个对象被外部方法引用，比如作为返回值返回传递到其他的地方，当这个方法执行结束要进行GC时，这个方法中的对象本应该被回收，却发现该对象还是存活状态没法回收，就称为<code>方法逃逸</code>：</p>
</li>
<li><p><code>线程逃逸</code>：直接将对象返回，该对象可能被外部线程访问，如：赋值给类变量等，称为线程逃逸。总的来说就是一个对象的指针被多个方法或者线程引用时，我们就称这个对象的指针发生了逃逸。</p>
</li>
</ul>
<p><strong>优化</strong>：即证明一个对象不会逃逸到方法或线程外。</p>
<ul>
<li>栈上分配：</li>
</ul>
<p>说起对象，那你第一个想到的是在堆空间上进行内存分配，GC在堆空间上筛选可回收的对象，回收对象，整理内存都需要浪费时间，若能通过逃逸分析确定某些对象是一定不会逃逸出方法之外的，就可以直接让这个对象在栈上分配内存，该对象随方法的执行结束栈帧出栈而销毁，减轻了GC的压力。</p>
<ul>
<li>同步消除：</li>
</ul>
<p>线程同步本身比较耗时，若确定了一个变量不会逃逸出线程，无法被其他线程访问到，那这个变量的读写就不会存在竞争，这个变量的同步措施就可以清除掉。</p>
<ul>
<li>标量替换：</li>
</ul>
<p><strong>标量</strong>：Java中的原始数据类型(int，char，long等)都不能再进一步分解，他们就可以称为标量。</p>
<p><strong>聚合量</strong>：若一个数据可以继续分解，那就称之为聚合量，而对象就是典型的聚合量，因为他可以分解成其他聚合量和标量。</p>
<p>若逃逸分析证明一个对象不会逃逸出方法，不会被外部访问，并且这个对象是可以被分解的，那程序在真正执行的时候可能不创建这个对象，而是直接创建这个对象分解后的标量来代替。这样就无需在对对象分配空间了，只在栈上为分解出的变量分配内存即可。</p>
<h2 id="30-内存屏障"><a href="#30-内存屏障" class="headerlink" title="30.内存屏障"></a>30.内存屏障</h2><ul>
<li>硬件层的内存屏障分为两种：<code>Load Barrier</code> 和 <code>Store Barrier</code>即读屏障和写屏障。</li>
<li>内存屏障有两个作用：</li>
</ul>
<blockquote>
<ol>
<li>阻止屏障两侧的指令重排序；</li>
<li>强制把写缓冲区&#x2F;高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。</li>
</ol>
</blockquote>
<ul>
<li>对于Load Barrier来说，在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制从新从主内存加载数据；</li>
<li>对于Store Barrier来说，在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。</li>
</ul>
<hr>
<h3 id="java内存屏障"><a href="#java内存屏障" class="headerlink" title="java内存屏障"></a>java内存屏障</h3><ul>
<li>java的内存屏障通常所谓的四种即<code>LoadLoad</code>,<code>StoreStore</code>,<code>LoadStore</code>,<code>StoreLoad</code>实际上也是上述两种的组合，完成一系列的屏障和数据同步功能。</li>
<li>LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li>
<li>StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li>
<li>LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li>
<li>StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。<strong>它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能</strong></li>
</ul>
<hr>
<h3 id="volatile语义中的内存屏障"><a href="#volatile语义中的内存屏障" class="headerlink" title="volatile语义中的内存屏障"></a>volatile语义中的内存屏障</h3><ul>
<li>volatile的内存屏障策略非常严格保守，非常悲观且毫无安全感的心态：</li>
</ul>
<blockquote>
<p>在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障；<br> 在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障；</p>
</blockquote>
<ul>
<li>由于内存屏障的作用，避免了volatile变量和其它指令重排序、线程之间实现了通信，使得volatile表现出了锁的特性。</li>
</ul>
<h3 id="final语义中的内存屏障"><a href="#final语义中的内存屏障" class="headerlink" title="final语义中的内存屏障"></a>final语义中的内存屏障</h3><ul>
<li>对于final域，编译器和CPU会遵循两个排序规则：</li>
</ul>
<blockquote>
<ol>
<li>新建对象过程中，构造体中对final域的初始化写入和这个对象赋值给其他引用变量，这两个操作不能重排序；（废话嘛）</li>
<li>初次读包含final域的对象引用和读取这个final域，这两个操作不能重排序；（晦涩，意思就是先赋值引用，再调用final值）</li>
</ol>
</blockquote>
<ul>
<li>总之上面规则的意思可以这样理解，必需保证一个对象的所有final域被写入完毕后才能引用和读取。这也是内存屏障的起的作用：</li>
<li>写final域：在编译器写final域完毕，构造体结束之前，会插入一个StoreStore屏障，保证前面的对final写入对其他线程&#x2F;CPU可见，并阻止重排序。</li>
<li>读final域：在上述规则2中，两步操作不能重排序的机理就是在读final域前插入了LoadLoad屏障。</li>
<li>X86处理器中，由于CPU不会对写-写操作进行重排序，所以StoreStore屏障会被省略；而X86也不会对逻辑上有先后依赖关系的操作进行重排序，所以LoadLoad也会变省略。</li>
</ul>
<h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><p>![Untitled](E:\学习笔记\图片\Untitled 47.png)</p>
<ul>
<li>workspace：工作区</li>
<li>staging area：暂存区&#x2F;缓存区</li>
<li>local repository：版本库或本地仓库</li>
<li>remote repository：远程仓库</li>
</ul>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">git clone	拷贝一份远程仓库，也就是下载一个项目。</span><br><span class="line">git init	初始化仓库</span><br><span class="line">git add	添加文件到暂存区，跟踪文件，只要更新，通过git status就能显示出来</span><br><span class="line">git status	查看仓库当前的状态，显示有变更的文件。-s 输出精简信息</span><br><span class="line">git diff	比较文件的不同，即暂存区和工作区的差异。</span><br><span class="line">git commit	提交暂存区到本地仓库。</span><br><span class="line">git reset	回退版本。</span><br><span class="line">git rm	删除工作区文件。</span><br><span class="line">git mv	移动或重命名工作区文件。</span><br><span class="line">git log	查看历史提交记录</span><br><span class="line">git blame &lt;file&gt;	以列表形式查看指定文件的历史修改记录</span><br><span class="line">git remote	远程仓库操作</span><br><span class="line">git fetch	从远程获取代码库</span><br><span class="line">git pull	下载远程代码并合并</span><br><span class="line">git push	上传远程代码并合并</span><br><span class="line">git branch	列出分支</span><br><span class="line">git branch (branchname)	手动创建一个分支</span><br><span class="line">git branch -d (branchname)	删除分支</span><br><span class="line">git merge	分支合并</span><br></pre></td></tr></table></figure>

<p>1）<code>git init</code></p>
<p>​	把当前目录作初始化为git仓库——会在当前文件夹出现<code>.git</code>文件夹。</p>
<p>2）<code>git add [*][*.*]</code></p>
<p>​	添加文件到暂存区。</p>
<p>3）<code>git commit -m &quot;本次提交的注释信息&quot;</code></p>
<p>​	提交暂存区到本地仓库。Linux用单引号，Windows用双引号。</p>
<p>4）<code>git remote add origin &lt;仓库地址&gt;</code></p>
<p>​	连接到远程仓库。</p>
<p>5）<code>git push</code></p>
<p>​	上传到远程代码并合并。【初次用 <code>git push origin master</code>】</p>
<p>PS：<code>git clone -b branch_name http://****.git</code></p>
<p>​	下载指定branch的代码</p>
<hr>
<p>指定远程仓库</p>
<p><code>git config --global user.name &quot;myGitAcountName&quot;</code></p>
<p><code>git config --global user.email &quot;myGitEmail&quot;</code></p>
<h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><p>并发编程的三个特性</p>
<p>原子性：一个操作或者多个操作，要么全部执行成功，要么全部执行失败。满足原子性的操作，中途不可被中断</p>
<p>有序性：程序执行的顺序按照代码的先后顺序执行。</p>
<p>可见性：多个线程共同访问共享变量时，某个线程修改了此变量，其他线程能立即看到修改后的值。</p>
<h2 id="1-i-是线程安全的吗？"><a href="#1-i-是线程安全的吗？" class="headerlink" title="1. i++是线程安全的吗？"></a>1. i++是线程安全的吗？</h2><p><strong>i++是不安全的</strong>，<del>（volatile关键字修饰的）</del></p>
<p><strong>i++是一个复合操作，可分为三个阶段：</strong></p>
<ul>
<li>读值，从内存到寄存器</li>
<li>+1，寄存器自增</li>
<li>写值，写回内存</li>
</ul>
<p>在这三步之间的都可能会有CPU调度，造成i的值被修改。造成脏读脏写。</p>
<p><strong>如果是方法里定义的，一定是线程安全的，方法中的变量放在栈中，是线程私有的；</strong></p>
<p><strong>如果是类的静态成员变量，i++则不是线程安全的，因为类的变量放在堆中，堆是共享的</strong></p>
<p><strong>如何解决线程安全性呢？</strong></p>
<ul>
<li>可以使用原子变量（AtomicInteger，参考 Java并发编程之原子变量）</li>
<li>sychronized关键字、Lock锁实现（参考 Java关键字 volatile、synchronized和Lock锁）。</li>
</ul>
<p>AtomicInteger 和 各种 Lock 都可以确保线程安全。AtomicInteger 的效率高是因为它是互斥区非常小，只有一条指令，而 Lock 的互斥区是拿锁到放锁之间的区域，至少三条指令。</p>
<h2 id="2-创建线程的四种方式"><a href="#2-创建线程的四种方式" class="headerlink" title="2.创建线程的四种方式"></a>2.创建线程的四种方式</h2><h3 id="java中创建线程的四种方法以及区别"><a href="#java中创建线程的四种方法以及区别" class="headerlink" title="java中创建线程的四种方法以及区别"></a>java中创建线程的四种方法以及区别</h3><p>Java使用Thread类代表线程，所有的线程对象都必须是Thread类或其子类的实例。Java可以用四种方式来创建线程，如下所示：</p>
<p>1）继承Thread类创建线程</p>
<p>2）实现Runnable接口创建线程</p>
<p>3）使用Callable和Future创建线程</p>
<p>4）使用线程池例如用Executor框架</p>
<h3 id="一、继承Thread类创建线程"><a href="#一、继承Thread类创建线程" class="headerlink" title="一、继承Thread类创建线程"></a>一、继承Thread类创建线程</h3><p>通过继承Thread类来创建并启动多线程的一般步骤如下</p>
<p>1、定义Thread类的子类，并重写该类的run()方法，该方法的方法体就是线程需要完成的任务，run()方法也称为线程执行体。</p>
<p>2、创建Thread子类的实例，也就是创建了线程对象</p>
<p>3、启动线程，即调用线程的start()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">代码实例</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;<span class="comment">//继承Thread类</span></span><br><span class="line"></span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="comment">//重写run方法</span></span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">new</span> <span class="title class_">MyThread</span>().start();<span class="comment">//创建并启动线程</span></span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二、实现Runnable接口创建线程"><a href="#二、实现Runnable接口创建线程" class="headerlink" title="二、实现Runnable接口创建线程"></a>二、实现Runnable接口创建线程</h3><p>通过实现Runnable接口创建并启动线程一般步骤如下：</p>
<p>1、定义Runnable接口的实现类，一样要重写run()方法，这个run()方法和Thread中的run()方法一样是线程的执行体</p>
<p>2、创建Runnable实现类的实例，并用这个实例作为Thread的target来创建Thread对象，这个Thread对象才是真正的线程对象</p>
<p>3、第三部依然是通过调用线程对象的start()方法来启动线程</p>
<p>代码实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;<span class="comment">//实现Runnable接口</span></span><br><span class="line"></span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;undefined</span><br><span class="line"></span><br><span class="line">　　<span class="comment">//重写run方法</span></span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">　　　　<span class="comment">//创建并启动线程</span></span><br><span class="line"></span><br><span class="line">　　　　MyThread2 myThread=<span class="keyword">new</span> <span class="title class_">MyThread2</span>();</span><br><span class="line"></span><br><span class="line">　　　　Thread thread=<span class="keyword">new</span> <span class="title class_">Thread</span>(myThread);</span><br><span class="line"></span><br><span class="line">　　　　thread().start();</span><br><span class="line"></span><br><span class="line">　　　　<span class="comment">//或者    new Thread(new MyThread2()).start();</span></span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、使用Callable和Future创建线程"><a href="#三、使用Callable和Future创建线程" class="headerlink" title="三、使用Callable和Future创建线程"></a>三、使用Callable和Future创建线程</h3><p>和Runnable接口不一样，Callable接口提供了一个call()方法作为线程执行体，call()方法比run()方法功能要强大。</p>
<ul>
<li>call()方法可以有返回值</li>
<li>call()方法可以声明抛出异常</li>
</ul>
<p>Java5提供了Future接口来代表Callable接口里call()方法的返回值，并且为Future接口提供了一个实现类FutureTask，这个实现类既实现了Future接口，还实现了Runnable接口，因此可以作为Thread类的target。在Future接口里定义了几个公共方法来控制它关联的Callable任务。</p>
<blockquote>
<p>boolean cancel(boolean mayInterruptIfRunning)：视图取消该Future里面关联的Callable任务</p>
</blockquote>
<blockquote>
<p>V get()：返回Callable里call（）方法的返回值，调用这个方法会导致程序阻塞，必须等到子线程结束后才会得到返回值</p>
</blockquote>
<blockquote>
<p>V get(long timeout,TimeUnit unit)：返回Callable里call（）方法的返回值，最多阻塞timeout时间，经过指定时间没有返回抛出TimeoutException</p>
</blockquote>
<blockquote>
<p>boolean isDone()：若Callable任务完成，返回True</p>
</blockquote>
<blockquote>
<p>boolean isCancelled()：如果在Callable任务正常完成前被取消，返回True</p>
</blockquote>
<p>创建并启动有返回值的线程的步骤如下：</p>
<p>1、创建Callable接口的实现类，并实现call()方法，然后创建该实现类的实例（从java8开始可以直接使用Lambda表达式创建Callable对象）。</p>
<p>2、使用FutureTask类来包装Callable对象，该FutureTask对象封装了Callable对象的call()方法的返回值</p>
<p>3、使用FutureTask对象作为Thread对象的target，创建并启动线程（因为FutureTask实现了Runnable接口）</p>
<p>4、调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread3</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">　　　MyThread3 th=<span class="keyword">new</span> <span class="title class_">MyThread3</span>();</span><br><span class="line"></span><br><span class="line">　　　<span class="comment">//也可以直接使用Lambda表达式创建Callable对象</span></span><br><span class="line"></span><br><span class="line">　　   <span class="comment">//使用FutureTask类来包装Callable对象</span></span><br><span class="line"></span><br><span class="line">　　　FutureTask&lt;Integer&gt; future=<span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Integer&gt;(</span><br><span class="line"></span><br><span class="line">　　　　(Callable&lt;Integer&gt;)()-&gt;&#123;</span><br><span class="line">　　　　　　<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　  );</span><br><span class="line"></span><br><span class="line">　　　<span class="keyword">new</span> <span class="title class_">Thread</span>(future,<span class="string">&quot;有返回值的线程&quot;</span>).start();<span class="comment">//实质上还是以Callable对象来创建并启动线程</span></span><br><span class="line"></span><br><span class="line">　　  <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">　　　　System.out.println(<span class="string">&quot;子线程的返回值：&quot;</span>+future.get());<span class="comment">//get()方法会阻塞，直到子线程执行结束才返回</span></span><br><span class="line"></span><br><span class="line"> 　　 &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">　　　　ex.printStackTrace();</span><br><span class="line"></span><br><span class="line">　　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="四、使用线程池，例如用Executor框架"><a href="#四、使用线程池，例如用Executor框架" class="headerlink" title="四、使用线程池，例如用Executor框架"></a>四、使用线程池，例如用Executor框架</h3><p>创建的几种方式：</p>
<p><strong>方式一：通过<code>ThreadPoolExecutor</code>构造函数实现（推荐）</strong></p>
<p><strong>方式二：通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来实现</strong> </p>
<p>Executors提供的四种线程池：</p>
<p><code>newFixedThreadPool</code> 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p>
<p><code>newSingleThreadExecutor</code> 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p>
<p><code>newCachedThreadPool</code> 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p>
<p><code>newScheduledThreadPoolExecutor</code>创建一个线程池，支持定时及周期性任务执行</p>
<p>《阿里巴巴 Java 开发手册》中强制线程池不允许使用 <code>Executors</code> 去创建，而是通过 <code>ThreadPoolExecutor</code> 构造函数的方式。</p>
<p><code>Executors</code> 返回线程池对象的弊端如下：</p>
<ul>
<li><strong><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code></strong> ： 允许请求的队列长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>
<li><strong><code>CachedThreadPool</code> 和 <code>ScheduledThreadPool</code></strong> ： 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 OOM。</li>
</ul>
<h2 id="3-例题"><a href="#3-例题" class="headerlink" title="3.例题"></a>3.例题</h2><h3 id="Java实现两个线程交替打印1-100"><a href="#Java实现两个线程交替打印1-100" class="headerlink" title="Java实现两个线程交替打印1-100"></a>Java实现两个线程交替打印1-100</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">/*指代的为TestThread,因为使用的是implements方式。若使用继承Thread类的方式，慎用this*/</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="comment">/*唤醒另外一个线程，注意是this的方法，而不是Thread*/</span></span><br><span class="line">                notify();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">/*使其休眠100毫秒，放大线程差异*/</span></span><br><span class="line">                    Thread.currentThread();<span class="comment">//此句可以省略</span></span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">                    i++;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">/*放弃资源，等待*/</span></span><br><span class="line">                        wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*只有一个TestThread对象*/</span></span><br><span class="line">        <span class="type">TestThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestThread</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-run-和start-有什么区别？"><a href="#4-run-和start-有什么区别？" class="headerlink" title="4.run()和start()有什么区别？"></a>4.run()和start()有什么区别？</h2><ul>
<li><strong>run</strong>()：线程执行体，方法体代表线程需要完成的任务。run()会理解被执行，在它结束之前无法并发（就是当成了普通对象执行）</li>
<li><strong>start</strong>()：用来启动线程。系统会把run()当成线程执行体来处理。</li>
</ul>
<p>【注】线程不可以重复调用start()方法，否则会引发IllegalThreadDtateException异常。</p>
<p>​			若直接调用run()，则不会通过线程去执行。</p>
<h2 id="5-sleep-和wait"><a href="#5-sleep-和wait" class="headerlink" title="5.sleep()和wait()"></a>5.sleep()和wait()</h2><ul>
<li>sleep()：1.Thread类的静态方法，2.可用在任何地方，3.释放CPU执行权，不释放锁，4.必须指定时间。</li>
<li>wait()：1.Object类中的成员方法，2.只能在同步方法或同步代码块中使用，3.释放CPU执行权，释放锁，然后进入对象的等待池，只有通过notify()&#x2F;notifyAll()才能唤醒进入等锁池（lock pool）重新获得锁。4.wait可以指定时间，也可以不指定。指定时间时，在时间内不会被notifyAll函数唤醒。</li>
</ul>
<h2 id="6-什么是-Callable-和-Future"><a href="#6-什么是-Callable-和-Future" class="headerlink" title="6.什么是 Callable 和 Future?"></a>6.什么是 Callable 和 Future?</h2><ul>
<li><strong>Callable 接口</strong>类似于 Runnable，但是 Runnable 不会返 回结果，并且无法抛出返回结果的异常，而 Callable 功能更强大一些，被线程执行后，可以返回值，这个返回值可以被 Future 拿到，也就是说，Future 可以拿到 异步执行任务的返回值。 可以认为是带有回调的 Runnable。</li>
<li><strong>Future 接口</strong>表示异步任务，是还没有完成的任务给出的未来结果。所以说 Callable 用于产生结果，Future 用于获取结果。</li>
</ul>
<h2 id="7-Java中线程同步的方法（五种）"><a href="#7-Java中线程同步的方法（五种）" class="headerlink" title="7.Java中线程同步的方法（五种）"></a>7.Java中线程同步的方法（五种）</h2><h3 id="一、同步方法"><a href="#一、同步方法" class="headerlink" title="一、同步方法"></a>一、同步方法</h3><p>即有synchronized关键字修饰的方法。 由于java的每个对象都有一个内置锁，当用此关键字修饰方法时， 内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。</p>
<h3 id="二、同步代码块"><a href="#二、同步代码块" class="headerlink" title="二、同步代码块"></a>二、同步代码块</h3><p>　　即有synchronized关键字修饰的语句块。 被该关键字修饰的语句块会自动被加上内置锁，从而实现同步</p>
<p>  代码如： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">synchronized(object)&#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、使用特殊域变量-volatile-实现线程同步"><a href="#三、使用特殊域变量-volatile-实现线程同步" class="headerlink" title="三、使用特殊域变量(volatile)实现线程同步"></a>三、使用特殊域变量(volatile)实现线程同步</h3><p>a.volatile关键字为域变量的访问提供了一种免锁机制， 属于轻量级同步策略</p>
<p>b.使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新， </p>
<p>c.因此每次使用该域就要重新计算，而不是使用寄存器中的值 </p>
<p>d.volatile不会提供任何原子操作，它也不能用来修饰final类型的变量 ，保证可见性和禁止指令重排</p>
<h3 id="四、使用重入锁实现线程同步"><a href="#四、使用重入锁实现线程同步" class="headerlink" title="四、使用重入锁实现线程同步"></a>四、使用重入锁实现线程同步</h3><p>ReentrantLock类是可重入、互斥、实现了Lock接口的锁，它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力。</p>
<h3 id="五、使用局部（本地）变量实现线程同步"><a href="#五、使用局部（本地）变量实现线程同步" class="headerlink" title="五、使用局部（本地）变量实现线程同步"></a>五、使用局部（本地）变量实现线程同步</h3><p>  如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本，副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。</p>
<p>   ThreadLocal 类的常用方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal() : 创建一个线程本地变量 </span><br><span class="line">get() : 返回此线程局部变量的当前线程副本中的值 </span><br><span class="line">initialValue() : 返回此线程局部变量的当前线程的&quot;初始值&quot; </span><br><span class="line">set(T value) : 将此线程局部变量的当前线程副本中的值设置为value</span><br></pre></td></tr></table></figure>

<h2 id="8-Java线程之间的通信"><a href="#8-Java线程之间的通信" class="headerlink" title="8.Java线程之间的通信"></a>8.Java线程之间的通信</h2><ul>
<li>wait()、notify()、notifyAll()——Object类的方法<ul>
<li>本地方法、final修饰、必须与synchronized一起</li>
<li>wait()：让当前线程释放对象锁并进入阻塞状态</li>
<li>notify()：用于唤醒一个正在等待响应对象锁的线程，使其进入就绪队列</li>
<li>每个锁都有两个队列：就绪队列、阻塞队列。</li>
</ul>
</li>
<li>await()、signal()、signalAll()——Condition接口的方法<ul>
<li>依赖于Lock，更安全高效</li>
<li>必须在lock.lock()和lock.unlock()之间使用</li>
</ul>
</li>
<li>BlockingQueue——生产者&#x2F;消费者模式<ul>
<li>放时 队满 阻塞</li>
<li>取时 队空 阻塞</li>
</ul>
</li>
</ul>
<h2 id="9-Java的锁"><a href="#9-Java的锁" class="headerlink" title="9.Java的锁"></a>9.Java的锁</h2><p><img src="E:\学习笔记\图片\20181122101753671.png" alt="img"></p>
<h3 id="1）乐观锁和悲观锁"><a href="#1）乐观锁和悲观锁" class="headerlink" title="1）乐观锁和悲观锁"></a>1）乐观锁和悲观锁</h3><ul>
<li><p><strong>悲观锁</strong>：每次拿数据都都认为别人会修改，所以每次拿数据都会上锁，其他想获取数据的会被阻塞。通过<strong>synchronized或Lock</strong>接口实现。</p>
</li>
<li><p><strong>乐观锁</strong>：每次拿数据的时候都认为别人不会修改，所以不会上锁。但在更新时会判断一下在此期间别人有没有去更新这个数据。提高了吞吐量。乐观锁适用于多读的应用类型，这样可以提高吞吐量。在JDK1.5 中新增 java.util.concurrent (J.U.C)就是建立在<strong>CAS</strong>之上的。相对于对于 synchronized 这种阻塞算法，CAS是非阻塞算法的一种常见实现。所以J.U.C在性能上有了很大的提升。</p>
</li>
<li><p>CAS——含三个操作数：需要读写的内存位置（V）、进行比较的预期原值（A） 和拟写入的新值(B)。CAS指令执行时，当且仅当内存地址V中的值与预期值A相等时，将内存地址V中的值修改为B，否则就什么都不做。整个比较并替换的操作是一个原子操作。有以下缺点：</p>
<ul>
<li><strong>ABA问题</strong>。</li>
<li><strong>循环时间长</strong>。</li>
<li><strong>只能保证一个变量的原子操作</strong>。</li>
</ul>
</li>
<li><p><strong>什么是ABA问题？ABA问题怎么解决？</strong></p>
<p>CAS 的使用流程通常如下：1）首先从地址 V 读取值 A；2）根据 A 计算目标值 B；3）通过 CAS 以原子的方式将地址 V 中的值从 A 修改为 B。</p>
<p>但是在第1步中读取的值是A，并且在第3步修改成功了，我们就能说它的值在第1步和第3步之间没有被其他线程改变过了吗？</p>
<p>如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ABA”问题。Java并发包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。</p>
</li>
</ul>
<h3 id="2）公平锁与非公平锁"><a href="#2）公平锁与非公平锁" class="headerlink" title="2）公平锁与非公平锁"></a>2）公平锁与非公平锁</h3><p>根据多个线程是否按照申请锁的顺序来获取锁，Java中将实现锁的方式分为两种：</p>
<ul>
<li><p>一种是使用Java自带的关键字<strong>synchronized</strong>对相应的类或者方法以及代码块进行加锁，只能是非公平锁。</p>
</li>
<li><p>另一种是<strong>ReentrantLock</strong>，默认非公平但可实现公平的一把锁。</p>
</li>
<li><p>synchronized：非公平锁</p>
</li>
<li><p>ReentrantLock：默认非公平，可以公平。基于内部类：</p>
<ul>
<li>FairSyn：公平锁</li>
<li>NonFairSync：非公平锁</li>
</ul>
<p>并且依赖于AQS。</p>
</li>
</ul>
<p>tryAcquire()是一个抽象方法，是公平与非公平的实现原理所在。</p>
<h3 id="3）-无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁"><a href="#3）-无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁" class="headerlink" title="3） 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁"></a>3） 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁</h3><p>这四种锁是指锁的状态，专门针对synchronized的。synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。</p>
<p><strong>锁的状态</strong>（这些锁不等同于Java API中的ReentratLock这种锁，这些锁是概念上的，是JDK1.6中为了对synchronized同步关键字进行优化而产生的的锁机制。）对象头中有Mark Word字段，含有所得状态信息。</p>
<ul>
<li><p><strong>无锁</strong>——锁标志位 01、偏向锁标志位 0</p>
</li>
<li><p><strong>偏向锁</strong>——锁标志位 01、偏向锁标志位 1</p>
<p>通俗的讲，偏向锁就是在运行过程中，对象的锁偏向某个线程。即在开启偏向锁机制的情况下，某个线程获得锁，当该线程下次再想要获得锁时，不需要再获得锁（即忽略synchronized关键词），直接就可以执行同步代码，比较适合竞争较少的情况。</p>
</li>
<li><p><strong>轻量级锁</strong>——锁标志位 00</p>
<p>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。轻量级锁不是用来替代传统的重量级锁的，而是在没有多线程竞争的情况下，使用轻量级锁能够减少性能消耗，但是当多个线程同时竞争锁时，轻量级锁会膨胀为重量级锁。</p>
</li>
<li><p><strong>重量级锁</strong>——锁标志位 10 </p>
<p>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低</p>
</li>
</ul>
<img src="E:/面试/myJava.assets/image-20220504021022415.png" alt="image-20220504021022415" style="zoom: 33%;" />

<p><strong>synchronized 锁升级原理</strong>：</p>
<ul>
<li>在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id;</li>
<li>再次进入的时候会先判断threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，当前线程通过CAS操作竞争锁，若竞争成功，threadid 设置为当前线程ID，然后执行同步代码。</li>
<li>当前线程通过CAS竞争锁失败的情况下，说明有竞争，当到达全局安全点时之前获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。</li>
<li>通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。</li>
</ul>
<p><img src="E:\学习笔记\图片\image-20220608004006489.png" alt="image-20220608004006489"></p>
<p><strong>锁的升级的目的</strong>：</p>
<p>锁升级是<strong>为了减低了锁带来的性能消耗。</strong>在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p>
<h3 id="4）自旋锁-与-自适应锁"><a href="#4）自旋锁-与-自适应锁" class="headerlink" title="4）自旋锁 与 自适应锁"></a>4）自旋锁 与 自适应锁</h3><p><strong>自旋锁</strong>：许多情况下，共享数据的锁定状态持续时间较短，切换线程不值得，通过让线程执行循环等待锁的释放，不让出CPU。如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式。但是它也存在<strong>缺点</strong>：如果锁被其他线程长时间占用，一直不释放CPU，会带来许多的性能开销。<strong>实现原理一样是CAS</strong></p>
<p><strong>自适应自旋锁</strong>：这种相当于是对上面自旋锁优化方式的进一步优化，它的自旋的次数不再固定，其自旋的次数由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定，这就解决了自旋锁带来的缺点。</p>
<h3 id="5）为什么要引入偏向锁和轻量级锁？为什么重量级锁开销大？"><a href="#5）为什么要引入偏向锁和轻量级锁？为什么重量级锁开销大？" class="headerlink" title="5）为什么要引入偏向锁和轻量级锁？为什么重量级锁开销大？"></a>5）为什么要引入偏向锁和轻量级锁？为什么重量级锁开销大？</h3><p>重量级锁底层依赖于系统的同步函数来实现，在 linux 中使用 pthread_mutex_t（互斥锁）来实现。</p>
<p>这些底层的同步函数操作会涉及到：操作系统用户态和内核态的切换、进程的上下文切换，而这些操作都是比较耗时的，因此重量级锁操作的开销比较大。</p>
<p>而在很多情况下，可能获取锁时只有一个线程，或者是多个线程交替获取锁，在这种情况下，使用重量级锁就不划算了，因此引入了偏向锁和轻量级锁来降低没有并发竞争时的锁开销。</p>
<h3 id="6）锁消除"><a href="#6）锁消除" class="headerlink" title="6）锁消除"></a>6）锁消除</h3><p>消除锁是虚拟机另外一种锁的优化，这种优化更彻底，在JIT编译时，对运行上下文进行扫描，去除不可能存在竞争的锁。</p>
<h3 id="7）锁粗化"><a href="#7）锁粗化" class="headerlink" title="7）锁粗化"></a>7）锁粗化</h3><p>锁粗化是虚拟机对另一种极端情况的优化处理，通过扩大锁的范围，避免反复加锁和释放锁。</p>
<h3 id="8）synchronized-锁降级"><a href="#8）synchronized-锁降级" class="headerlink" title="8）synchronized 锁降级"></a>8）synchronized 锁降级</h3><p>JDK 1.6 之后为了提高 synchronized 的效率，才引入了偏向锁、轻量级锁。 随着锁竞争逐渐激烈，其状态会按照「无锁 &#x3D;&#x3D;&gt; 偏向锁 &#x3D;&#x3D;&gt; 轻量级锁 &#x3D;&#x3D;&gt; 重量级锁 」这个方向逐渐升级，并且不可逆，只能进行锁升级，而<strong>无法进行锁降级</strong>。</p>
<h3 id="9）互斥锁？"><a href="#9）互斥锁？" class="headerlink" title="9）互斥锁？"></a>9）互斥锁？</h3><ul>
<li><strong>synchronized——一种块结构</strong><ul>
<li>会在同步块的前后形成monitorenter和monitorexit这两个字节码指令。字节码指令都需要一个引用类型的参数来指明要锁定和解锁的对象。不指定时，根据synchronized修饰的方法类型来决定是取代码所在的对象实例还是取类型对应的Class对象来作为线程要持有的锁。</li>
</ul>
</li>
<li>JDK5起，提供了<strong>JUC包</strong>。——基于Lock接口，用非块结构实现互斥同步。</li>
</ul>
<h3 id="10）分段锁"><a href="#10）分段锁" class="headerlink" title="10）分段锁"></a>10）分段锁</h3><p>首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p>
<p>ConcurrentHashMap——数组+数组+链表</p>
<h3 id="11）读写锁"><a href="#11）读写锁" class="headerlink" title="11）读写锁"></a>11）读写锁</h3><ul>
<li>共享读，但只能一个写</li>
<li>适用于读远远大于写</li>
<li>读写锁由于需要额外维护读锁的状态，当并发不是很高的情况下，效率可能不如独占锁高。</li>
<li>Java的ReadWriteLock的主要实现主要为ReentrantReadWriteLock，其提供了以下特性：<ul>
<li>公平性选择：默认非公平，也可以公平。非公平的吞吐量大于公平</li>
<li>可重入：读线程获取读锁后可以再次获取读锁，写线程获取写锁之后可以再次获取写锁</li>
<li>可降级：写线程获取写锁之后，还能再次获取读锁，然后释放掉写锁之后，此时是读锁状态</li>
</ul>
</li>
</ul>
<h3 id="12）如何自己实现一个锁？"><a href="#12）如何自己实现一个锁？" class="headerlink" title="12）如何自己实现一个锁？"></a>12）如何自己实现一个锁？</h3><ul>
<li><p>需要一个锁标记，来记录当前持有锁的进程，考虑到它的原子性，我们用 AtomicReference 类来存放。</p>
</li>
<li><p>需要一个线程的等待集合，所以我们要定义一个list，考虑到先进先出机制，我们用 LinkedBlockingQueue 来存放线程集合。</p>
</li>
<li><p>线程执行完，会释放锁，此时要通知其他线程争抢锁，这里又涉及到线程通信。</p>
</li>
<li><p>PS：细致的话，还需要公平性，是否可重入等</p>
</li>
</ul>
<h2 id="10-Java中实现锁的方式"><a href="#10-Java中实现锁的方式" class="headerlink" title="10.Java中实现锁的方式"></a>10.Java中实现锁的方式</h2><p>两种：synchronized关键字和并发包中的锁类。</p>
<p>Lock接口的继承关系，ReentrantLock是Lock的重要实现类</p>
<p><img src="E:\学习笔记\图片\1771072-20200216201818148-1683117055.png" alt="img"></p>
<h3 id="synchronized和RenntrantLock的区别"><a href="#synchronized和RenntrantLock的区别" class="headerlink" title="synchronized和RenntrantLock的区别"></a>synchronized和RenntrantLock的区别</h3><p>① <strong>底层实现</strong></p>
<p>synchronized 是<strong>JVM</strong>层面的锁，是<strong>Java关键字</strong>，通过monitor对象来完成（monitorenter与monitorexit），对象只有在同步块或同步方法中才能调用wait&#x2F;notify方法，ReentrantLock 是从jdk1.5以来（java.util.concurrent.locks.Lock）提供的<strong>API层面</strong>的锁。</p>
<p>② <strong>是否可手动释放：</strong></p>
<p>synchronized 不需要用户去手动释放锁，synchronized 代码执行完后系统会自动让线程释放对锁的占用； ReentrantLock则需要用户去手动释放锁，如果没有手动释放锁，就可能导致死锁现象。一般通过lock()和unlock()方法配合try&#x2F;finally语句块来完成，使用释放更加灵活。</p>
<p>③ <strong>是否可中断</strong></p>
<p>synchronized是不可中断类型的锁，除非加锁的代码中出现异常或正常执行完成； ReentrantLock则可以中断</p>
<p>④ <strong>是否公平锁</strong></p>
<p>synchronized为非公平锁 ReentrantLock则即可以选公平锁也可以选非公平锁，通过构造方法new ReentrantLock时传入boolean值进行选择，为空默认false非公平锁，true为公平锁。</p>
<p>⑤ <strong>锁是否可绑定条件Condition</strong></p>
<p>synchronized不能绑定； ReentrantLock通过绑定Condition结合await()&#x2F;singal()方法实现线程的精确唤醒，而不是像synchronized通过Object类的wait()&#x2F;notify()&#x2F;notifyAll()方法要么随机唤醒一个线程要么唤醒全部线程。</p>
<p>⑥ <strong>锁的对象</strong></p>
<p>synchronzied锁的是对象，锁是保存在对象头里面的，根据对象头数据来标识是否有线程获得锁&#x2F;争抢锁；ReentrantLock锁的是线程，根据进入的线程和int类型的state标识锁的获得&#x2F;争抢。</p>
<h2 id="11-AQS——AbstractQueueSynchronizer-抽象队列同步器"><a href="#11-AQS——AbstractQueueSynchronizer-抽象队列同步器" class="headerlink" title="11.AQS——AbstractQueueSynchronizer(抽象队列同步器)"></a>11.AQS——AbstractQueueSynchronizer(抽象队列同步器)</h2><p><strong>AQS 核心思想</strong>是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p>
<p>AQS就是基于CLH队列（同步队列，FIFO双向队列），用volatile修饰共享变量state，线程通过CAS去改变状态符，成功则获取锁成功，失败则进入等待队列，等待被唤醒。</p>
<ul>
<li>AQS内部维护了一个int成员变量来表示同步状态，通过内置的FIFO同步队列来控制获取共享资源的线程。AQS主要做这么几件事：<ul>
<li>同步状态的维护管理</li>
<li>等待队列的维护管理</li>
<li>线程的阻塞与唤醒</li>
</ul>
</li>
<li>AQS采用<strong>模板方法模式</strong>，在内部维护了很多的模板的方法，子类只需要实现特定的几个方法（非抽象方法！！），就可以实现子类自己的需求。</li>
<li>基于AQS实现的组件：<ul>
<li>ReentrantLock——可重入锁</li>
<li>Semaphore——计数信号量</li>
<li>ReentrantReadWriteLock——读写锁</li>
</ul>
</li>
</ul>
<h2 id="12-线程池"><a href="#12-线程池" class="headerlink" title="12.线程池"></a>12.线程池</h2><p><strong>思想</strong>：线程池在系统启动时即创建大量空闲的线程，程序将一个Runnable对象或Callable对象传给线程池，线程池就会启动一个空闲的线程来执行他们的run()或call()方法，当执行结束后，该线程并不会死亡，而是再次返回线程池中成为空闲状态，等待执行下一个Runnable对象的run()或call()方法。</p>
<h3 id="使用线程池的好处："><a href="#使用线程池的好处：" class="headerlink" title="使用线程池的好处："></a><strong>使用线程池的好处</strong>：</h3><ul>
<li><strong>降低资源消耗</strong>。 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。 当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<h3 id="线程池的状态："><a href="#线程池的状态：" class="headerlink" title="线程池的状态："></a><strong>线程池的状态</strong>：</h3><ul>
<li><strong>Running</strong>：能接受新提交的任务，并且能处理阻塞队列中的任务。</li>
<li><strong>Shutdown</strong>：关闭状态，不再接受新任务，但是可以继续处理阻塞队列中已保存的任务。</li>
<li><strong>Stop</strong>：不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。</li>
<li><strong>Tidying</strong>：如果所有的任务都已终止，workerCount为0，线程池进入该状态后会调用terminated()方法（默认啥也不做）进入Terminated状态。</li>
<li><strong>Terminated</strong>：在terminated()方法执行完后进入该状态。</li>
</ul>
<h3 id="线程池中的关键参数"><a href="#线程池中的关键参数" class="headerlink" title="线程池中的关键参数"></a>线程池中的关键参数</h3><p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p>
<ul>
<li><strong><code>corePoolSize</code> :</strong> 核心线程数线程数定义了最小可以同时运行的线程数量。</li>
<li><strong><code>maximumPoolSize</code> :</strong> 最大线程数。当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li><strong><code>workQueue</code>:</strong> 工作队列。当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>
</ul>
<p><code>ThreadPoolExecutor</code>其他常见参数 :</p>
<ol>
<li><strong><code>keepAliveTime</code></strong>:存活时间。当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li>
<li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li>
<li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li>
<li><strong><code>handler</code></strong> :饱和策略。关于饱和策略下面单独介绍一下。</li>
</ol>
<h3 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a>饱和策略</h3><p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p>
<ul>
<li><strong><code>ThreadPoolExecutor.AbortPolicy</code></strong> ：抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li>
<li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code></strong> ：调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li>
<li><strong><code>ThreadPoolExecutor.DiscardPolicy</code></strong> ：不处理新任务，直接丢弃掉。</li>
<li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code></strong> ： 此策略将丢弃最早的未处理的任务请求。</li>
</ul>
<h3 id="shutdown-与-shutdownNow-的区别："><a href="#shutdown-与-shutdownNow-的区别：" class="headerlink" title="shutdown() 与 shutdownNow()的区别："></a>shutdown() 与 shutdownNow()的区别：</h3><ul>
<li><strong>shutdown</strong>() ：关闭线程池，线程池的状态变为 SHUTDOWN。线程池不再接受新任务了，但是队列里的任务得执行完毕。</li>
<li><strong>shutdownNow</strong>() ：关闭线程池，线程的状态变为 STOP。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。<br>shutdownNow的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终</li>
</ul>
<h3 id="执行execute-方法和submit-方法的区别是什么呢？"><a href="#执行execute-方法和submit-方法的区别是什么呢？" class="headerlink" title="执行execute()方法和submit()方法的区别是什么呢？"></a><strong>执行execute()方法和submit()方法的区别是什么呢？</strong></h3><ul>
<li><strong>execute() 方法</strong>用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</li>
<li><strong>submit()方法</strong>用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 get（long timeout，TimeUnit unit） 方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li>
</ul>
<h3 id="Executor和Executors的区别？"><a href="#Executor和Executors的区别？" class="headerlink" title="Executor和Executors的区别？"></a><strong>Executor和Executors的区别？</strong></h3><ul>
<li>Executors <strong>工具类</strong>的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。</li>
<li>Executor <strong>接口</strong>对象能执行我们的线程任务。ExecutorService接口继承了Executor接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。</li>
</ul>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><h4 id="造成可见性问题的原因"><a href="#造成可见性问题的原因" class="headerlink" title="造成可见性问题的原因"></a>造成可见性问题的原因</h4><p>在Java中造成可见性问题的原因是<code>Java内存模型(JMM)</code>，在Java内存模型中，规定了共享变量是存放在<code>主内存</code>中，然后每个线程都有自己的<code>工作内存</code>，而线程对共享变量的操作，必须先从主内存中读到工作内存中去，至于什么时候写回到主内存是不可预知的，这就导致每个线程之间对共享变量的操作是封闭的，其他线程不可见的。</p>
<h4 id="volatile如何解决可见性问题"><a href="#volatile如何解决可见性问题" class="headerlink" title="volatile如何解决可见性问题"></a>volatile如何解决可见性问题</h4><p>有volatile修饰的共享变量进行写操作的时候多出一条带<code>lock前缀的指令</code>，如下所示</p>
<p><img src="E:\学习笔记\图片\20200510191415431.png" alt="在这里插入图片描述"></p>
<p>lock前缀的指令在多核处理器下会引发两件事情<br><code>1. 将当前处理器缓存行的数据写回到系统内存。</code><br><code>2. 这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</code></p>
<p>为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存后再进行操作，但是操作完了不知道什么时候写回内存。而对声明了volatile关键字的变量进行写操作，JVM会向处理器发送一条lock前缀的指令，将这个变量所在的缓存行立即写回系统内存。并且为了保证各个处理器的缓存是一致的，实现了<code>缓存一致性协议</code>，各个处理通过<code>嗅探</code>在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成<code>无效状态</code>，那么下次对这个数据进行操作，就会重新从系统内存中获取最新的值。对应JMM来说就是：</p>
<ol>
<li><code>Lock前缀的指令让线程工作内存中的值写回主内存中；</code></li>
<li><code>通过缓存一致性协议，其他线程如果工作内存中存了该共享变量的值，就会失效；</code></li>
<li><code>其他线程会重新从主内存中获取最新的值；</code></li>
</ol>
<h4 id="volatile保证有序性的原理"><a href="#volatile保证有序性的原理" class="headerlink" title="volatile保证有序性的原理"></a>volatile保证有序性的原理</h4><blockquote>
<p>为了性能优化，JVM会在不改变<code>数据依赖性</code>的情况下，允许<code>编译器和处理器对指令序列进行重排序</code>，而有序性问题指的就是程序代码执行的顺序与程序员编写程序的顺序不一致，导致程序结果不正确的问题。而加了volatile修饰的共享变量，则通过<code>内存屏障</code>解决了多线程下有序性问题。</p>
</blockquote>
<p>加了volatile关键字以后，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序</p>
<h3 id="4-volatile和synchronized的区别？"><a href="#4-volatile和synchronized的区别？" class="headerlink" title="4.volatile和synchronized的区别？"></a>4.<strong>volatile和synchronized的区别？</strong></h3><ul>
<li><strong>本质：</strong>volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</li>
<li><strong>锁级别：</strong>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。</li>
<li><strong>原子性：</strong>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。</li>
<li><strong>阻塞</strong>：volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。</li>
<li><strong>优化</strong>：volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化</li>
</ul>
<h3 id="5-Synchronized与Lock的区别？"><a href="#5-Synchronized与Lock的区别？" class="headerlink" title="5. Synchronized与Lock的区别？"></a>5. <strong>Synchronized与Lock的区别？</strong></h3><ul>
<li>Synchronized是Java关键字，在JVM层面实现加解锁；Lock是接口，在代码层面实现加解锁。</li>
<li>Synchronized可以用在代码块、方法上；Lock只能写在代码上；</li>
<li>Synchronized在代码执行完成或出现异常时自动解锁；Lock必须显示解锁；</li>
<li>Synchronized会使拿不到锁的线程一直等待；Lock可以设置获取锁失败的超时时间；</li>
<li>Synchronized无法得知是否会成功获得锁；Lock可以通过tryLock得知加锁是否成功；</li>
<li>Synchronized锁可重入、不可中断、非公平；Lock锁可重入、可中断、可公平&#x2F;不公平，还可以分读写锁。</li>
</ul>
<h2 id="13-Java内存模型（JMM）"><a href="#13-Java内存模型（JMM）" class="headerlink" title="13.Java内存模型（JMM）"></a>13.Java内存模型（JMM）</h2><h3 id="1、JMM是什么"><a href="#1、JMM是什么" class="headerlink" title="1、JMM是什么"></a>1、JMM是什么</h3><p><strong>JMM 看作是 Java 定义的并发编程相关的一组规范</strong>，用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果，JMM规范了Java虚拟机与计算机内存是如何协同工作的。<strong>定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的细节</strong>。其主要目的是为了简化多线程编程，增强程序可移植性的。例如：规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。</p>
<p>在当前的 Java 内存模型下，线程可以把变量保存在 <strong>工作内存</strong> （比如机器的寄存器）中，而不是直接在主存中进行读写。</p>
<p><strong>什么是主内存？什么是工作内存？</strong></p>
<ul>
<li><strong>主内存</strong> ：所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)</li>
<li><strong>工作内存</strong> ：每个线程都有一个私有的本地内存来存储共享变量的副本，并且，每个线程只能访问自己的本地内存，无法访问其他线程的本地内存。本地内存是 JMM 抽象出来的一个概念，存储了主内存中的共享变量副本。</li>
</ul>
<p>Java 内存模型的抽象示意图如下：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/concurrent/jmm.png" alt="JMM(E:\学习笔记\图片\Java内存模型.png)"></p>
<h3 id="2-为什么要有Java内存模型"><a href="#2-为什么要有Java内存模型" class="headerlink" title="2.为什么要有Java内存模型"></a>2.为什么要有Java内存模型</h3><p>在当前的硬件内存模型下，运行多线程会存在一些问题。（如下）1.而Java 语言是跨平台的，它需要自己提供一套内存模型以屏蔽系统差异。2.JMM 定义了一些规范来解决这些问题，开发发者可以利用这些规范更方便地开发多线程程序。不需要了解底层原理，直接使用并发相关的一些关键字和类即可。</p>
<h4 id="缓存一致性问题："><a href="#缓存一致性问题：" class="headerlink" title="缓存一致性问题："></a><strong>缓存一致性问题</strong>：</h4><p>在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（MainMemory）。基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也引入了新的问题：缓存一致性（CacheCoherence）。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致的情况。CPU 为了解决内存缓存不一致性问题可以通过制定缓存一致协议（比如 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MESI%E5%8D%8F%E8%AE%AE">MESI 协议open in new window</a>）或者其他手段来解决。 操作系统通过 <strong>内存模型（Memory Model）</strong> 定义一系列规范来解决这个问题。无论是 Windows 系统，还是 Linux 系统，它们都有特定的内存模型。</p>
<h4 id="指令重排序问题："><a href="#指令重排序问题：" class="headerlink" title="指令重排序问题："></a><strong>指令重排序问题</strong>：</h4><p>为了提升执行速度&#x2F;性能，计算机在执行程序代码的时候，会对指令进行重排序。</p>
<p><strong>什么是指令重排序？</strong> 简单来说就是系统在执行代码的时候并不一定是按照你写的代码的顺序依次执行。</p>
<p>常见的指令重排序有下面 2 种情况：</p>
<ul>
<li><strong>编译器优化重排</strong> ：编译器（包括 JVM、JIT 编译器等）在不改变单线程程序语义的前提下，重新安排语句的执行顺序。</li>
<li><strong>指令并行重排</strong> ：现代处理器采用了指令级并行技术(Instruction-Level Parallelism，ILP)来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
</ul>
<p>另外，内存系统也会有“重排序”，但有不是真正意义上的重排序。在 JMM 里表现为主存和本地内存的内容可能不一致，进而导致程序在多线程下执行可能出现问题。</p>
<p>Java 源代码会经历 <strong>编译器优化重排 —&gt; 指令并行重排 —&gt; 内存系统重排</strong> 的过程，最终才变成操作系统可执行的指令序列。</p>
<p><strong>指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong> ，所以在多线程下，指令重排序可能会导致一些问题。</p>
<p>编译器和处理器的指令重排序的处理方式不一样。对于编译器，通过禁止特定类型的编译器的方式来禁止重排序。对于处理器，通过插入内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）的方式来禁止特定类型的处理器重排序。指令并行重排和内存系统重排都属于是处理器级别的指令重排序。</p>
<h3 id="3、Java-内存区域和-JMM-有何区别？"><a href="#3、Java-内存区域和-JMM-有何区别？" class="headerlink" title="3、Java 内存区域和 JMM 有何区别？"></a>3、Java 内存区域和 JMM 有何区别？</h3><p> <strong>Java 内存区域和内存模型是完全不一样的两个东西</strong> ：</p>
<ul>
<li>JVM 内存结构和 Java 虚拟机的运行时区域相关，定义了 JVM 在运行时如何分区存储程序数据，就比如说堆主要用于存放对象实例。</li>
<li>Java 内存模型和 Java 的并发编程相关，抽象了线程和主内存之间的关系就比如说线程之间的共享变量必须存储在主内存中，规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。</li>
</ul>
<h2 id="13-ThreadLocal"><a href="#13-ThreadLocal" class="headerlink" title="13.ThreadLocal"></a>13.ThreadLocal</h2><h3 id="1-解决什么问题？"><a href="#1-解决什么问题？" class="headerlink" title="1.解决什么问题？"></a><strong>1.解决什么问题？</strong></h3><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong></p>
<p>JDK中提供的ThreadLocal类就是解决这个问题的。换句话说，类ThreadLocal主要解决的就是每个线程绑定自己的值，可以将ThreadLocal类比喻成全局存放数据的盒子，盒子中可以存储每个线程的私有数据。</p>
<p><strong>ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用</strong>。作用：提供一个<strong>线程内</strong>公共变量（比如当前请求的用户信息），减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度，或者为线程提供一个<strong>私有的变量副本</strong>，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。</p>
<h3 id="2-原理："><a href="#2-原理：" class="headerlink" title="2.原理："></a><strong>2.原理</strong>：</h3><p><strong>每个<code>Thread</code>中都具备一个<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为 key ，Object 对象为 value 的键值对。</strong>此处key为弱引用，value为强引用。【弱引用是为了GC】</p>
<p><img src="E:\学习笔记\图片\1156565-20170724100913883-243740206.png" alt="img"></p>
<p>ThreadLocalMap类的定义是在ThreadLocal类中（内部类），真正的引用却是在Thread类中。</p>
<p>Thread类中有一行，引用ThreadLocalMap</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained by the ThreadLocal class. */</span></span><br><span class="line">   ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>ThreadLocalMap中用于存储数据的entry定义：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    <span class="type">Object</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="type">Entry</span>(<span class="type">ThreadLocal</span>&lt;?&gt; k, <span class="type">Object</span> v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Map的key是ThreadLocal类的实例对象，value为用户的值</strong></p>
<h4 id="ThreadLocal的工作原理"><a href="#ThreadLocal的工作原理" class="headerlink" title="ThreadLocal的工作原理"></a><strong>ThreadLocal的工作原理</strong></h4><ol>
<li><strong>Thread类中有一个成员变量属于ThreadLocalMap类</strong>(一个定义在ThreadLocal类中的内部类)，它是一个Map，他的key是ThreadLocal实例对象。</li>
<li><strong>当为ThreadLocal类的对象set值时，首先获得当前线程的ThreadLocalMap类属性</strong>，然后以ThreadLocal类的对象为key，设定value。get值时则类似。</li>
<li><strong>ThreadLocal变量的活动范围为某线程</strong>，是该线程“专有的，独自霸占”的，对该变量的所有操作均由该线程完成！也就是说，ThreadLocal 不是用来解决共享对象的多线程访问的竞争问题的，因为ThreadLocal.set() 到线程中的对象是该线程自己使用的对象，其他线程是不需要访问的，也访问不到的。当线程终止后，这些值会作为垃圾回收。</li>
<li>由ThreadLocal的工作原理决定了：每个线程独自拥有一个变量，并非是共享的</li>
</ol>
<h4 id="如过实现一个线程多个ThreadLocal对象，每一个ThreadLocal对象是如何区分的呢？"><a href="#如过实现一个线程多个ThreadLocal对象，每一个ThreadLocal对象是如何区分的呢？" class="headerlink" title="如过实现一个线程多个ThreadLocal对象，每一个ThreadLocal对象是如何区分的呢？"></a>如过实现一个线程多个ThreadLocal对象，每一个ThreadLocal对象是如何区分的呢？</h4><p>​	对于每一个ThreadLocal对象，都有一个final修饰的int型的<strong>threadLocalHashCode</strong>不可变属性，对于<strong>基本数据类型，可以认为它在初始化后就不可以进行修改，所以可以唯一确定一个ThreadLocal对象。</strong><br>　　但是如何保证两个同时实例化的ThreadLocal对象有不同的threadLocalHashCode属性：在ThreadLocal类中，还包含了一个static修饰的AtomicInteger（[əˈtɒmɪk]提供原子操作的Integer类）成员变量（即类变量）和一个static final修饰的常量（作为两个相邻nextHashCode的差值）。由于nextHashCode是类变量，所以每一次调用ThreadLocal类都可以保证nextHashCode被更新到新的值，并且下一次调用ThreadLocal类，这个被更新的值仍然可用，同时AtomicInteger保证了nextHashCode自增的原子性。</p>
<h4 id="为什么不直接用线程id来作为ThreadLocalMap的key？"><a href="#为什么不直接用线程id来作为ThreadLocalMap的key？" class="headerlink" title="为什么不直接用线程id来作为ThreadLocalMap的key？"></a>为什么不直接用线程id来作为ThreadLocalMap的key？</h4><p>　　这一点很容易理解，因为<strong>直接用线程id来作为ThreadLocalMap的key，无法区分放入ThreadLocalMap中的多个value。</strong>比如我们放入了两个字符串，你如何知道我要取出来的是哪一个字符串呢？<br>　　而使用ThreadLocal作为key就不一样了，由于每一个ThreadLocal对象都可以由threadLocalHashCode属性唯一区分或者说每一个<strong>ThreadLocal对象都可以由这个对象的名字唯一区分</strong>（下面的例子），所以可以用不同的ThreadLocal作为key，区分不同的value，方便存取。</p>
<h3 id="3-为什么key要设置成弱引用"><a href="#3-为什么key要设置成弱引用" class="headerlink" title="3.为什么key要设置成弱引用"></a>3.为什么key要设置成弱引用</h3><h4 id="对象的引用关系"><a href="#对象的引用关系" class="headerlink" title="对象的引用关系"></a>对象的引用关系</h4><p><img src="E:\学习笔记\图片\1156565-20170724121152430-1111069410.png" alt="img"></p>
<p>ThreadLocalMap在ThreadLocal中定义，在中引用了Thread，外界是通过ThreadLocal对象来对ThreadLocalMap进行操作的（ThreadLocalMap是ThreadLocal的内部类），假设外界使用ThreadLocal的对象被被回收，即ThreadLocalMap指向的ThreadLocal也不会再被访问，在此时应该对其（ThreadLocalMap引用的）进行GC。但是由于ThreadLocalMap被Thread引用，假如ThreadLocal为强引用，只要线程一直运行，因为ThreadLocal放在线程中的ThreadLocalMap中，**ThreadLocal一直被线程对象引用，所以在线程销毁之前都是可达的，都无法<code>GC</code>**，因此采用弱引用（只要发生GC，只有弱引用指向的对象就会被回收）</p>
<h3 id="4-内存泄漏（key为弱引用）"><a href="#4-内存泄漏（key为弱引用）" class="headerlink" title="4.内存泄漏（key为弱引用）"></a>4.内存泄漏（key为弱引用）</h3><p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</p>
<p>这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。<code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法</p>
<h3 id="5-为什么value不设置为弱引用"><a href="#5-为什么value不设置为弱引用" class="headerlink" title="5.为什么value不设置为弱引用"></a>5.为什么value不设置为弱引用</h3><p>假如key为弱引用，在其他的地方没有引用时，直接将其GC，而此时我们的<code>ThreadLocal</code>还处于使用期间，就会造成Value为null的错误，所以将其设置为强引用。</p>
<h3 id="6-很多人说建议把ThreadLocal修饰为static，为什么？"><a href="#6-很多人说建议把ThreadLocal修饰为static，为什么？" class="headerlink" title="6.很多人说建议把ThreadLocal修饰为static，为什么？"></a><strong>6.很多人说建议把ThreadLocal修饰为static，为什么？</strong></h3><p>ThreadLocal能实现了线程的数据隔离，不在于它自己本身，而在于Thread的ThreadLocalMap。所以，ThreadLocal可以只初始化一次，只分配一块存储空间就足以了，没必要作为成员变量多次被初始化。</p>
<h3 id="7-应用场景"><a href="#7-应用场景" class="headerlink" title="7.应用场景"></a>7.应用场景</h3><ul>
<li>数据库连接的时候，我们会创建一个<code>Connection</code>连接，让不同的线程使用。这个时候就会出现多个线程争抢同一个资源的情况。因此使用TreadLocal管理JDBC连接Connection，保证每个线程使用各自连接。</li>
<li>管理Session会话，将Session保存在ThreadLocal中，使线程多次处理会话时始终是同一个属于自己的Session。</li>
</ul>
<h3 id="8-实际应用"><a href="#8-实际应用" class="headerlink" title="8.实际应用"></a>8.实际应用</h3><p>Spring提供了事务相关的操作，而事务是得保证一组操作同时成功或失败的，这意味着一次事务的所有操作需要在同一个数据库连接上，Spring就是用的ThreadLocal来实现，ThreadLocal存储的类型是一个Map，Map中的key 是DataSource，value 是Connection（为了应对多数据源的情况，所以是一个Map），用了ThreadLocal保证了同一个线程获取一个Connection对象。</p>
<h3 id="9-使用建议"><a href="#9-使用建议" class="headerlink" title="9.使用建议"></a>9.使用建议</h3><ul>
<li>用static修饰，static ThreadLocal headerLocal &#x3D; new ThreadLocal();</li>
<li>使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法</li>
</ul>
<h2 id="14-Volatile"><a href="#14-Volatile" class="headerlink" title="14.Volatile"></a>14.Volatile</h2><p>保证可见性和有序性</p>
<h3 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h3><ul>
<li>当对volatile变量执行写操作后，JMM会把工作内存中的最新变量值强制刷新到主内存</li>
<li>写操作会导致其他线程中的缓存无效</li>
</ul>
<p>这样，其他线程使用缓存时，发现本地工作内存中此变量无效，便从主内存中获取，这样获取到的变量便是最新的值，实现了线程的可见性。</p>
<h3 id="如何保证有序性"><a href="#如何保证有序性" class="headerlink" title="如何保证有序性"></a>如何保证有序性</h3><p>通过添加内存屏障来保证。确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面。</p>
<h2 id="15-Sychronized"><a href="#15-Sychronized" class="headerlink" title="15.Sychronized"></a>15.Sychronized</h2><p><code>synchronized</code>关键字同时保证上述三种特性（原子性、有序性、可见性）。</p>
<ul>
<li><p><code>synchronized</code>是同步锁，同步块内的代码相当于同一时刻单线程执行，故不存在原子性和指令重排序的问题</p>
</li>
<li><p><code>synchronized</code>关键字的语义JMM有两个规定，保证其实现内存可见性：</p>
<ul>
<li><p>线程解锁前，必须把共享变量的最新值刷新到主内存中；</p>
</li>
<li><p>线程加锁前，将清空工作内存中共享变量的值，从主内存中冲洗取值。</p>
</li>
</ul>
</li>
</ul>
<h3 id="如何使用-synchronized-关键字？"><a href="#如何使用-synchronized-关键字？" class="headerlink" title="如何使用 synchronized 关键字？"></a>如何使用 synchronized 关键字？</h3><p>synchronized 关键字最主要的三种使用方式：</p>
<ol>
<li>修饰实例方法</li>
<li>修饰静态方法</li>
<li>修饰代码块</li>
</ol>
<p><strong>1、修饰实例方法</strong> （锁当前对象实例）</p>
<p>给当前对象实例加锁，进入同步代码前要获得 <strong>当前对象实例的锁</strong> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、修饰静态方法</strong> （锁当前类）</p>
<p>给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 <strong>当前 class 的锁</strong>。</p>
<p>这是因为静态成员不属于任何一个实例对象，归整个类所有，不依赖于类的特定实例，被类的所有实例共享。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态 <code>synchronized</code> 方法和非静态 <code>synchronized</code> 方法之间的调用互斥么？不互斥！如果一个线程 A 调用一个实例对象的非静态 <code>synchronized</code> 方法，而线程 B 需要调用这个实例对象所属类的静态 <code>synchronized</code> 方法，是允许的，不会发生互斥现象，因为访问静态 <code>synchronized</code> 方法占用的锁是当前类的锁，而访问非静态 <code>synchronized</code> 方法占用的锁是当前实例对象锁。</p>
<p><strong>3、修饰代码块</strong> （锁指定对象&#x2F;类）</p>
<p>对括号里指定的对象&#x2F;类加锁：</p>
<ul>
<li><code>synchronized(object)</code> 表示进入同步代码库前要获得 <strong>给定对象的锁</strong>。</li>
<li><code>synchronized(类.class)</code> 表示进入同步代码前要获得 <strong>给定 Class 的锁</strong></li>
</ul>
<h3 id="构造方法可以使用-synchronized-关键字修饰么？"><a href="#构造方法可以使用-synchronized-关键字修饰么？" class="headerlink" title="构造方法可以使用 synchronized 关键字修饰么？"></a>构造方法可以使用 synchronized 关键字修饰么？</h3><p>先说结论：<strong>构造方法不能使用 synchronized 关键字修饰。</strong></p>
<p>构造方法本身就属于线程安全的，不存在同步的构造方法一说</p>
<h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p>
<p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 <code>monitor</code></strong> 的持有权。</p>
<p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。</p>
<h3 id="synchronized-和-ReentrantLock-的区别"><a href="#synchronized-和-ReentrantLock-的区别" class="headerlink" title="synchronized 和 ReentrantLock 的区别"></a>synchronized 和 ReentrantLock 的区别</h3><h4 id="两者都是可重入锁"><a href="#两者都是可重入锁" class="headerlink" title="两者都是可重入锁"></a>两者都是可重入锁</h4><p><strong>“可重入锁”</strong> 指的是自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。</p>
<h4 id="synchronized-依赖于-JVM-而-ReentrantLock-依赖于-API"><a href="#synchronized-依赖于-JVM-而-ReentrantLock-依赖于-API" class="headerlink" title="synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API"></a>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</h4><p><code>synchronized</code> 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 <code>synchronized</code> 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。<code>ReentrantLock</code> 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try&#x2F;finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p>
<h4 id="ReentrantLock-比-synchronized-增加了一些高级功能"><a href="#ReentrantLock-比-synchronized-增加了一些高级功能" class="headerlink" title="ReentrantLock 比 synchronized 增加了一些高级功能"></a>ReentrantLock 比 synchronized 增加了一些高级功能</h4><p>相比<code>synchronized</code>，<code>ReentrantLock</code>增加了一些高级功能。主要来说主要有三点：</p>
<ul>
<li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li>
<li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li>
<li><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>&#x2F;<code>notifyAll()</code>方法相结合可以实现等待&#x2F;通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</li>
</ul>
<h3 id="synchronized中有几个队列"><a href="#synchronized中有几个队列" class="headerlink" title="synchronized中有几个队列"></a>synchronized中有几个队列</h3><p>三个</p>
<p>同步队列：排队取锁的线程所在的队列</p>
<p>等待队列：调用 <code>wait</code> 方法后，线程会从同步队列转移到等待队列</p>
<p>synchronized 中同步队列有两个 _cxq 与 EntryList，基于不同的 QMode 来调整线程的出队策略</p>
<p>_cxq (竞争队列): <strong>抢锁失败后，线程会进入此队列</strong>，此队列大部分情况时<strong>单向链表</strong>，入队策略是 <strong>后来者当头</strong></p>
<p>EntryList: 默认情况下（根据 Knob_MoveNotifyee 判断，源码默认为 2 ，当 EntryList 不为空，Policy &#x3D;&#x3D; 2 时，参阅 源码 1720-1735 行)，<strong>线程被唤醒时，会从等待队列转移到此队列</strong>，此队列是一个<strong>双向链表</strong></p>
<p>WaitSet: 等待队列，调用 wait 方法后，线程会进入此队列</p>
<h2 id="16-volatile和synchronized的区别"><a href="#16-volatile和synchronized的区别" class="headerlink" title="16.volatile和synchronized的区别"></a>16.volatile和synchronized的区别</h2><ul>
<li><code>volatile</code> 关键字是线程同步的轻量级实现，所以 <code>volatile</code>性能肯定比<code>synchronized</code>关键字要好 。但是 <code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块 。</li>
<li><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</li>
<li><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</li>
</ul>
<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="1-文件系统"><a href="#1-文件系统" class="headerlink" title="1.文件系统"></a>1.文件系统</h2><p><strong>在 Linux 操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。</strong> 也就是说在 Linux 系统中有一个重要的概念：<strong>一切都是文件。</strong></p>
<h2 id="2-inode-介绍"><a href="#2-inode-介绍" class="headerlink" title="2.inode 介绍"></a>2.inode 介绍</h2><p><strong>inode 是 linux&#x2F;unix 文件系统的基础。那么，inode 是什么?有什么作用呢?</strong></p>
<p>硬盘的最小存储单位是扇区(Sector)，块(block)由多个扇区组成。文件数据存储在块中。块的最常见的大小是 4kb，约为 8 个连续的扇区组成（每个扇区存储 512 字节）。一个文件可能会占用多个 block，但是一个块只能存放一个文件。</p>
<p>虽然，我们将文件存储在了块(block)中，但是我们还需要一个空间来存储文件的 <strong>元信息 metadata</strong> ：如某个文件被分成几块、每一块在的地址、文件拥有者，创建时间，权限，大小等。这种 <strong>存储文件元信息的区域就叫 inode</strong>，译为索引节点：<strong>i（index）+node</strong>。 每个文件都有一个 inode，存储文件的元信息。</p>
<p>可以使用 <code>stat</code> 命令可以查看文件的 inode 信息。每个 inode 都有一个号码，Linux&#x2F;Unix 操作系统不使用文件名来区分文件，而是使用 inode 号码区分不同的文件。</p>
<p>简单来说：inode 就是用来维护某个文件被分成几块、每一块在的地址、文件拥有者，创建时间，权限，大小等信息。</p>
<p>简单总结一下：</p>
<ul>
<li><strong>inode</strong> ：记录文件的属性信息，可以使用 stat 命令查看 inode 信息。</li>
<li><strong>block</strong> ：实际文件的内容，如果一个文件大于一个块时候，那么将占用多个 block，但是一个块只能存放一个文件。（因为数据是由 inode 指向的，如果有两个文件的数据存放在同一个块中，就会乱套了）</li>
</ul>
<p><img src="E:\学习笔记\图片\image-20220809111336625.png" alt="image-20220809111336625"></p>
<h2 id="3-Linux-文件类型"><a href="#3-Linux-文件类型" class="headerlink" title="3.Linux 文件类型"></a>3.Linux 文件类型</h2><p>Linux 支持很多文件类型，其中非常重要的文件类型有: <strong>普通文件</strong>，<strong>目录文件</strong>，<strong>链接文件</strong>，<strong>设备文件</strong>，<strong>管道文件</strong>，<strong>Socket 套接字文件</strong>等。</p>
<ul>
<li><strong>普通文件（-）</strong> ： 用于存储信息和数据， Linux 用户可以根据访问权限对普通文件进行查看、更改和删除。比如：图片、声音、PDF、text、视频、源代码等等。</li>
<li><strong>目录文件（d，directory file）</strong> ：目录也是文件的一种，用于表示和管理系统中的文件，目录文件中包含一些文件名和子目录名。打开目录事实上就是打开目录文件。</li>
<li><strong>符号链接文件（l，symbolic link）</strong> ：保留了指向文件的地址而不是文件本身。</li>
<li><strong>字符设备（c，char）</strong> ：用来访问字符设备比如键盘。</li>
<li><strong>设备文件（b，block）</strong> ： 用来访问块设备比如硬盘、软盘。</li>
<li><strong>管道文件(p,pipe)</strong> : 一种特殊类型的文件，用于进程之间的通信。</li>
<li><strong>套接字(s,socket)</strong> ：用于进程间的网络通信，也可以用于本机之间的非网络通信。</li>
</ul>
<h2 id="4-Linux-目录树"><a href="#4-Linux-目录树" class="headerlink" title="4.Linux 目录树"></a>4.Linux 目录树</h2><p>所有可操作的计算机资源都存在于目录树这个结构中，对计算资源的访问，可以看做是对这棵目录树的访问。</p>
<p><strong>Linux 的目录结构如下：</strong></p>
<p>Linux 文件系统的结构层次鲜明，就像一棵倒立的树，最顶层是其根目录：<img src="E:\学习笔记\图片\image-20220809111724762.png" alt="image-20220809111724762"></p>
<p><strong>常见目录说明：</strong></p>
<ul>
<li><strong>&#x2F;bin：</strong> 存放二进制可执行文件(ls、cat、mkdir 等)，常用命令一般都在这里；</li>
<li><strong>&#x2F;etc：</strong> 存放系统管理和配置文件；</li>
<li><strong>&#x2F;home：</strong> 存放所有用户文件的根目录，是用户主目录的基点，比如用户 user 的主目录就是&#x2F;home&#x2F;user，可以用~user 表示；</li>
<li><strong>&#x2F;usr ：</strong> 用于存放系统应用程序；</li>
<li><strong>&#x2F;opt：</strong> 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把 tomcat 等都安装到这里；</li>
<li><strong>&#x2F;proc：</strong> 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；</li>
<li><strong>&#x2F;root：</strong> 超级用户（系统管理员）的主目录（特权阶级^o^）；</li>
<li><strong>&#x2F;sbin:</strong> 存放二进制可执行文件，只有 root 才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如 ifconfig 等；</li>
<li><strong>&#x2F;dev：</strong> 用于存放设备文件；</li>
<li><strong>&#x2F;mnt：</strong> 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；</li>
<li><strong>&#x2F;boot：</strong> 存放用于系统引导时使用的各种文件；</li>
<li><strong>&#x2F;lib ：</strong> 存放着和系统运行相关的库文件 ；</li>
<li><strong>&#x2F;tmp：</strong> 用于存放各种临时文件，是公用的临时文件存储点；</li>
<li><strong>&#x2F;var：</strong> 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；</li>
<li><strong>&#x2F;lost+found：</strong> 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows 下叫什么.chk）就在这里。</li>
</ul>
<h2 id="5-常用指令"><a href="#5-常用指令" class="headerlink" title="5.常用指令"></a>5.常用指令</h2><h3 id="目录切换命令"><a href="#目录切换命令" class="headerlink" title="目录切换命令"></a>目录切换命令</h3><ul>
<li><strong><code>cd usr</code>：</strong> 切换到该目录下 usr 目录</li>
<li><strong><code>cd ..（或cd../）</code>：</strong> 切换到上一层目录</li>
<li><strong><code>cd /</code>：</strong> 切换到系统根目录</li>
<li><strong><code>cd ~</code>：</strong> 切换到用户主目录</li>
<li><strong><code>cd -</code>：</strong> 切换到上一个操作所在目录</li>
</ul>
<h3 id="目录的操作命令-增删改查"><a href="#目录的操作命令-增删改查" class="headerlink" title="目录的操作命令(增删改查)"></a>目录的操作命令(增删改查)</h3><ul>
<li><strong><code>mkdir 目录名称</code>：</strong> 增加目录。</li>
<li>**<code>ls/ll</code>**（ll 是 ls -l 的别名，ll 命令可以看到该目录下的所有目录和文件的详细信息）：查看目录信息。</li>
<li><strong><code>rm [-rf] 目录</code> :</strong> 删除目录（删）。注意：rm 不仅可以删除目录，也可以删除其他文件或压缩包，为了增强大家的记忆， 无论删除任何目录或文件，都直接使用<code>rm -rf</code> 目录&#x2F;文件&#x2F;压缩包。</li>
</ul>
<h3 id="文件的操作命令-增删改查"><a href="#文件的操作命令-增删改查" class="headerlink" title="文件的操作命令(增删改查)"></a>文件的操作命令(增删改查)</h3><ul>
<li><strong><code>touch 文件名称</code>:</strong> 文件的创建（增）。</li>
<li><strong><code>vim 文件</code>：</strong> 修改文件的内容（改）。vim 编辑器是 Linux 中的强大组件，是 vi 编辑器的加强版，vim 编辑器的命令和快捷方式有很多，但此处不一一阐述，大家也无需研究的很透彻，使用 vim 编辑修改文件的方式基本会使用就可以了。在实际开发中，使用 vim 编辑器主要作用就是修改配置文件，下面是一般步骤： <code>vim 文件------&gt;进入文件-----&gt;命令模式------&gt;按i进入编辑模式-----&gt;编辑文件 -------&gt;按Esc进入底行模式-----&gt;输入：wq/q!</code> （输入 wq 代表写入内容并退出，即保存；输入 q!代表强制退出不保存）。</li>
<li><strong><code>rm -rf 文件</code>：</strong> 删除文件（删）。</li>
</ul>
<h3 id="压缩文件的操作命令"><a href="#压缩文件的操作命令" class="headerlink" title="压缩文件的操作命令"></a>压缩文件的操作命令</h3><p><strong>1）打包并压缩文件：</strong></p>
<p>Linux 中的打包文件一般是以.tar 结尾的，压缩的命令一般是以.gz 结尾的。而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。 命令：<code>tar -zcvf 打包压缩后的文件名 要打包压缩的文件</code> ，其中：</p>
<ul>
<li>z：调用 gzip 压缩命令进行压缩</li>
<li>c：打包文件</li>
<li>v：显示运行过程</li>
<li>f：指定文件名</li>
</ul>
<p>比如：假如 test 目录下有三个文件分别是：aaa.txt bbb.txt ccc.txt，如果我们要打包 test 目录并指定压缩后的压缩包名称为 test.tar.gz 可以使用命令：**<code>tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt</code> 或 <code>tar -zcvf test.tar.gz /test/</code>**</p>
<p><strong>2）解压压缩包：</strong></p>
<p>命令：<code>tar [-xvf] 压缩文件</code></p>
<p>其中：x：代表解压</p>
<p>示例：</p>
<ul>
<li>将 &#x2F;test 下的 test.tar.gz 解压到当前目录下可以使用命令：**<code>tar -xvf test.tar.gz</code>**</li>
<li>将 &#x2F;test 下的 test.tar.gz 解压到根目录&#x2F;usr 下:**<code>tar -xvf test.tar.gz -C /usr</code>**（- C 代表指定解压的位置）</li>
</ul>
<h3 id="Linux-的权限命令"><a href="#Linux-的权限命令" class="headerlink" title="Linux 的权限命令"></a>Linux 的权限命令</h3><p>操作系统中每个文件都拥有特定的权限、所属用户和所属组。权限是操作系统用来限制资源访问的机制，在 Linux 中权限一般分为读(readable)、写(writable)和执行(excutable)，分为三组。分别对应文件的属主(owner)，属组(group)和其他用户(other)，通过这样的机制来限制哪些用户、哪些组可以对特定的文件进行什么样的操作。</p>
<p>通过 <strong><code>ls -l</code></strong> 命令我们可以 查看某个目录下的文件或目录的权限</p>
<p>示例：在随意某个目录下<code>ls -l</code></p>
<p>![img](E:\学习笔记\图片\Tue, 09 Aug 2022 111805.png)</p>
<p>第一列的内容的信息解释如下：</p>
<p><img src="E:\学习笔记\图片\image-20220809111844929.png" alt="image-20220809111844929"></p>
<blockquote>
<p>下面将详细讲解文件的类型、Linux 中权限以及文件有所有者、所在组、其它组具体是什么？</p>
</blockquote>
<p><strong>文件的类型：</strong></p>
<ul>
<li>d： 代表目录</li>
<li>-： 代表文件</li>
<li>l： 代表软链接（可以认为是 window 中的快捷方式）</li>
</ul>
<p><strong>Linux 中权限分为以下几种：</strong></p>
<ul>
<li>r：代表权限是可读，r 也可以用数字 4 表示</li>
<li>w：代表权限是可写，w 也可以用数字 2 表示</li>
<li>x：代表权限是可执行，x 也可以用数字 1 表示</li>
</ul>
<p><strong>文件和目录权限的区别：</strong></p>
<p>对文件和目录而言，读写执行表示不同的意义。</p>
<p>对于文件：</p>
<table>
<thead>
<tr>
<th align="left">权限名称</th>
<th align="right">可执行操作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">r</td>
<td align="right">可以使用 cat 查看文件的内容</td>
</tr>
<tr>
<td align="left">w</td>
<td align="right">可以修改文件的内容</td>
</tr>
<tr>
<td align="left">x</td>
<td align="right">可以将其运行为二进制文件</td>
</tr>
</tbody></table>
<p>对于目录：</p>
<table>
<thead>
<tr>
<th align="left">权限名称</th>
<th align="right">可执行操作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">r</td>
<td align="right">可以查看目录下列表</td>
</tr>
<tr>
<td align="left">w</td>
<td align="right">可以创建和删除目录下文件</td>
</tr>
<tr>
<td align="left">x</td>
<td align="right">可以使用 cd 进入目录</td>
</tr>
</tbody></table>
<p>需要注意的是： <strong>超级用户可以无视普通用户的权限，即使文件目录权限是 000，依旧可以访问。</strong></p>
<p><strong>修改文件&#x2F;目录的权限的命令：<code>chmod</code></strong></p>
<p>示例：修改&#x2F;test 下的 aaa.txt 的权限为文件所有者有全部权限，文件所有者所在的组有读写权限，其他用户只有读的权限。</p>
<p><strong><code>chmod u=rwx,g=rw,o=r aaa.txt</code></strong> 或者 <strong><code>chmod 764 aaa.txt</code></strong></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAg0AAAD2BAMAAACn/KlUAAAAD1BMVEUAAACqqqr/AACqAAAAqgDVR6mAAAAHP0lEQVR42uxdAZKbMAzEzQe8P+j0BZnh/3+r0UI3ruJe7QsTCNo7iCIhX7wRBjbOMQUCgUAgEAgEAoFAILAbANlEMm9mSMglAlhInjor4dEFy5hOAjzzpDyhrFKWt9ibD/IIoKv8FkvxD+ChPF6Lh5SRVfMA/vCwelLxmMGAgZ4qi/wB+aQ8TMjQe70yQx60g7AeFgO+QvAR9VCWJg/A3zwsi3iwWviQ/YJLqx6migf1jR4z8ME8mJk9DynXPMj6gPGh5iGp+4/jAxwPqLPOXQ+YEqpzpLQZm4e8IGsbgh5lleWRB6yeQCAQCAQ+B8kZyKsDpzn4vwBwRsqbI13o4B88GFAJCMBVeVjVJwkIZbnq+CAegBz1sBgpeLg6Dw8CwpV5SJXskO3ZFcfJQCAQeI5fQ/g5fRrGehQ8rFmtM4v8L4lDIn8xlgXNKRjgqs4y0ECHnLIrD8iTR4sd2FofFclopCVwZag2ppHQISPsyUPq50EbQEYjDeCqyrJHGtiDB32ayVSIbYb+tV8g1aVOt59QYRAFjgfWCNO3TtddgjIZ2uYhAWZITuEWQH89IEM8JOj9YajFAzdWqa9eP6HClQNISM2DrQg+UZgd9SFfW7AF3fXAeS5bKsBXT4OhzQCe8ZA9D25ChXvVXNPd5EFDo9aadOEHXgIsk24eRGLKaE17EjwPtngeJs8Dw1jNikrHQ9VzujwpIttlHpoHMKGTBz0oyfPwunoAvuBBsTYPeMoDt5YHPTwwSzygxQMXPqPRxQP5s/bcWQ1DnocEaOOHPXT1+gkVBgA5AWBIxQOOt+IBOgYwa9KIoNCWlUGDtbBxnBDn1XF9ETwED6E/BI6Cbv3BA8hj+gM9+oYHjYb+sC+69QePcf3BPP4ynoAz9kTal4e2/sCsHXjo0R+EAf3Bt5D69QdmmfUS/UHo0R+EEf3Bk48+/UFZYIhcgf0e0h+EXv2BGNEf/K6FTv2BWaqHWu4cud4Ueq67hZHrbj8Wold/YFabB2WeiAcLDegP+9TDkP4wDekPnodB/QENHvr1B2FIf5i69QcHhnr1B/0tr0/W+sOJvkEbCAQCgc/Ha/SH48x/OKX+wFCNS+oP8C1eUX8oIX8+eUH9wULuA9Pr6Q8WcrNArqg/YPI8XFF/eMbD9fQHhZR8Rf1hCYX+EAgEAoETYVh/0GFuXH+AUh1u05c4hP7wiu9fYGpjnr7AcfQH8jCkP/TwcHj9AcsPeRjTH/DQ6fl2n273xaBnXkzzr4zcyha34j6a/pBQfLZCHtMfRGzp4b0QMNMgEfRb9+lYw8fTH0qI7H13/gPf+dt8p0GPee/q+kzXAa+7uVcwND7/wWB9nc0QD0aBHHQdkweGxvSHdj20eZgPpz+44+bo/Ac/PnAHKKZ4KB6Gp/lo+sO68bfnP/jjBXeQ5bE8Z4FYucxlKavLIygwFoKHAg6jb8OvI2F6CU7/RZUfHdsGD/vc/4I86Iipp3siO4M8vO/+Fz+bl9w7Qid5r+WhPF6Lh5ff/8J4YGjxZHNrR2PbANjyyp2u+uuQTiOxtFSfhapRC1u7Zgg/3nD/C9UDQ2y5YG1HPFTyBa/eG6F68gwy/P8WkUM54uFN978QD1vLxbUWmOMhb22jFRIPivvrFBEDt1+84f4XPTwAG62wtEZIPGyF//QrB3qtjof33f+iox7KwiiY4kMkV6meh7F62P/+Fxof/osH2PhHLn3o/3jgopfqeHjP/S+240XaeGA7a5XLgEYn+2VWHWK1SdmQFKz//7DWwlbOyKc+r/7N3tmlKgwDYfQi2UC3cFeSh9n/mhxntEMJKKFRJuk5WhkJQfIRxf7leDjtya0r7l9sPuzL72fpxCcHhxwccnixzPGH/0zg38S/iX8T/yb+TfybBv5NB/+mgX8TAACgF/ybf3gnyWEH/+YT/JsG/k0D7yQ5HMC/GeDfBPgCt+mu5P8Ot+nOpBvk4JCDkyeHtP7NEsUPcsjr35QofpBDXv/miRz8bGYYFOLGh2dT2yuJf7NI1QGLF4bou1L1qUV3DrH+gz7ixoe9qe2Vxr8pupVqhSO2Sfd8OK7/oB8XNz406z9EryT+zSKPAUv1IoKR2p3Dcd0DreKC/72p7ZXEvyn6KLVUKxzxl5M5+Hz4nEMS/2aTw4j5oGixxY0PbQ7a5r2S+DePOfjm76zozCHWf/Ch+Adt0dTmkMS/WWzUVbzwufBIxp7C/2r2L8iBHMiBHLIcn8S/mcB/gX8T/yb+Tfyb+Dfxb+LfxL+JfxMAABYH/2aC4w/4N/Fv4t/Ev4l/E/8m/k38m/g3AQBgcfBv4t/Ev4l/E/8m/k38m/g38W/i37wKRIB/M4l/E2Byxvkv5l6lebz/Ys4TB2/9F9fKYbD/Ys4vxxj/xRLz4bT/YpHvxXn/xcI59PsvFvh9GOO/mHs+3Nu7YxoAABAGghrwbxYPhA5N7iT80LWv/xe9HQib1qXQAQAAuFqK6eakDZMsPAAAAABJRU5ErkJggg==" alt="img"></p>
<p><strong>补充一个比较常用的东西:</strong></p>
<p>假如我们装了一个 zookeeper，我们每次开机到要求其自动启动该怎么办？</p>
<ol>
<li>新建一个脚本 zookeeper</li>
<li>为新建的脚本 zookeeper 添加可执行权限，命令是:<code>chmod +x zookeeper</code></li>
<li>把 zookeeper 这个脚本添加到开机启动项里面，命令是：<code>chkconfig --add zookeeper</code></li>
<li>如果想看看是否添加成功，命令是：<code>chkconfig --list</code></li>
</ol>
<h2 id="6-linux如何在大文件中查找指定字符"><a href="#6-linux如何在大文件中查找指定字符" class="headerlink" title="6.linux如何在大文件中查找指定字符"></a>6.linux如何在大文件中查找指定字符</h2><p>dd命令：用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换。默认从标准输入拷贝到标准输出。</p>
<p>部分相关参数：</p>
<ol>
<li><p>if&#x3D;文件名：输入文件名，缺省为标准输入。即指定源文件。</p>
</li>
<li><p>of&#x3D;文件名：输出文件名，缺省为标准输出。即指定目的文件。</p>
</li>
<li><p>ibs&#x3D;bytes：一次读入bytes个字节，即指定一个块大小为bytes个字节。</p>
<p>obs&#x3D;bytes：一次输出bytes个字节，即指定一个块大小为bytes个字节。</p>
<p>bs&#x3D;bytes：同时设置读入&#x2F;输出的块大小为bytes个字节。</p>
</li>
<li><p>skip&#x3D;blocks：从输入文件开头跳过blocks个块后再开始复制。</p>
</li>
<li><p>count&#x3D;blocks：仅拷贝blocks个块，块大小等于ibs指定的字节数。</p>
</li>
</ol>
<p>查看某个文件的大小 命令1.ls -lh file 2.du -h file</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=model_20200423155728 bs=1024 skip=3600000 count=1200 | grep &#x27;4222019284714124&#x27;</span><br></pre></td></tr></table></figure>


<p>使用二分法找到了“4222019284714124”！关于 dd+grep 的用法，总结了几点：</p>
<p>每次从文件开头先跳过 skip<em>bs 大小的内容，复制 count</em>bs 大小的内容过来用 grep 查询。</p>
<p>如果不设置 count，就会查找跳过后剩余的整个文件，如果查到，则会有输出；否则无。</p>
<p>对于特别大的文件，可以不设置skip先把 count 设为一半文件大小的值，采用二分法查找。如果找到，则限定在了前半范围，否则在后半部分。使用类似的方法继续查找……</p>
<p>如果找到，最后会输出 count*bs 大小的内容</p>
<h1 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h1><h2 id="1-IDEA"><a href="#1-IDEA" class="headerlink" title="1.IDEA"></a>1.IDEA</h2><h3 id="pom-war-jar-的区别"><a href="#pom-war-jar-的区别" class="headerlink" title="pom war jar 的区别"></a>pom war jar 的区别</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1：pom工程：用在父级工程或聚合工程中。用来做jar包的版本控制。</span><br><span class="line">2：war工程：将会打包成war，发布在服务器上的工程，如网站或服务。</span><br><span class="line">3：jar工程：将会打包成jar用作jar包使用。</span><br></pre></td></tr></table></figure>

<h3 id="项目打包"><a href="#项目打包" class="headerlink" title="项目打包"></a>项目打包</h3><p><strong>可视化操作</strong></p>
<p>1.idea工具右边有个maven，点击打开项目的lifecycle，点击install</p>
<p>说明: 如果打包问题,则检查maven的配置!</p>
<p>2.将打包好的jar文件上传到工作目录</p>
<p>3.发布 <code>java -jar XXX.jar</code></p>
<p><strong>命令行</strong></p>
<p>在idea中Terminal控制台执行maven打包命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mvn clean 会把原来target目录给删掉重新生成。</span><br><span class="line">mvn package 会打包成jar到target目录</span><br><span class="line"></span><br><span class="line">mvn clean package依次执行了clean、resources、compile、testResources、testCompile、test、jar(打包)等７个阶段。</span><br></pre></td></tr></table></figure>

<p>命令执行完毕后，在target目录下生成了jar包</p>
<h2 id="2-Maven"><a href="#2-Maven" class="headerlink" title="2.Maven"></a>2.Maven</h2><h1 id="秒杀项目"><a href="#秒杀项目" class="headerlink" title="秒杀项目"></a>秒杀项目</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><strong>订单为未付款处理逻辑</strong></p>
<p>数据库库存更新，删除Redis中的缓存。</p>
<p><strong>对于需要更新的数据，先更新数据库，再删除缓存</strong></p>
<p><strong>消息丢失问题</strong></p>
<p>给MQ队列下单时，消息丢失，可以添加“消息发送表”，生产者在发送mq消息前，先写入消息发送表，记为待处理，然后再发送。消费者消费后修改表为已处理。</p>
<p><strong>写入消息发送表，在发往mq中丢失</strong> </p>
<p>增加重试机制</p>
<p><strong>重复消费</strong></p>
<p>增加“消息处理表”，消费者在处理前先查询消息处理表，假如已存在，表示是重复消费。</p>
<p><strong>垃圾消息的问题</strong></p>
<p>消费失败，不停地重试发消息，但是无法消费。在重试时先查询消息发送表中该消息的发送次数是否达到最大限制。</p>
<p><strong>延迟消费问题</strong></p>
<p>rocketmq，自带了<strong>延迟队列</strong>的功能。</p>
<p>下单时消息生产者会先生成订单，此时状态为待支付，然后会向延迟队列中发一条消息。达到了延迟时间，消息消费者读取消息之后，会查询该订单的状态是否为待支付。如果是待支付状态，则会更新订单状态为取消状态。如果不是待支付状态，说明该订单已经支付过了，则直接返回。 </p>
<p><strong>可以优化的问题</strong></p>
<ul>
<li>消息丢失问题</li>
<li>数据的动静分离没有做的很彻底，只是用到了浏览器缓存，没有使用CDN等技术</li>
<li>没有设置降级的方案</li>
<li>限流做的不够完善，目前只对用户对于某个商品的访问做了限流，没有对整体的流量做限流，比如不法分子有非常多的账号，同时对一个商品发起请求可能造成我们的服务不可用。</li>
<li>没有考虑redis穿透的情况处理方案</li>
</ul>
<h2 id="技术点介绍"><a href="#技术点介绍" class="headerlink" title="技术点介绍"></a>技术点介绍</h2><p><img src="E:\学习笔记\图片\image-20220320141655536.png" alt="image-20220320141655536"></p>
<p>RabbitMQ：用来实现异步，解耦系统模块</p>
<p>Redis：缓存、数据库、注册中心、消息中间件，本处当做缓存使用</p>
<h2 id="秒杀流程"><a href="#秒杀流程" class="headerlink" title="秒杀流程"></a>秒杀流程</h2><p>1.登录进入商品列表页面，静态资源缓存</p>
<p>2.点击进入商品详情页面，静态资源缓存，Ajax获取验证码等动态信息</p>
<p>3.点击秒杀, 将验证码结果和商品ID传给后端，如果结果正确。动态生成随机串UUID,结合用户ID和商品ID存入redis，并将path传给前端。前端获取path后，再根据path地址调用秒杀服务</p>
<p>4.服务端获取请求的path参数，去查缓存是否在</p>
<p>5.如果存在，执行秒杀逻辑</p>
<p>6.查看Redis还有库存，预减redis库存，看是否已经生成订单，没有的话就将请求放入消息队列</p>
<p>7.后台从消息队列中取消息：获取商品ID和用户ID，判断数据库库存</p>
<p>8.如果有库存，减库存，生成订单。（可以通过延迟队列，处理付款）</p>
<p>9.前端轮询订单生成结果。</p>
<h2 id="分布式session（通过redis解决）"><a href="#分布式session（通过redis解决）" class="headerlink" title="分布式session（通过redis解决）"></a>分布式session（通过redis解决）</h2><p>之前的代码在我们之后一台应用系统，所有操作都在一台Tomcat上，没有什么问题。当我们部署多台系统，配合Nginx的时候会出现用户登录的问题 </p>
<p><strong>原因</strong> </p>
<p>由于 Nginx 使用默认负载均衡策略（轮询），请求将会按照时间顺序逐一分发到后端应用上。 也就是说刚开始我们在 Tomcat1 登录之后，用户信息放在 Tomcat1 的 Session 里。过了一会，请求 又被 Nginx 分发到了 Tomcat2 上，这时Tomcat2 上 Session 里还没有用户信息，于是又要登录。</p>
<p><strong>分布式Session是怎么实现的</strong></p>
<ul>
<li>用户登录后生成随机字符串，并向cookie中写入此字符串。</li>
<li>在Redis中记录此字符串和用户信息的映射</li>
<li>当用户再次访问网页时，取出cookie中对应字段值，根据此字段值访问Redis得到用户相关信息</li>
</ul>
<p>也可以通过SpringSession实现分布式Session： </p>
<p>​	使用SpringSession实现分布式Session，通过Session将用户信息存储在Redis中，</p>
<p> 其他解决方案： </p>
<ul>
<li><p>Session复制 （两个tomcat同步代码）</p>
<p>优点</p>
<p>无需修改代码，只需要修改Tomcat配置</p>
<p>缺点</p>
<p> Session同步传输占用内网带宽</p>
<p>多台Tomcat同步性能指数级下降</p>
<p> Session占用内存，无法有效水平扩展</p>
</li>
<li><p>前端存储（cookie 明文）</p>
<p>优点</p>
<p>不占用服务端内存 </p>
<p>缺点</p>
<p> 存在安全风险</p>
<p> 数据大小受cookie限制</p>
<p> 占用外网带宽 </p>
</li>
<li><p>Session粘滞 </p>
<p>优点</p>
<p> 无需修改代码</p>
<p> 服务端可以水平扩展 </p>
<p>缺点</p>
<p> 增加新机器，会重新Hash，导致重新登录</p>
<p> 应用重启，需要重新登录 </p>
</li>
<li><p>后端集中存储</p>
<p>优点 </p>
<p>安全 </p>
<p>容易水平扩展 </p>
<p>缺点 </p>
<p>增加复杂度 </p>
<p>需要修改代码</p>
</li>
</ul>
<h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><ol>
<li><p>商品列表</p>
<img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20220321153710269.png" alt="image-20220321153710269" style="zoom:67%;" />
</li>
<li><p>商品详情</p>
</li>
<li><p>秒杀订单</p>
<p><img src="E:\学习笔记\图片\image-20220321154257019.png" alt="image-20220321154257019"></p>
</li>
<li><p>秒杀商品表</p>
<p>方便后期的处理，假如简单在商品表中加字段，后期处理很麻烦，难以维护，且可能原价商品和秒杀商品同时放出</p>
<p><img src="E:\学习笔记\图片\image-20220321154058830.png" alt="image-20220321154058830"></p>
</li>
<li><p>订单详情</p>
<p><img src="E:\学习笔记\图片\image-20220321153941102.png" alt="image-20220321153941102"></p>
</li>
</ol>
<h2 id="明文密码二次MD5加密"><a href="#明文密码二次MD5加密" class="headerlink" title="明文密码二次MD5加密"></a>明文密码二次MD5加密</h2><p><strong>加密的目的：第一次是因为http是明文传输的，第二次为了防止数据库被盗</strong></p>
<p>1.第一次加密是因为http采用明文传输，若传输的数据包被截取，那么密码就会被别人知道。是用户端对密码进行加密，防止传输过程中的密码泄露。<br>2.第二次加密是防止数据库被盗，因为MD5有些加密后是可以通过彩虹表进行反向查询得到原始密码，所以第二次MD5是为了保险起见，服务器对一次MD5加密后的输出进行再次加密，然后存入数据库</p>
<h2 id="系统压测"><a href="#系统压测" class="headerlink" title="系统压测"></a>系统压测</h2><ol>
<li>JMeter</li>
<li>自定义变量模拟多用户</li>
<li>JMeter命令行的使用</li>
<li>正式压测<ol>
<li>商品列表</li>
<li>秒杀</li>
</ol>
</li>
</ol>
<ul>
<li>JMeter在windows下是图形界面<ul>
<li>打开jmeter.bat运行图形界面</li>
<li>测试计划中添加线程组</li>
<li>在线程组中添加HTTP请求默认值（就是端口号）</li>
<li>在线程组中添加HTTP请求（就是要测试的类的URL）、这里可以设置带参数</li>
<li>在线程组中添加监听器进监听</li>
<li>也可以通过自定义模拟多用户（写一个文件，导入即可）</li>
</ul>
</li>
<li>JMeter在Linux下是命令行进行操<ul>
<li>在Windows上录好jmx</li>
<li>命令行：sh jmeter.sh -n -t XXX.jmx -l result.jtl</li>
<li>把result.jtl导入到jmeter</li>
</ul>
</li>
</ul>
<p><strong>结果</strong>：五千并发的情况下，QPS为一千三左右</p>
<h2 id="页面优化"><a href="#页面优化" class="headerlink" title="页面优化"></a>页面优化</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>页面静态化和缓存</strong><br>网页静态化技术和缓存技术的本意都是为了减轻数据库的访问压力，实现网站优化，提高网站的访问效率。</p>
<p><strong>定义不同:</strong><br>静态化是将数据库静态化到页面，客户端访问不需要查询数据库，主要存放形式是静态化文件资源，存储于硬盘，用户请求的是指定目录下的静态页面，页面中有数据。<br>缓存是将数据存储于服务器内存，二者存放位置和形式不一样。</p>
<p><strong>作用不同：</strong><br>网页静态化还有利于搜索引擎，明显地提高网站的访问效率，安全的角度来说，静态页面更不容易被SQL注入攻击。因此，为了提高访问效率，同时利于SEO，增强安全性<br>缓存是指在服务器缓存的，用户访问时能加快访问速度的。</p>
<p><strong>利用原理不同：</strong><br>页面静态化利用的静态页面交互比动态交互快原理；<br>缓存技术利用内存交互比数据库交互快的原理.</p>
<p><strong>适用场景不同：</strong><br>网页静态化比较适合大规模且相对变化不太频繁的数据。秒杀的时候，都要把商品页面进行静态化，放到CDN上面，这样能在前端就能抗住大量的并发请求；内容页面一般不怎么变化，完全可以静态化。<br>缓存比较适合小规模的数据。首页、分类页的数据，容易变化，我们就可以使用缓存来实现，设置过期时间，同样不用对数据库进行查询，只要访问内存就行。</p>
<h3 id="页面缓存-URL缓存-对象缓存"><a href="#页面缓存-URL缓存-对象缓存" class="headerlink" title="页面缓存+URL缓存+对象缓存"></a>页面缓存+URL缓存+对象缓存</h3><p>页面缓存通过将页面放入Redis缓存中，减少页面渲染速度，URL缓存是将一些URL字段动态变化的页面放入Redis，对象缓存是在整个过程中，可能需要判断User字段，但是此处将对象放入缓存中。</p>
<p><strong>页面缓存步骤（这里指的是商品列表）：</strong><br>1.从redisService中取缓存<br>2.若缓存中没有则手动渲染，利用thymeleaf模板<br>3.然后将页面加入缓存，并返回渲染页面</p>
<p>1.假如有一个这样的代码(他的功能是展现商品的列表,这里讲的框架是SpringBoot,前端用的thymleaf模板)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/goods/to_list&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">list</span><span class="params">(Model model, MiaoshaUser user )</span> &#123;</span><br><span class="line">	model.addAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">	<span class="comment">// 查询商品列表</span></span><br><span class="line">	List&lt;GoodsVo&gt; goodsList = goodsService.listGoodsVo();</span><br><span class="line">	model.addAttribute(<span class="string">&quot;goodsList&quot;</span>, goodsList);</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;goods_list&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们从上面的代码得知：该代码是查询出商品列表然后转到goods_list.html的前端页面上(配置文件省略),我们可以得知.将goodsList参数通过model传给goods_list页面,这其中是通过SpringBoot框架来进行渲染的.其中牵扯很多代码的运行,比较耗时间;而且每执行这个代码一次,SpringBoot就要渲染一次,非常的麻烦;</p>
<p>2.接下来我们就按照上面的例子作为例子来讲解页面的缓存(使用页面缓存的代码如下:)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/goods/to_list&quot;, produces = &quot;text/html&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">list</span><span class="params">(Model model, MiaoshaUser user, HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">	model.addAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">	<span class="comment">// 查询商品列表</span></span><br><span class="line">	List&lt;GoodsVo&gt; goodsList = goodsService.listGoodsVo();</span><br><span class="line">	model.addAttribute(<span class="string">&quot;goodsList&quot;</span>, goodsList);</span><br><span class="line">	<span class="comment">// 使用页面缓存 1.查询redis对应的缓存 2.不存在则写入redis缓存中</span></span><br><span class="line">	<span class="comment">// 1.查询redis</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">html</span> <span class="operator">=</span> redisService.get(GoodsKey.getGoodsList, <span class="string">&quot;&quot;</span>, String.class);</span><br><span class="line">	<span class="keyword">if</span> (!StringUtils.isEmpty(html)) &#123;</span><br><span class="line">		<span class="keyword">return</span> html;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 假如redis查询不到数据,则:渲染html(通过SpringBoot的themleafViewResovler接口的实现类SpringWebContext来操作)</span></span><br><span class="line">	<span class="type">SpringWebContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringWebContext</span>(request, response, request.getServletContext(), request.getLocale(),</span><br><span class="line">			model.asMap(), applicationContext);</span><br><span class="line">	<span class="comment">// 手动进行渲染:thymeleafViewResolver</span></span><br><span class="line">	html = thymeleafViewResolver.getTemplateEngine().process(<span class="string">&quot;goods_list&quot;</span>, ctx);</span><br><span class="line">	<span class="comment">// 2.将手动渲染完毕的html存放到redis中</span></span><br><span class="line">	<span class="keyword">if</span> (!StringUtils.isEmpty(html)) &#123;</span><br><span class="line">		redisService.set(GoodsKey.getGoodsList, <span class="string">&quot;&quot;</span>, html);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们从上面的代码得知:页面缓存是首先从redis中取出渲染好的页面,如果不存在,那么则自己手动渲染页面一次，再把通过thymeleafViewResolver渲染好的页面存入到缓存中去!</p>
<p><strong>URL缓存（指的是商品详情页）未实现</strong><br>与页面缓存步骤基本一致，但是需要取缓存和加缓存时要加入参数，GoodsId<br><strong>对象缓存（指的是User对象）未实现</strong><br>前面的页面缓存和URL缓存适合变化不大的，缓存时间比较短<br>对象缓存是<strong>长期缓存</strong>，所以需要有个<strong>更新</strong>的步骤<br>第一步是取缓存<br>若缓存中没有则去数据库中查找，并加入缓存；如数据库中没有就报错<br>更新用户的密码</p>
<h3 id="页面静态化，前后端分离（Thymeleaf实现）"><a href="#页面静态化，前后端分离（Thymeleaf实现）" class="headerlink" title="页面静态化，前后端分离（Thymeleaf实现）"></a>页面静态化，前后端分离（Thymeleaf实现）</h3><p>Thymeleaf 是新一代 Java 模板引擎，与 Velocity、FreeMarker 等传统 Java 模板引擎不同，Thymeleaf 支持 HTML 原型，其文件后缀为“.html”，因此它可以直接被浏览器打开，此时浏览器会忽略未定义的 Thymeleaf 标签属性，展示 thymeleaf 模板的静态页面效果；当通过 Web 应用程序访问时，Thymeleaf 会动态地替换掉静态内容，使页面动态显示。</p>
<p>Thymeleaf 通过在 html 标签中，增加额外属性来达到“模板+数据”的展示方式，示例代码如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--th:text 为 Thymeleaf 属性，用于在展示文本--&gt;&lt;h1 th:text=&quot;迎您来到Thymeleaf&quot;&gt;欢迎您访问静态页面 HTML&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>当直接使用浏览器打开时，浏览器展示结果如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">欢迎您访问静态页面HTML</span><br></pre></td></tr></table></figure>

<p>当通过 Web 应用程序访问时，浏览器展示结果如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">迎您来到Thymeleaf</span><br></pre></td></tr></table></figure>

<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>活动页面绝大多数内容是固定的，比如：商品名称、商品描述、图片等。为了减少不必要的服务端请求，通常情况下，会对固定页面做静态化处理。用户浏览商品等常规操作，并不会请求到服务端。</p>
<ul>
<li>将动态渲染生成的页面结果保存成html文件，放到静态文件服务器中。</li>
<li>用户直接去静态服务器，访问处理好的静态html文件。</li>
</ul>
<p>Thymeleaf除了可以把渲染结果写入Response，也可以写到本地文件实现静态化，先来看看Thymeleaf中的几个概念：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Context：运行上下文</span><br><span class="line">TemplateResolver：模板解析器</span><br><span class="line">TemplateEngine：模板引擎</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Context</p>
</blockquote>
<p>上下文：用来保存模型数据，当模板引擎渲染时，可以从Context上下文获取数据用于渲染，当与SpringBoot结合使用时，我们放入Model的数据会被处理到Context，作为模板渲染的数据使用。</p>
<blockquote>
<p>TemplateResolver</p>
</blockquote>
<p>模板解析器：用来读取模板相关的配置，如：模板存放的位置信息、模板文件名称、模板文件的类型等。与SpringBoot结合使用时，TemplateResolver已由其创建完成，并且各种配置也都有默认值，比如模板存放位置，默认就是：templates，模板文件类型默认就是html</p>
<blockquote>
<p>TemplateEngine</p>
</blockquote>
<p>模板引擎：用来解析模板的引擎，需要使用到上下文、模板解析器。分别从两者中获取模板中需要的数据，模板文件。然后利用内置的语法规则解析，从而输出解析后的文件。来看下模板引起进行处理的函数</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">templateEngine.process(&quot;模板名&quot;, context, writer);</span><br></pre></td></tr></table></figure>

<p>三个参数：</p>
<ul>
<li>模板名称</li>
<li>上下文：包含了模型数据</li>
<li>writer：输出目的地的流.在输出时，我们可以指定输出的目的地，如果目的地是Response的流，那就是网络响应。如果目的地是本地文件，那就实现静态化了。</li>
</ul>
<p>使用Thymeleaf生成静态页面<br>生成静态页面 &#x3D; 静态模板(item.html) + 动态数据</p>
<p>1）创建Context上下文对象（读取模板文件需要的动态数据）<br>2）定义静态模板（(item.html）<br>3）使用模板引擎对象读取静态目标，把动态数据写入模板，使用IO输出流生成一个静态文件</p>
<p>静态页面服务器一般选择使用nginx。</p>
<p>在配置文件中配置静态化页面的信息<br>1.在application.yml中配置生成静态文件的目录：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ly:</span></span><br><span class="line">  <span class="attr">static:</span></span><br><span class="line">    <span class="attr">itemDir:</span> <span class="string">D:\resource\ly-source\nginx-1.16.0\html\item</span> <span class="comment">#静态页服务器地址</span></span><br><span class="line">    <span class="attr">itemTemplate:</span> <span class="string">item</span> <span class="comment">#模板名称</span></span><br></pre></td></tr></table></figure>

<p>2.编写生成静态化页面的service方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成商品的静态页面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createStaticPage</span><span class="params">(Long spuId)</span>&#123;</span><br><span class="line">        <span class="comment">//1）创建Context上下文对象（读取模板文件需要的动态数据）</span></span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>();</span><br><span class="line">        <span class="comment">//设置动态数据</span></span><br><span class="line">        context.setVariables(getDetailData(spuId));    </span><br><span class="line">		<span class="comment">//2）定义静态模板（(item.html）</span></span><br><span class="line">    	<span class="type">String</span> <span class="variable">tmepName</span> <span class="operator">=</span> itemTemplate+<span class="string">&quot;.html&quot;</span>;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//3）使用模板引擎对象读取静态目标，把动态数据写入模板，使用IO输出流生成一个静态文件</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//生成 静态页名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> spuId+<span class="string">&quot;.html&quot;</span>;</span><br><span class="line">    <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        writer = <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">File</span>(itemDir,fileName));</span><br><span class="line">        templateEngine.process(tmepName,context,writer);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//注意：一旦涉及自定义输出流，必须关闭输出流，否则后续无法删除该文件</span></span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CDN优化-未实现"><a href="#CDN优化-未实现" class="headerlink" title="CDN优化 未实现"></a>CDN优化 未实现</h3><ul>
<li>CDN是内容分发网络，相当于缓存，只是部署在全国各地，当用户发起请求时，会找最近的CDN获取资源</li>
</ul>
<h2 id="接口优化"><a href="#接口优化" class="headerlink" title="接口优化"></a>接口优化</h2><p>思路</p>
<ul>
<li>内存标记减少Redis访问</li>
<li>Redis预减库存减少数据库访问</li>
<li>RabbitMQ队列缓冲，异步下单，增强用户体验</li>
</ul>
<h3 id="秒杀库存的处理"><a href="#秒杀库存的处理" class="headerlink" title="秒杀库存的处理"></a>秒杀库存的处理</h3><h4 id="1-加载库存"><a href="#1-加载库存" class="headerlink" title="1.加载库存"></a>1.加载库存</h4><p>系统初始化后就将所有商品库存放入缓存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 秒杀接口优化之---   第一步:  系统初始化后就将所有商品库存放入 缓存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    List&lt;GoodsVo&gt; goods = goodsService.getGoodsList();</span><br><span class="line">    <span class="keyword">if</span> (goods == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (GoodsVo goodsVo : goods) &#123;</span><br><span class="line">        redisService.set(GoodsKey.getId(), goodsVo.getStockCount());</span><br><span class="line">        isOverMap.put(goodsVo.getId(), <span class="literal">false</span>);<span class="comment">//先初始化 每个商品都是false 就是还有</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="2-Redis预减库存减少数据库的访问"><a href="#2-Redis预减库存减少数据库的访问" class="headerlink" title="2.Redis预减库存减少数据库的访问"></a>2.Redis预减库存减少数据库的访问</h4><p>为了减少对数据库得访问，尽量访问Redis，就在系统初始化时预先把库存加载到Redis。假如库存不够，直接返回，库存够的话，把请求放入RabbitMQ队列，向客户端返回正在排队中，然后异步访问数据库。客户端轮询查看订单状态。（后续为了更多的提升，可以分库分表）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**秒杀接口优化之 ----第二步： 预减库存 从缓存中减库存</span></span><br><span class="line"><span class="comment"> * 利用 redis 中的方法，减去库存，返回值为 减去1 之后的值</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">long</span> <span class="variable">stock</span> <span class="operator">=</span> redisService.decr(GoodsKey.getGoodsStock, <span class="string">&quot;&quot;</span> + goodsId);</span><br><span class="line"><span class="comment">/*这里判断不能小于等于，因为减去之后等于 说明还有是正常范围*/</span></span><br><span class="line"><span class="keyword">if</span> (stock &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    isOverMap.put(goodsId, <span class="literal">true</span>);<span class="comment">//没有库存就设置 对应id 商品的map 为true</span></span><br><span class="line">    <span class="keyword">return</span> Result.error(CodeMsg.MIAO_SHA_NO_STOCK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>整体的逻辑如下：</p>
<p>1.先将所有数据读出来，初始化到缓存中，并以 stock + goodid 的形成存入Redis。<br>2.在秒杀的时候，先进行预减库存检测，从redis中，利用decr 减去对应商品的库存，如果库存小于0，说明此时 库存不足，则不需要访问数据库。直接抛出异常即可。<br>我们上面还使用到了isOverMap，这个是内存标记。</p>
<h4 id="3-内存标记减少Redis的访问"><a href="#3-内存标记减少Redis的访问" class="headerlink" title="3.内存标记减少Redis的访问"></a>3.内存标记减少Redis的访问</h4><p>定义一个hashmap标记是否还有库存，假如没有库存，就不再需要访问Redis，减少Redis访问次数</p>
<p>由于接口优化很多基于Redis的缓存操作，当并发很高的时候，也会给Redis服务器带来很大的负担，如果可以减少对Redis服务器的访问，也可以达到的优化的效果。</p>
<p>于是，可以加一个内存map,标记对应商品的库存量是否还有，在访问Redis之前，在map中拿到对应商品的库存量标记，就可以不需要访问Redis 就可以判断没有库存了。</p>
<p>1.生成一个map，并在初始化的时候，将所有商品的id为键，标记false 存入map中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;Long, Boolean&gt; isOverMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Long, Boolean&gt;();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 秒杀接口优化之---   第一步:  系统初始化后就将所有商品库存放入 缓存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    List&lt;GoodsVo&gt; goods = goodsService.getGoodsList();</span><br><span class="line">    <span class="keyword">if</span> (goods == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (GoodsVo goodsVo : goods) &#123;</span><br><span class="line">        redisService.set(GoodsKey.getGoodsStock, <span class="string">&quot;&quot;</span> + goodsVo.getId(), goodsVo.getStockCount());</span><br><span class="line">        isOverMap.put(goodsVo.getId(), <span class="literal">false</span>);<span class="comment">//先初始化 每个商品都是false 就是还有</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**再优化： 优化 库存之后的请求不访问redis 通过判断 对应 map 的值</span></span><br><span class="line"><span class="comment">  * */</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isOver</span> <span class="operator">=</span> isOverMap.get(goodsId);</span><br><span class="line"><span class="keyword">if</span> (isOver) &#123;</span><br><span class="line">     <span class="keyword">return</span> Result.error(CodeMsg.MIAO_SHA_NO_STOCK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (stock &lt; <span class="number">0</span>) &#123;</span><br><span class="line">     isOverMap.put(goodsId, <span class="literal">true</span>);<span class="comment">//没有库存就设置 对应id 商品的map 为true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>2.在预减库存之前，从map中取标记，若标记为false,说明库存不足</p>
<p>3.预减库存，当遇到库存不足的时候，将该商品的标记置为true,表示该商品的库存不足。这样，下面的所有请求，将被拦截，无需访问redis进行预减库存。</p>
<h4 id="4-RabbitMQ异步下单"><a href="#4-RabbitMQ异步下单" class="headerlink" title="4.RabbitMQ异步下单"></a>4.RabbitMQ异步下单</h4><ol>
<li><p>SpringBoot整合RabbitMQ</p>
</li>
<li><p>交换机 使用的topic</p>
<p>Rabbit中发布消息不直接和消息队列联系，而是通过交换机和队列联系</p>
</li>
</ol>
<p>整体逻辑如下</p>
<p>将商品的库存数据加载至内存，同时初始化内存标记，即把每个产品的id存放至map，都是初始化为false，在每次需要执行秒杀逻辑之前，先在内存标记中取值，如果仍有库存，即map里返回的为false,则执行秒杀逻辑，否则直接抛出异常。</p>
<p>然后进行减库存，先访问Redis，将请求放入队列，最后访问数据库。</p>
<p>在扣减库存时，需要判断缓存中的库存数量是否仍然大于0，如果小于等于0，修改内存标记。</p>
<h3 id="2-Redis实现分布式锁（之前是基于redis自带的递减函数进行原子性操作）保证数据库的一致性。"><a href="#2-Redis实现分布式锁（之前是基于redis自带的递减函数进行原子性操作）保证数据库的一致性。" class="headerlink" title="2.Redis实现分布式锁（之前是基于redis自带的递减函数进行原子性操作）保证数据库的一致性。"></a>2.Redis实现分布式锁（之前是基于redis自带的递减函数进行原子性操作）保证数据库的一致性。</h3><p>给数据库的减库存操作进行加锁。为了防止多实例修改数据库，造成数据不一致问题。</p>
<p>在减库存时，通过<strong>Redis的占位锁</strong> ，一般是 <strong>setnx 和 del</strong>函数，实现互斥访问，通过占位锁实现分布式锁，假如线程执行过程中出现问题，则占位锁没删除，会造成其他线程无法进行，因此<strong>设置超时时间</strong>。但是假如出现延迟，还未执行完锁就被超时删除，引入看门狗机制，保证线程在执行过程中，锁不会过期（设置一个监听线程，锁的过期时间每减少三门之一，假如还未执行完，就把过期时间加满）。同时，为了防止锁删除操作可能删除的是其他线程的锁，会造成混乱；因此通过在设置锁时，<strong>给value设置一个随机值</strong>，每当执行完任务进行锁的删除时，<strong>先检查是否是自己的锁</strong>，不是就无法删除，同时可以<strong>删除锁需要几个步骤</strong>：1.获取锁 2. 判断是否是自己的 3.删除，操作不是原子性的，因此通过lua脚本实现原子性，redis内置支持lua脚本（两种实现方式：1.在redis端写好，在java端调用2.在Java端写好，发送到redis执行）</p>
<h2 id="安全优化"><a href="#安全优化" class="headerlink" title="安全优化"></a>安全优化</h2><h3 id="秒杀接口地址隐藏"><a href="#秒杀接口地址隐藏" class="headerlink" title="秒杀接口地址隐藏"></a>秒杀接口地址隐藏</h3><p>秒杀接口地址隐藏</p>
<p>虽然前端页面在秒杀未开始时秒杀按钮设置为不可用，但是有可能用户通过前端js代码找到秒杀地址，在秒杀未开始时直接访问，秒杀接口隐藏的目的是用户通过js获取到的秒杀地址并不能让其完成秒杀功能</p>
<p><strong>逻辑：</strong></p>
<p>1.点击秒杀按钮，第一次发起请求</p>
<ol>
<li>判断用户是否登陆</li>
<li>判断验证码是否正确</li>
<li>根据用户id和商品id生成一个随机地址path，放入Redis，并作为响应返回给前端</li>
</ol>
<p>2.前端收到path后，放入URL中，再次发起请求</p>
<ol>
<li>判断path和Redis中的path是否一致</li>
<li>内存标记</li>
<li>预减库存</li>
<li>生成订单</li>
</ol>
<p>在秒杀之前要先根据童虎id和商品id生成一个path，存入Redis，在执行秒杀的时候根据用户和商品ID，再从Redis中取Path进行验证</p>
<h3 id="算术验证码"><a href="#算术验证码" class="headerlink" title="算术验证码"></a>算术验证码</h3><ul>
<li>作用：接口防刷；错开请求</li>
<li>在获取Path时进行验证</li>
</ul>
<h3 id="接口防刷"><a href="#接口防刷" class="headerlink" title="接口防刷"></a>接口防刷</h3><ul>
<li>当一个用户访问接口时，把访问次数写入缓存，并设置有效期</li>
<li>一分钟之内如果用户访问，则缓存中的访问次数加一，如果次数超限进行限流操作</li>
<li>如果一分钟内没有超限，缓存中数据消失，下次再访问时重新写入缓存</li>
</ul>
<h1 id="广告系统"><a href="#广告系统" class="headerlink" title="广告系统"></a>广告系统</h1><h2 id="微服务的架构"><a href="#微服务的架构" class="headerlink" title="微服务的架构"></a>微服务的架构</h2><p><img src="E:\学习笔记\图片\image-20220324154421961.png" alt="image-20220324154421961"></p>
<p><img src="E:\学习笔记\图片\image-20220324154653925.png" alt="image-20220324154653925"></p>
<p>SpringCloud是基于网关的方式实现的，实现微服务网关的组件是zuul，zuul的生命周期如下：</p>
<p><img src="E:\学习笔记\图片\image-20220324154950274.png" alt="image-20220324154950274"></p>
<p>大部分功能通过过滤器来实现</p>
<ul>
<li><strong>pre：在请求被路由之前调用</strong></li>
<li><strong>route：在路由请求时被调用</strong></li>
<li><strong>post：在 route 和 error 过滤器之后被调用</strong></li>
<li><strong>error：处理请求时发生错误时被调用</strong></li>
</ul>
<h2 id="还包括哪些系统"><a href="#还包括哪些系统" class="headerlink" title="还包括哪些系统"></a>还包括哪些系统</h2><p>包括曝光检测系统、报表系统、扣费系统</p>
<p><img src="E:\学习笔记\图片\image-20220324153608407.png" alt="image-20220324153608407"></p>
<h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20220324153251027.png" alt="image-20220324153251027" style="zoom:200%;" />

<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p><img src="E:\学习笔记\图片\c5ab9976ly1fyuklt5lnuj21ec0oktkb.jpg" alt="img"></p>
<h2 id="用到的微服务组件"><a href="#用到的微服务组件" class="headerlink" title="用到的微服务组件"></a>用到的微服务组件</h2><h3 id="1-Eureka"><a href="#1-Eureka" class="headerlink" title="1.Eureka"></a>1.Eureka</h3><p>功能：服务注册与发现</p>
<p>由三个角色组成：</p>
<p>Eureka Server：提供服务注册与发现</p>
<p>Service Provider：服务提供方，将自身注册到Eureka Server上，从而让Eureka持有服务的元信息（从Eureka配置文件中，大致可以得出，元信息包括，服务端口，服务名称，服务ip或域名，服务间调用的url等，以 ConcurrentHashMap 存储），让其他的服务消费方能够找到当前服务</p>
<p>Service Consumer：服务消费方，从Server上获取注册的服务列表，从而能够消费服务。</p>
<p><img src="E:\学习笔记\图片\c5ab9976ly1fyto185hnwj213g0fw764.jpg" alt="img"></p>
<h3 id="2-网关Zuul"><a href="#2-网关Zuul" class="headerlink" title="2.网关Zuul"></a>2.网关Zuul</h3><p>外部应用都要通过网关去访问各个微服务，非业务模块之间调用，通过网关。微服务架构中，后端服务不直接开放给调用端，而是通过服务网关根据请求的url，路由到相应的服务。</p>
<h2 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h2><p><strong>用户表</strong>     用户名、给用户生成的token、用户状态、创建时间、更新时间</p>
<p><strong>推广计划表</strong>  所属的用户、名称、状态、开始时间、结束时间、创建时间、更新时间</p>
<p><strong>推广单元表</strong>  关联推广计划id、推广单元名称、推广单元状态、广告位类型、预算、创建时间、更新时间</p>
<p><strong>创意表</strong>  创意名称、物料类型、物料子类型、高度、宽度、大小（KB）、持续时长、审核状态、所属用户、物料地址、创建时间、更新时间</p>
<p><strong>创意与推广单元的关联表</strong> 创意id、推广单元id</p>
<p><strong>推广单元关键词</strong> 单元id、关键词（例如培训、洗护）</p>
<p><strong>推广单元兴趣</strong> 单元id、兴趣标签</p>
<p><strong>推广单元地域</strong> 单元id、省、市</p>
<h2 id="统一响应接口"><a href="#统一响应接口" class="headerlink" title="统一响应接口"></a>统一响应接口</h2><p>统一响应的代码说明</p>
<h2 id="RestControllerAdvice-注解"><a href="#RestControllerAdvice-注解" class="headerlink" title="@RestControllerAdvice 注解"></a>@RestControllerAdvice 注解</h2><p><strong>Advice 在 Spring 中的含义就是对 XX 功能增强，RestControllerAdvice（ControllerAdvice）就是对控制器增强。之所以使用 RestControllerAdvice，是因为我们对外提供的都是 Rest 接口（json）。</strong></p>
<p><strong>我们需要对 Controller 返回的内容做一些额外的工作，即功能增强，就需要利用到这个注解。另外，这个注解提供了 basePackages 属性可以指定对特定 package 中的 Controller 生效。</strong></p>
<h2 id="ResponseBodyAdvice-接口"><a href="#ResponseBodyAdvice-接口" class="headerlink" title="ResponseBodyAdvice 接口"></a>ResponseBodyAdvice 接口</h2><p><strong>ResponseBodyAdvice 的作用是在响应体返回之前做一些自定义的处理工作。通常，我们会实现 ResponseBodyAdvice 接口，并包装统一的响应返回。接口的详细定义可以阅读 Spring 官网的解释: <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/servlet/mvc/method/annotation/ResponseBodyAdvice.html">Spring ResponseBodyAdvice</a></strong></p>
<ul>
<li><strong>supports 方法</strong></li>
</ul>
<p><strong>supports 的返回值是 boolean 类型，用于指定哪些 Controller 方法需要处理。我们当前的代码实现是标注了 IgnoreResponseAdvice 注解的类或者方法，统一响应不会生效。代码解释如下：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;h2&gt;判断是否需要对响应进行处理&lt;/h2&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> false: 不需要处理; true: 需要处理</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(MethodParameter methodParameter,</span></span><br><span class="line"><span class="params">                        Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前方法所在的类标识了 IgnoreResponseAdvice 注解, 则不需要处理</span></span><br><span class="line">    <span class="keyword">if</span> (methodParameter.getDeclaringClass().isAnnotationPresent(</span><br><span class="line">            IgnoreResponseAdvice.class</span><br><span class="line">    )) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前方法标识了 IgnoreResponseAdvice 注解, 则不需要处理</span></span><br><span class="line">    <span class="keyword">if</span> (methodParameter.getMethod().isAnnotationPresent(</span><br><span class="line">            IgnoreResponseAdvice.class</span><br><span class="line">    )) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对响应进行处理, 执行 beforeBodyWrite 方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>beforeBodyWrite 方法</strong></li>
</ul>
<p><strong>根据方法的名字可以知道，这个方法实现了在结果输出前的操作。这个方法的参数很多，我们只需要关注第一个：Object，这个就是原始的 Controller 返回的内容。我们也就是需要对它进行包装。代码解释如下：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;h2&gt;响应返回之前的处理&lt;/h2&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 响应对象</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">beforeBodyWrite</span><span class="params">(<span class="meta">@Nullable</span> Object o,</span></span><br><span class="line"><span class="params">                              MethodParameter methodParameter,</span></span><br><span class="line"><span class="params">                              MediaType mediaType,</span></span><br><span class="line"><span class="params">                              Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass,</span></span><br><span class="line"><span class="params">                              ServerHttpRequest serverHttpRequest,</span></span><br><span class="line"><span class="params">                              ServerHttpResponse serverHttpResponse)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义最终的返回对象</span></span><br><span class="line">    CommonResponse&lt;Object&gt; response = <span class="keyword">new</span> <span class="title class_">CommonResponse</span>&lt;&gt;(<span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 o 是 null, response 不需要设置 data</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == o) &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    <span class="comment">// 如果 o 已经是 CommonResponse 类型, 强转即可</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o <span class="keyword">instanceof</span> CommonResponse) &#123;</span><br><span class="line">        response = (CommonResponse&lt;Object&gt;) o;</span><br><span class="line">    <span class="comment">// 否则, 把响应对象作为 CommonResponse 的 data 部分</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        response.setData(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果我们对 Controller 返回的结果的处理过程比较复杂，那么根据处理的分类，可以指定多个 ResponseBodyAdvice，并使用 @Order 指定处理顺序。</strong></p>
<h2 id="统一异常处理接口"><a href="#统一异常处理接口" class="headerlink" title="统一异常处理接口"></a>统一异常处理接口</h2><p>统一异常处理的解释说明</p>
<h2 id="ExceptionHandler"><a href="#ExceptionHandler" class="headerlink" title="@ExceptionHandler"></a>@ExceptionHandler</h2><p><strong>拦截 Spring 的异常处理需要使用到 ExceptionHandler 注解。Spring 3.0 引入的这个注解可以让我们在一个 handler 方法或者类中统一处理 Controller 抛出的异常，使得写出的代码更加清晰。</strong></p>
<p><strong>首先，来看看对这个注解的解释：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span>             <span class="comment">// 这个注解标注在对象的方法上</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span>     <span class="comment">// 在运行时有效</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ExceptionHandler &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Exceptions handled by the annotated method. If empty, will default to any</span></span><br><span class="line"><span class="comment">	 * exceptions listed in the method argument list.</span></span><br><span class="line"><span class="comment">   * value 是一个 Class 数组，用于指定需要拦截的异常类。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	Class&lt;? <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt;[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：该注解注释的方法可以有灵活的输入参数，通常需要给出异常参数：包括一般的异常或特定的异常（即自定义异常），如果注解自身没有指定异常类，会默认进行映射。</strong></p>
<p><strong>课程中代码实现的解释如下：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;h1&gt;全局异常处理&lt;/h1&gt;</span></span><br><span class="line"><span class="comment"> * RestControllerAdvice: 组合注解, ControllerAdvice + ResponseBody, 是对 RestController 的功能增强</span></span><br><span class="line"><span class="comment"> * Created by Qinyi.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *代码中抛出异常后，就会被GlobalExceptionAdvice捕获，通过handlerAdException方法进行处理</span></span><br><span class="line"><span class="comment">     * &lt;h2&gt;对 AdException 进行统一处理&lt;/h2&gt;</span></span><br><span class="line"><span class="comment">     * ExceptionHandler: 可以对指定的异常进行拦截</span></span><br><span class="line"><span class="comment">     * 优化: 定义多种类异常, 并实现对应的异常处理. 例如: 推广单元的操作出现异常, 抛出 AdUnitException;</span></span><br><span class="line"><span class="comment">     *  Binlog 解析异常, 抛出 BinlogException</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = AdException.class)</span><span class="comment">//标记处理AdException.class中定义的异常</span></span><br><span class="line">    <span class="keyword">public</span> CommonResponse&lt;String&gt; <span class="title function_">handlerAdException</span><span class="params">(HttpServletRequest req,</span></span><br><span class="line"><span class="params">                                                     AdException ex)</span> &#123;<span class="comment">//HttpServletRequest是请求，可以知道哪个请求抛出了异常。</span></span><br><span class="line">        <span class="comment">// 统一异常接口的响应</span></span><br><span class="line">        <span class="comment">// 优化: 定义不同类型的异常枚举(异常码和异常信息)</span></span><br><span class="line">        CommonResponse&lt;String&gt; response = <span class="keyword">new</span> <span class="title class_">CommonResponse</span>&lt;&gt;(-<span class="number">1</span>,</span><br><span class="line">                <span class="string">&quot;business error&quot;</span>);</span><br><span class="line">        response.setData(ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="统一配置类"><a href="#统一配置类" class="headerlink" title="统一配置类"></a>统一配置类</h2><p>WebMvcConfigurer 接口</p>
<p><strong>Spring 的 WebMvcConfigurer 接口提供了很多方法让我们来定制 Spring MVC 的配置。这个接口还是非常常用的，可以对 Spring 的很多配置和行为进行定制。下面对一些常用的方法进行解释：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 匹配路由请求规则</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">configurePathMatch</span><span class="params">(PathMatchConfigurer configurer)</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 注册自定义的 Formatter 和 Convert</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">addFormatters</span><span class="params">(FormatterRegistry registry)</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 添加静态资源处理器</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 配置消息转换器</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">configureMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 添加自定义视图控制器</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 添加自定义方法参数处理器</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">addArgumentResolvers</span><span class="params">(List&lt;HandlerMethodArgumentResolver&gt; resolvers)</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="微服务之间的调用"><a href="#微服务之间的调用" class="headerlink" title="微服务之间的调用"></a>微服务之间的调用</h2><p><em><strong>注册到 Eureka Server 的各个微服务之间可以通过 SpringCloud 自带的组件实现服务之间的调用</strong></em></p>
<h3 id="Ribbon-方式调用"><a href="#Ribbon-方式调用" class="headerlink" title="Ribbon 方式调用"></a>Ribbon 方式调用</h3><p><em><strong>Ribbon 是一个客户端负载均衡器，可以很好的控制 HTTP 和 TCP 客户端的行为</strong></em></p>
<ul>
<li><strong>SearchApplication.java 中完成注入，并标记 @LoadBalanced 开启负载均衡的功能</strong></li>
<li><strong>SearchController.java 中通过 RestTemplate 调用服务接口，与常见的 RestTemplate 不同的是，调用使用的不再是 ip + port，而是服务名。这是通过注册中心（Eureka Server）实现的。</strong></li>
</ul>
<h3 id="Feign-方式调用"><a href="#Feign-方式调用" class="headerlink" title="Feign 方式调用"></a>Feign 方式调用</h3><p><em><strong>Feign 可以实现声明式的 Web 服务客户端</strong></em></p>
<ul>
<li><p><strong>定义接口interface SponsorClient</strong></p>
</li>
<li><p><strong>通过 @FeignClient 指定调用的微服务名称</strong>  </p>
</li>
<li><p><strong>在接口类中的方法上声明 @RequestMapping 指明调用服务的地址（方法）与请求类型</strong></p>
</li>
<li><p><strong>通过在 @FeignClient 中配置 fallback 指定熔断</strong></p>
</li>
<li><p><strong>定义类实现接口：SponsorClient.java，重写方法，熔断：SponsorClientHystrix.java</strong>，当微服务停止服务，调用这个服务时，会执行fallback指定的类，执行实现类中对应的重写方法（服务降级）</p>
</li>
</ul>
<p>接口类</p>
<p><img src="E:\学习笔记\图片\image-20220409214059790.png" alt="image-20220409214059790"></p>
<p>实现类</p>
<p><img src="E:\学习笔记\图片\image-20220409214038240.png" alt="image-20220409214038240"></p>
<h2 id="检索系统的流程"><a href="#检索系统的流程" class="headerlink" title="检索系统的流程"></a>检索系统的流程</h2><p>根据广告位类型对推广单元进行预筛选；</p>
<p>根据各个 Feature 对推广单元进行再过滤； </p>
<p>对推广单元以及推广计划的状态进行过滤；</p>
<p>创意信息与广告位信息的匹配。</p>
<p>匹配完成后返回响应信息给媒体方进行投放。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>此处的索引不等同于数据库中的索引，因为此时检索系统和广告系统是分开的，检索系统中的检索服务并不是需要数据库中的所有字段，并且每次检索都去访问数据库的话，会存在延迟，因此，将检索中用到的数据字段导出存在本地，在检索时不去访问数据库，直接访问本地索引就可以了，只有找到相关的广告系统，才去数据库中去取。因此，此处的索引也是建立在本地内存的基础上，用代码去实现的一个索引。用correnthashmap存储。</p>
<p>假如索引过多，内存较小，可以放在Redis缓存数据库中</p>
<p>正向索引和倒排索引（反向索引）</p>
<p><img src="E:\学习笔记\图片\image-20220324163258996.png" alt="image-20220324163258996"></p>
<h3 id="正向索引和倒排索引"><a href="#正向索引和倒排索引" class="headerlink" title="正向索引和倒排索引"></a>正向索引和倒排索引</h3><p>正向索引的思想：通过一个正键或者一个唯一找到一个对象</p>
<p>倒排索引：通过内容去确定包含关系的对象，设计是为了存储在全文搜索下某个单词在一个文档或一组文档中存储位置的映射。是在文档检索系统中最常用的数据结构。</p>
<p><img src="E:\学习笔记\图片\image-20220324163251336.png" alt="image-20220324163251336"></p>
<h2 id="构建索引的字段"><a href="#构建索引的字段" class="headerlink" title="构建索引的字段"></a>构建索引的字段</h2><p>广告计划中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Long planId;</span><br><span class="line"><span class="keyword">private</span> Long userId;</span><br><span class="line"><span class="keyword">private</span> Integer planStatus;</span><br><span class="line"><span class="keyword">private</span> Date startDate;</span><br><span class="line"><span class="keyword">private</span> Date endDate;</span><br></pre></td></tr></table></figure>

<p>广告推广单元</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Long unitId;</span><br><span class="line"><span class="keyword">private</span> Integer unitStatus;</span><br><span class="line"><span class="keyword">private</span> Integer positionType;</span><br><span class="line"><span class="keyword">private</span> Long planId;</span><br></pre></td></tr></table></figure>



<h2 id="存储索引的数据结构"><a href="#存储索引的数据结构" class="headerlink" title="存储索引的数据结构"></a>存储索引的数据结构</h2><p>使用ConcurrentHashMap、concurrentSkipListSet，监听 Binlog 更新数据需要线程安全，所以需要线程安全的容器。</p>
<h2 id="索引加载时机"><a href="#索引加载时机" class="headerlink" title="索引加载时机"></a>索引加载时机</h2><p>在加载索引的类上注释@PostConstruct，以在启动检索系统时，就将索引加载进系统</p>
<h2 id="如果广告数据太多，内存中放不下，你会怎么做-？"><a href="#如果广告数据太多，内存中放不下，你会怎么做-？" class="headerlink" title="如果广告数据太多，内存中放不下，你会怎么做 ？"></a>如果广告数据太多，内存中放不下，你会怎么做 ？</h2><p>如果广告数据量非常的大，放到本地的 JVM 里面肯定不合适，我们需要考虑使用分布式缓存。那么，Redis 就是很好的缓存系统。但是，此时，需要考虑广告索引数据结构的序列化和反序列化问题，效率会比本地 JVM 数据结构慢很多。</p>
<h2 id="全量索引"><a href="#全量索引" class="headerlink" title="全量索引"></a>全量索引</h2><h3 id="如何构建"><a href="#如何构建" class="headerlink" title="如何构建"></a>如何构建</h3><p>构建一个新的子服务，将索引存放在文件中，定义一个类dump（常量的声明类），里边定义数据文件的存储地址以及各个表数据的存储文件名，定义表中要导出的字段。将数据库中已经有的数据生成文件放入到本地，系统中需要多少个索引表，就要有几个文件。导出时不需要导出所有的字段，只导出需要建立索引的字段。</p>
<p>在检索系统启动时，先读取文件将文件数据转换成索引对象，再去构建索引，不需要再去访问数据库。</p>
<h3 id="为什么不在数据库中直接读取数据构建索引"><a href="#为什么不在数据库中直接读取数据构建索引" class="headerlink" title="为什么不在数据库中直接读取数据构建索引"></a>为什么不在数据库中直接读取数据构建索引</h3><ol>
<li>ad-search 这样的检索模块，肯定是要多实例部署（我们线上部署了60个实例）。那么，如果实例启动的时候，直接从数据库中读取，会给数据库造成太大的压力，影响其他的业务系统（数据库通常都是服务多个业务系统的）；</li>
<li>ad-search 模块其实是对表结构无感知的，只让检索模块了解到它需要知道的那些字段就可以，例如，推广计划的名称、创建时间等等，对检索起不到作用，不需要知道。这样，即使以后表结构发生变化，但是核心的字段不变，ad-search 的代码就不需要修改。</li>
</ol>
<h2 id="增量索引"><a href="#增量索引" class="headerlink" title="增量索引"></a>增量索引</h2><p>增量索引：系统运行过程中，监控数据库的变化，实时加载更新索引</p>
<h3 id="如何构建-1"><a href="#如何构建-1" class="headerlink" title="如何构建"></a>如何构建</h3><p>由于不想投放系统与检索系统产生太多的关联，所以我们监听所写入的mysql的Binlog，解析Binlog，得到增量数据（增删改），再去实现检索系统的索引更新。通过监听binlog的开源工具mysql-binlog-connector-java 实现</p>
<p><img src="E:\学习笔记\图片\image-20220811190612051.png" alt="image-20220811190612051"></p>
<p>使用Row格式</p>
<p><img src="E:\学习笔记\图片\image-20220811190716206.png" alt="image-20220811190716206"></p>
<img src="E:\学习笔记\图片\image-20220811191242128.png" alt="image-20220811191242128" style="zoom:33%;" />

<p>解析出来的数据</p>
<p><img src="E:\学习笔记\图片\image-20220811192427056.png" alt="image-20220811192427056"></p>
<p>因此需要一个模板，去解析出binlog监听到的数据。</p>
<h3 id="模板文件"><a href="#模板文件" class="headerlink" title="模板文件"></a>模板文件</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;database&quot;</span><span class="punctuation">:</span> <span class="string">&quot;imooc_ad_data&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tableList&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;tableName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ad_plan&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;level&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;insert&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;id&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;user_id&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;plan_status&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;start_date&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;end_date&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;update&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;id&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;user_id&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;plan_status&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;start_date&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;end_date&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;delete&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;id&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;tableName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ad_unit&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;level&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;insert&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;id&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;unit_status&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;position_type&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;plan_id&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;update&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;id&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;unit_status&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;position_type&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;plan_id&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;delete&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;id&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;tableName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ad_creative&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;level&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;insert&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;id&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;type&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;material_type&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;height&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;width&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;audit_status&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;url&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;update&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;id&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;type&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;material_type&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;height&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;width&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;audit_status&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;url&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;delete&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;id&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;tableName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;creative_unit&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;level&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;insert&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;creative_id&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;unit_id&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;update&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;delete&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;creative_id&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;unit_id&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;tableName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ad_unit_district&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;level&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;insert&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;unit_id&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;province&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;city&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;update&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;delete&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;unit_id&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;province&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;city&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;tableName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ad_unit_it&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;level&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;insert&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;unit_id&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;it_tag&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;update&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;delete&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;unit_id&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;it_tag&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;tableName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ad_unit_keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;level&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;insert&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;unit_id&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;update&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;delete&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;unit_id&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="假如存在其他的系统需要访问增量数据"><a href="#假如存在其他的系统需要访问增量数据" class="headerlink" title="假如存在其他的系统需要访问增量数据"></a>假如存在其他的系统需要访问增量数据</h2><p>将数据投放到kafka中，其他的服务可以监听kafka的topic，去获得Binlog的增量数据。</p>
<h2 id="Kafka的使用"><a href="#Kafka的使用" class="headerlink" title="Kafka的使用"></a>Kafka的使用</h2><ul>
<li><strong>投递给数据分析子系统：对广告主的广告数据变更行为进行建模分析</strong></li>
<li><strong>投递给日志系统：用于打印记录广告主数据变更历史，用于将来的数据核对</strong></li>
<li><strong>…</strong></li>
</ul>
<h2 id="Mysql的Binlog格式类型"><a href="#Mysql的Binlog格式类型" class="headerlink" title="Mysql的Binlog格式类型"></a>Mysql的Binlog格式类型</h2><p>MySQL binlog的格式有三种：基于SQL语句的复制(statement-based replication, SBR)，基于行的复制(row-based replication, RBR)，混合模式复制(mixed-based replication, MBR)。</p>
<p>相应地，binlog的格式也有三种：STATEMENT，ROW，MIXED。它主要用于mysql的复制技术。</p>
<p><strong>Row Level 行模式</strong></p>
<p>日志中会记录每一行数 据被修改的形式，然后在slave端再对相同的数据进行修改</p>
<p>优点：在row level模式下，bin-log中可以不记录执行的sql语句的上下文相关的信息，仅仅只需要记录那一条被修改。所以rowlevel的日志内容会非常清楚的记录下每一行数据修改的细节。不会出现某些特定的情况下的存储过程或function，以及trigger的调用和触发无法被正确复制的问题</p>
<p>缺点：row level，所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，会产生大量的日志内容。</p>
<p><strong>Statement Level（默认）</strong></p>
<p>每一条会修改数据的sql都会记录到master的bin-log中。slave在复制的时候sql进程会解析成和原来master端执行过的相同的sql来再次执行</p>
<p><strong>优点：</strong>statement level下的优点首先就是解决了row level下的缺点，不需要记录每一行数据的变化，减少bin-log日志量，节约IO，提高性能，因为它只需要在Master上锁执行的语句的细节，以及执行语句的上下文的信息。</p>
<p>缺点：由于只记录语句，所以，在statement level下 已经发现了有不少情况会造成MySQL的复制出现问题，主要是修改数据的时候使用了某些定的函数或者功能的时候会出现。</p>
<p><strong>Mixed 自动模式</strong></p>
<p>在Mixed模式下，MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志格式，也就是在Statement和Row之间选择一种。如果sql语句确实就是update或者delete等修改数据的语句，那么还是会记录所有行的变更。</p>
<p>企业场景如何选择binlog模式</p>
<p>1、互联网公司，使用MySQL的功能相对少（存储过程、触发器、函数）</p>
<p>选择默认的语句模式，Statement Level（默认）</p>
<p>2、公司如果用到使用MySQL的特殊功能（存储过程、触发器、函数）</p>
<p>则选择Mixed模式</p>
<p>3、公司如果用到使用MySQL的特殊功能（存储过程、触发器、函数）又希望数据最大化一直，此时最好选择Row level模式</p>
<h1 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h1><h2 id="以jar包方式部署"><a href="#以jar包方式部署" class="headerlink" title="以jar包方式部署"></a>以jar包方式部署</h2><p>第一步：将项目打包方式修改为jar</p>
<p>第二步：在idea中Terminal控制台执行maven打包命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mvn clean 会把原来target目录给删掉重新生成。</span><br><span class="line">mvn package 会打包成jar到target目录</span><br><span class="line"></span><br><span class="line">mvn clean package依次执行了clean、resources、compile、testResources、testCompile、test、jar(打包)等７个阶段。</span><br></pre></td></tr></table></figure>

<p>命令执行完毕后，在target目录下生成了jar包</p>
<p> 第三步：使用xftp将jar包上传到服务器&#x2F;usr&#x2F;local&#x2F;springboot-helloworld目录下</p>
<p>第四步：运行jar包</p>
<p>先切换到jar包所在目录：</p>
<p>cd &#x2F;usr&#x2F;local&#x2F;springboot-helloworld&#x2F;<br>运行jar:</p>
<p>java -jar springboot-helloworld-0.0.1-SNAPSHOT.jar<br>出现如下信息表示启动成功：</p>
<p>第五步：测试</p>
<h1 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h1><h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><p>限流就是对请求的速率进行限制，避免瞬时的大量请求击垮软件系统。</p>
<h3 id="常见的限流算法"><a href="#常见的限流算法" class="headerlink" title="常见的限流算法"></a>常见的限流算法</h3><h4 id="固定窗口计数器算法"><a href="#固定窗口计数器算法" class="headerlink" title="固定窗口计数器算法"></a>固定窗口计数器算法</h4><p>固定窗口其实就是时间窗口。<strong>固定窗口计数器算法</strong> 规定了我们单位时间处理的请求数量。</p>
<p>假如我们规定系统中某个接口 1 分钟只能访问 33 次的话，使用固定窗口计数器算法的实现思路如下：</p>
<ul>
<li>给定一个变量 <code>counter</code> 来记录当前接口处理的请求数量，初始值为 0（代表接口当前 1 分钟内还未处理请求）。</li>
<li>1 分钟之内每处理一个请求之后就将 <code>counter+1</code> ，当 <code>counter=33</code> 之后（也就是说在这 1 分钟内接口已经被访问 33 次的话），后续的请求就会被全部拒绝。</li>
<li>等到 1 分钟结束后，将 <code>counter</code> 重置 0，重新开始计数。</li>
</ul>
<p><strong>这种限流算法无法保证限流速率，因而无法保证突然激增的流量。</strong></p>
<h4 id="滑动窗口计数器算法"><a href="#滑动窗口计数器算法" class="headerlink" title="滑动窗口计数器算法"></a>滑动窗口计数器算法</h4><p><strong>滑动窗口计数器算法</strong> 算的上是固定窗口计数器算法的升级版。</p>
<p>滑动窗口计数器算法相比于固定窗口计数器算法的优化在于：<strong>它把时间以一定比例分片</strong> 。</p>
<p>例如我们的接口限流每分钟处理 60 个请求，我们可以把 1 分钟分为 60 个窗口。每隔 1 秒移动一次，每个窗口一秒只能处理 不大于 <code>60(请求数)/60（窗口数）</code> 的请求， 如果当前窗口的请求计数总和超过了限制的数量的话就不再处理其他请求。</p>
<p>很显然， <strong>当滑动窗口的格子划分的越多，滑动窗口的滚动就越平滑，限流的统计就会越精确。</strong></p>
<h4 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h4><p>我们可以把发请求的动作比作成注水到桶中，我们处理请求的过程可以比喻为漏桶漏水。我们往桶中以任意速率流入水，以一定速率流出水。当水超过桶流量则丢弃，因为桶容量是不变的，保证了整体的速率。</p>
<p>用队列实现</p>
<h4 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h4><p>令牌桶算法和漏桶算法算法一样，不过现在桶里装的是令牌了，请求在被处理之前需要拿到一个令牌，请求处理完毕之后将这个令牌丢弃（删除）。我们根据限流大小，按照一定的速率往桶里添加令牌。如果桶装满了，就不能继续往里面继续添加令牌了。</p>
<h3 id="单机限流"><a href="#单机限流" class="headerlink" title="单机限流"></a>单机限流</h3><p>单机限流可以直接使用 Google Guava 自带的限流工具类 <code>RateLimiter</code> 。 <code>RateLimiter</code> 基于令牌桶算法，可以应对突发流量。</p>
<blockquote>
<p>Guava 地址：<a target="_blank" rel="noopener" href="https://github.com/google/guava">https://github.com/google/guava</a></p>
</blockquote>
<p>除了最基本的令牌桶算法(<strong>平滑突发限流</strong>)实现之外，Guava 的<code>RateLimiter</code>还提供了 <strong>平滑预热限流</strong> 的算法实现。</p>
<p>平滑突发限流就是按照指定的速率放令牌到桶里，而平滑预热限流会有一段预热时间，预热时间之内，速率会逐渐提升到配置的速率。</p>
<h4 id="平滑突发限流"><a href="#平滑突发限流" class="headerlink" title="平滑突发限流"></a>平滑突发限流</h4><p>以同样的速率稳定的向令牌桶中天剑令牌。</p>
<h4 id="平滑预热限流"><a href="#平滑预热限流" class="headerlink" title="平滑预热限流"></a>平滑预热限流</h4><p>在刚开的一段时间内，以逐渐增快的速率向令牌桶中添加令牌，逐步达到规定的速率，然后平稳添加。</p>
<p>举例：</p>
<p>假如要1s 放 5 个令牌到桶里，那么就是每0.2s放入一个令牌</p>
<p><strong>平滑突发限流：</strong>也就是 0.2s 放 1个令牌到桶里</p>
<p><strong>平滑预热限流：</strong>假如预热时间为3s,也就说刚开始的 3s 内发牌速率会逐渐提升到 0.2s 放 1 个令牌</p>
<h3 id="分布式限流"><a href="#分布式限流" class="headerlink" title="分布式限流"></a>分布式限流</h3><p>分布式限流常见的方案：</p>
<ul>
<li><strong>借助中间件架限流</strong> ：可以借助 Sentinel 或者使用 Redis 来自己实现对应的限流逻辑。</li>
<li><strong>网关层限流</strong> ：比较常用的一种方案，直接在网关层把限流给安排上了。不过，通常网关层限流通常也需要借助到中间件&#x2F;框架。就比如 Spring Cloud Gateway 的分布式限流实现<code>RedisRateLimiter</code>就是基于 Redis+Lua 来实现的，再比如 Spring Cloud Gateway 还可以整合 Sentinel 来做限流。</li>
</ul>
<p>如果要基于 Redis 来手动实现限流逻辑的话，建议配合 Lua 脚本来做。</p>
<h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><p>Shell 编程就是对一堆 Linux 命令的逻辑化处理</p>
<h2 id="Shell-编程的-Hello-World"><a href="#Shell-编程的-Hello-World" class="headerlink" title="Shell 编程的 Hello World"></a>Shell 编程的 Hello World</h2><p>学习任何一门编程语言第一件事就是输出 HelloWorld 了！下面我会从新建文件到 shell 代码编写来说下 Shell 编程如何输出 Hello World。</p>
<p>(1)新建一个文件 helloworld.sh :<code>touch helloworld.sh</code>，扩展名为 sh（sh 代表 Shell）（扩展名并不影响脚本执行，见名知意就好，如果你用 php 写 shell 脚本，扩展名就用 php 好了）</p>
<p>(2) 使脚本具有执行权限：<code>chmod +x helloworld.sh</code></p>
<p>(3) 使用 vim 命令修改 helloworld.sh 文件：<code>vim helloworld.sh</code>(vim 文件——&gt;进入文件—–&gt;命令模式——&gt;按 i 进入编辑模式—–&gt;编辑文件 ——-&gt;按 Esc 进入底行模式—–&gt;输入**:wq&#x2F;q!** （输入 wq 代表写入内容并退出，即保存；输入 q!代表强制退出不保存。）)</p>
<p>helloworld.sh 内容如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#第一个shell小程序,echo 是linux中的输出命令。</span></span><br><span class="line"><span class="built_in">echo</span>  <span class="string">&quot;helloworld!&quot;</span></span><br></pre></td></tr></table></figure>

<p>shell 中 # 符号表示注释。<strong>shell 的第一行比较特殊，一般都会以#!开始来指定使用的 shell 类型。在 linux 中，除了 bash shell 以外，还有很多版本的 shell， 例如 zsh、dash 等等…不过 bash shell 还是我们使用最多的。</strong></p>
<p>(4) 运行脚本:<code>./helloworld.sh</code> 。（注意，一定要写成 <code>./helloworld.sh</code> ，而不是 <code>helloworld.sh</code> ，运行其它二进制的程序也一样，直接写 <code>helloworld.sh</code> ，linux 系统会去 PATH 里寻找有没有叫 helloworld.sh 的，而只有 &#x2F;bin, &#x2F;sbin, &#x2F;usr&#x2F;bin，&#x2F;usr&#x2F;sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 <code>helloworld.sh</code> 是会找不到命令的，要用<code>./helloworld.sh</code> 告诉系统说，就在当前目录找。）</p>
<h2 id="Shell-编程中的变量介绍"><a href="#Shell-编程中的变量介绍" class="headerlink" title="Shell 编程中的变量介绍"></a>Shell 编程中的变量介绍</h2><p><strong>Shell 编程中一般分为三种变量：</strong></p>
<ol>
<li><strong>我们自己定义的变量（自定义变量）:</strong> 仅在当前 Shell 实例中有效，其他 Shell 启动的程序不能访问局部变量。</li>
<li><strong>Linux 已定义的环境变量</strong>（环境变量， 例如：<code>PATH</code>, <code>HOME</code> 等…, 这类变量我们可以直接使用），使用 <code>env</code> 命令可以查看所有的环境变量，而 set 命令既可以查看环境变量也可以查看自定义变量。</li>
<li><strong>Shell 变量</strong> ：Shell 变量是由 Shell 程序设置的特殊变量。Shell 变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了 Shell 的正常运行</li>
</ol>
<p><strong>常用的环境变量:</strong></p>
<blockquote>
<p>PATH 决定了 shell 将到哪些目录中寻找命令或程序<br>HOME 当前用户主目录<br>HISTSIZE 　历史记录数<br>LOGNAME 当前用户的登录名<br>HOSTNAME 　指主机的名称<br>SHELL 当前用户 Shell 类型<br>LANGUAGE 　语言相关的环境变量，多语言可以修改此环境变量<br>MAIL 　当前用户的邮件存放目录<br>PS1 　基本提示符，对于 root 用户是#，对于普通用户是$</p>
</blockquote>
<p><strong>Shell 编程中的变量名的命名的注意事项：</strong></p>
<ul>
<li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头，但是可以使用下划线（_）开头。</li>
<li>中间不能有空格，可以使用下划线（_）。</li>
<li>不能使用标点符号。</li>
<li>不能使用 bash 里的关键字（可用 help 命令查看保留关键字）。</li>
</ul>
<h2 id="Shell-字符串"><a href="#Shell-字符串" class="headerlink" title="Shell 字符串"></a>Shell 字符串</h2><p><strong>字符串操作：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">name=<span class="string">&quot;SnailClimb&quot;</span></span><br><span class="line"><span class="comment"># 使用双引号拼接</span></span><br><span class="line">greeting=<span class="string">&quot;hello, &quot;</span><span class="variable">$name</span><span class="string">&quot; !&quot;</span></span><br><span class="line">greeting_1=<span class="string">&quot;hello, <span class="variable">$&#123;name&#125;</span> !&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$greeting</span>  <span class="variable">$greeting_1</span></span><br><span class="line"><span class="comment"># 使用单引号拼接</span></span><br><span class="line">greeting_2=<span class="string">&#x27;hello, &#x27;</span><span class="variable">$name</span><span class="string">&#x27; !&#x27;</span></span><br><span class="line">greeting_3=<span class="string">&#x27;hello, $&#123;name&#125; !&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$greeting_2</span>  <span class="variable">$greeting_3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取字符串长度</span></span><br><span class="line"><span class="comment"># 第一种方式</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#name&#125;</span> <span class="comment">#输出 10</span></span><br><span class="line"><span class="comment"># 第二种方式</span></span><br><span class="line"><span class="built_in">expr</span> length <span class="string">&quot;<span class="variable">$name</span>&quot;</span></span><br><span class="line"><span class="comment">#使用 expr 命令时，表达式中的运算符左右必须包含空格，如果不包含空格，将会输出表达式本身:</span></span><br><span class="line"><span class="built_in">expr</span> 5+6    // 直接输出 5+6</span><br><span class="line"><span class="built_in">expr</span> 5 + 6       // 输出 11</span><br><span class="line"><span class="comment">#对于某些运算符，还需要我们使用符号\进行转义，否则就会提示语法错误。</span></span><br><span class="line"><span class="built_in">expr</span> 5 * 6       // 输出错误</span><br><span class="line"><span class="built_in">expr</span> 5 \* 6      // 输出30<span class="string">&quot;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#截取子字符串:</span></span><br><span class="line"><span class="string">#简单的字符串截取：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#从字符串第 1 个字符开始往后截取 10 个字符</span></span><br><span class="line"><span class="string">str=&quot;</span>SnailClimb is a great man<span class="string">&quot;</span></span><br><span class="line"><span class="string">echo <span class="variable">$&#123;str:0:10&#125;</span> #输出:SnailClimb</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#根据表达式截取：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">var=&quot;</span>https://www.runoob.com/linux/linux-shell-variable.html<span class="string">&quot;</span></span><br><span class="line"><span class="string"># %表示删除从后匹配, 最短结果</span></span><br><span class="line"><span class="string"># %%表示删除从后匹配, 最长匹配结果</span></span><br><span class="line"><span class="string"># #表示删除从头匹配, 最短结果</span></span><br><span class="line"><span class="string"># ##表示删除从头匹配, 最长匹配结果</span></span><br><span class="line"><span class="string"># 注: *为通配符, 意为匹配任意数量的任意字符</span></span><br><span class="line"><span class="string">s1=<span class="variable">$&#123;var%%t*&#125;</span> #h</span></span><br><span class="line"><span class="string">s2=<span class="variable">$&#123;var%t*&#125;</span>  #https://www.runoob.com/linux/linux-shell-variable.h</span></span><br><span class="line"><span class="string">s3=<span class="variable">$&#123;var%%.*&#125;</span> #http://www</span></span><br><span class="line"><span class="string">s4=<span class="variable">$&#123;var#*/&#125;</span>  #/www.runoob.com/linux/linux-shell-variable.html</span></span><br><span class="line"><span class="string">s5=<span class="variable">$&#123;var##*/&#125;</span> #linux-shell-variable.html</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<h2 id="Shell-数组"><a href="#Shell-数组" class="headerlink" title="Shell 数组"></a>Shell 数组</h2><p>bash 支持一维数组（不支持多维数组），并且没有限定数组的大小。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#数组操作</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">array=(1 2 3 4 5);</span><br><span class="line"><span class="comment"># 获取数组长度</span></span><br><span class="line">length=<span class="variable">$&#123;#array[@]&#125;</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">length2=<span class="variable">$&#123;#array[*]&#125;</span></span><br><span class="line"><span class="comment">#输出数组长度</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$length</span> <span class="comment">#输出：5</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$length2</span> <span class="comment">#输出：5</span></span><br><span class="line"><span class="comment"># 输出数组第三个元素</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[2]&#125;</span> <span class="comment">#输出：3</span></span><br><span class="line"><span class="built_in">unset</span> array[1]<span class="comment"># 删除下标为1的元素也就是删除第二个元素</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;array[@]&#125;</span>;<span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span> ;<span class="keyword">done</span> <span class="comment"># 遍历数组，输出： 1 3 4 5</span></span><br><span class="line"><span class="built_in">unset</span> array; <span class="comment"># 删除数组中的所有元素</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;array[@]&#125;</span>;<span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span> ;<span class="keyword">done</span> <span class="comment"># 遍历数组，数组元素为空，没有任何输出内容</span></span><br></pre></td></tr></table></figure>

<h2 id="Shell-基本运算符"><a href="#Shell-基本运算符" class="headerlink" title="Shell 基本运算符"></a>Shell 基本运算符</h2><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><p><img src="E:\学习笔记\图片\4937342.jpg" alt="算数运算符"></p>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p>
<p><img src="E:\学习笔记\图片\64391380.jpg" alt="shell关系运算符"></p>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p><img src="E:\学习笔记\图片\60545848-1660015151549.jpg" alt="逻辑运算符"></p>
<h3 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h3><p><img src="E:\学习笔记\图片\93961425.jpg" alt="布尔运算符"></p>
<h3 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h3><p><img src="E:\学习笔记\图片\309094.jpg" alt=" 字符串运算符"></p>
<h3 id="文件相关运算符"><a href="#文件相关运算符" class="headerlink" title="文件相关运算符"></a>文件相关运算符</h3><p><img src="E:\学习笔记\图片\60359774.jpg" alt="文件相关运算符"></p>
<p>假如我们定义好了一个文件路径<code>file=&quot;/usr/learnshell/test.sh&quot;</code> 如果我们想判断这个文件是否可读，可以这样<code>if [ -r $file ]</code></p>
<h2 id="shell-流程控制"><a href="#shell-流程控制" class="headerlink" title="shell 流程控制"></a>shell 流程控制</h2><h3 id="if-条件语句"><a href="#if-条件语句" class="headerlink" title="if 条件语句"></a>if 条件语句</h3><p>简单的 if else-if else 的条件语句示例</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">a=3;</span><br><span class="line">b=9;</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -eq <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;a 等于 b&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$a</span> -gt <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;a 大于 b&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;a 小于 b&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a 小于 b</span><br></pre></td></tr></table></figure>

<p>相信大家通过上面的示例就已经掌握了 shell 编程中的 if 条件语句。不过，还要提到的一点是，不同于我们常见的 Java 以及 PHP 中的 if 条件语句，shell if 条件语句中不能包含空语句也就是什么都不做的语句。</p>
<h3 id="for-循环语句"><a href="#for-循环语句" class="headerlink" title="for 循环语句"></a>for 循环语句</h3><p>通过下面三个简单的示例认识 for 循环语句最基本的使用，实际上 for 循环语句的功能比下面你看到的示例展现的要大得多。</p>
<p><strong>输出当前列表中的数据：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> loop <span class="keyword">in</span> 1 2 3 4 5</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;The value is: <span class="variable">$loop</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p><strong>产生 10 个随机数：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;0..9&#125;;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="variable">$RANDOM</span>;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p><strong>输出 1 到 5:</strong></p>
<p>通常情况下 shell 变量调用需要加 $,但是 for 的 (()) 中不需要,下面来看一个例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">for</span>((i=1;i&lt;=5;i++));</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span>;</span><br><span class="line"><span class="keyword">done</span>;</span><br></pre></td></tr></table></figure>

<h3 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h3><p><strong>基本的 while 循环语句：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">int=1</span><br><span class="line"><span class="keyword">while</span>(( <span class="variable">$int</span>&lt;=5 ))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$int</span></span><br><span class="line">    <span class="built_in">let</span> <span class="string">&quot;int++&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p><strong>while 循环可用于读取键盘信息：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;按下 &lt;CTRL-D&gt; 退出&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&#x27;输入你最喜欢的电影: &#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> FILM</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;是的！<span class="variable">$FILM</span> 是一个好电影&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>输出内容:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">按下 &lt;CTRL-D&gt; 退出</span><br><span class="line">输入你最喜欢的电影: 变形金刚</span><br><span class="line">是的！变形金刚 是一个好电影</span><br></pre></td></tr></table></figure>

<p><strong>无限循环：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h2 id="shell-函数"><a href="#shell-函数" class="headerlink" title="shell 函数"></a>shell 函数</h2><h3 id="不带参数没有返回值的函数"><a href="#不带参数没有返回值的函数" class="headerlink" title="不带参数没有返回值的函数"></a>不带参数没有返回值的函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="function"><span class="title">hello</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;这是我的第一个 shell 函数!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;-----函数开始执行-----&quot;</span></span><br><span class="line">hello</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;-----函数执行完毕-----&quot;</span></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----函数开始执行-----</span><br><span class="line">这是我的第一个 shell 函数!</span><br><span class="line">-----函数执行完毕-----</span><br></pre></td></tr></table></figure>

<h3 id="有返回值的函数"><a href="#有返回值的函数" class="headerlink" title="有返回值的函数"></a>有返回值的函数</h3><p><strong>输入两个数字之后相加并返回结果：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="function"><span class="title">funWithReturn</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;输入第一个数字: &quot;</span></span><br><span class="line">    <span class="built_in">read</span> aNum</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;输入第二个数字: &quot;</span></span><br><span class="line">    <span class="built_in">read</span> anotherNum</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;两个数字分别为 <span class="variable">$aNum</span> 和 <span class="variable">$anotherNum</span> !&quot;</span></span><br><span class="line">    <span class="built_in">return</span> $((<span class="variable">$aNum</span>+<span class="variable">$anotherNum</span>))</span><br><span class="line">&#125;</span><br><span class="line">funWithReturn</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;输入的两个数字之和为 $?&quot;</span></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入第一个数字:</span><br><span class="line">1</span><br><span class="line">输入第二个数字:</span><br><span class="line">2</span><br><span class="line">两个数字分别为 1 和 2 !</span><br><span class="line">输入的两个数字之和为 3</span><br></pre></td></tr></table></figure>

<h3 id="带参数的函数"><a href="#带参数的函数" class="headerlink" title="带参数的函数"></a>带参数的函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="function"><span class="title">funWithParam</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;第一个参数为 <span class="variable">$1</span> !&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;第二个参数为 <span class="variable">$2</span> !&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;第十个参数为 <span class="variable">$10</span> !&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;第十个参数为 <span class="variable">$&#123;10&#125;</span> !&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;第十一个参数为 <span class="variable">$&#123;11&#125;</span> !&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;参数总数有 <span class="variable">$#</span> 个!&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;作为一个字符串输出所有参数 $* !&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">funWithParam 1 2 3 4 5 6 7 8 9 34 73</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一个参数为 1 !</span><br><span class="line">第二个参数为 2 !</span><br><span class="line">第十个参数为 10 !</span><br><span class="line">第十个参数为 34 !</span><br><span class="line">第十一个参数为 73 !</span><br><span class="line">参数总数有 11 个!</span><br><span class="line">作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !</span><br></pre></td></tr></table></figure>

<h1 id="常用集合的API"><a href="#常用集合的API" class="headerlink" title="常用集合的API"></a>常用集合的API</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">数组 List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">•	add(value) add(<span class="type">int</span> index, <span class="type">int</span> value)</span><br><span class="line">•	get(index) indexOf(value) lastIndexOf(value)</span><br><span class="line">•	set(index, value)</span><br><span class="line">•	size()</span><br><span class="line">•	isEmpty()</span><br><span class="line">•	remove(<span class="type">int</span> index) clear()</span><br><span class="line">•	toArray()</span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">双向链表 List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">•	插入 offerFirst(value) offerLast(value) <span class="comment">// 返回true/false</span></span><br><span class="line">•	取值 peekFirst() peekLast()</span><br><span class="line">•	删除 pollFirst() pollLast()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">栈 Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">•	push(value)</span><br><span class="line">•	peek()</span><br><span class="line">•	poll()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">队列 Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">•	offer()</span><br><span class="line">•	peek()</span><br><span class="line">•	poll()</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">哈希表 Map&lt;Integer, Character&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">•	map.put(key, value)</span><br><span class="line">•	map.get(key) map.getOrDefault(key, defaultValue)</span><br><span class="line">•	map.remove(key)</span><br><span class="line">•	map.size()</span><br><span class="line">•	map.isEmpty()</span><br><span class="line">•	map.containsKey(key)</span><br><span class="line">•	map.keySet() map.values() map.entrySet()</span><br><span class="line">•	map.clear()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">红黑树 TreeSet&lt;Integer&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">•	add(value)</span><br><span class="line">•	remove(value)</span><br><span class="line">•	floor(num) <span class="comment">// 小于等于num的最大值</span></span><br><span class="line">•	ceiling(num) <span class="comment">// 大于等于num的最小值</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">优先队列/堆 Queue&lt;ListNode&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; o1.val - o2.val); <span class="comment">// 小根堆</span></span><br><span class="line">•	offer(value)</span><br><span class="line">•	peek()</span><br><span class="line">•	poll()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">集合 Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">•	add()</span><br><span class="line">•	contains(value)</span><br><span class="line">•	remove()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">保持插入顺序的双向链表哈希表 LinkedHashMap&lt;Integer, Integer&gt; cache = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">•	有HashMap和LinkedList的特性</span><br><span class="line">    </span><br><span class="line">Arrays</span><br><span class="line">•	Arrays.sort();</span><br><span class="line">•	Arrays.fill();</span><br><span class="line">•	Arrays.asList();</span><br><span class="line">•	Arrays.binarySearch(<span class="type">int</span>[] a, <span class="type">int</span> key); <span class="comment">// 二分查找 return int</span></span><br><span class="line">•	Arrays.compare(<span class="type">int</span>[] a, <span class="type">int</span>[] b);</span><br><span class="line">•	Arrays.copyOf(<span class="type">int</span>[] a, <span class="type">int</span> newLength);</span><br><span class="line">•	Arrays.copyOfRange(<span class="type">int</span>[] a, <span class="type">int</span> start, <span class="type">int</span> end);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String的API</span><br><span class="line">s.trim();</span><br><span class="line">s.compareTo(t);</span><br><span class="line">System.out.println(s.strip());</span><br><span class="line">s.substring(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">s.equals(t);</span><br><span class="line">s.endsWith(t);</span><br><span class="line">s.indexOf(t);</span><br><span class="line">s.isEmpty();</span><br><span class="line">s.lastIndexOf(t);</span><br><span class="line">s.repeat(<span class="number">3</span>);</span><br><span class="line">s.replace(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">s.replaceAll(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>);</span><br><span class="line">s.replaceFirst(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">s.concat(t);</span><br><span class="line">s.startsWith(<span class="string">&quot;s&quot;</span>);</span><br><span class="line">s.startsWith(<span class="string">&quot;a&quot;</span>, <span class="number">3</span>);</span><br><span class="line">s.toCharArray();</span><br><span class="line">s.toUpperCase();</span><br><span class="line">s.toLowerCase();</span><br><span class="line"></span><br><span class="line">StringBuilder s;</span><br><span class="line">s.append(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">s.insert(<span class="number">2</span>, <span class="string">&quot;dsfgh&quot;</span>);</span><br><span class="line">s.reverse();</span><br><span class="line">s.toString();</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2022/10/05/Java%E9%9D%A2%E7%BB%8F/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2022/10/05/Java%E9%9B%86%E5%90%88/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            Java集合
          
        </div>
      </a>
    
    
      <a href="/2022/10/05/Hexo%E5%92%8CGithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Hexo和Github搭建个人博客</div>
      </a>
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022
        <i class="ri-heart-fill heart_icon"></i> pp-lv
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.png" alt="LPL&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">Categories</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">Tags</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">About</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i></p>
  <div class="reward-box">
    
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>