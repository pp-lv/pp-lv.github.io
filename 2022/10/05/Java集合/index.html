<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>Java集合 |  LPL&#39;s Blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-Java集合"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Java集合
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/10/05/Java%E9%9B%86%E5%90%88/" class="article-date">
  <time datetime="2022-10-05T12:45:00.000Z" itemprop="datePublished">2022-10-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%85%AB%E8%82%A1%E6%96%87/">八股文</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">9.5k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">34 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="1-Java集合框架图"><a href="#1-Java集合框架图" class="headerlink" title="1.Java集合框架图"></a>1.Java集合框架图</h2><img src="/2022/10/05/Java%E9%9B%86%E5%90%88/Untitled2.png" class="" title="框架图">

<span id="more"></span>

<h2 id="2-HashMap"><a href="#2-HashMap" class="headerlink" title="2.HashMap"></a>2.HashMap</h2><h3 id="2-1-HashMap的底层数据结构"><a href="#2-1-HashMap的底层数据结构" class="headerlink" title="2.1 HashMap的底层数据结构"></a>2.1 HashMap的底层数据结构</h3><p>JDK1.7中，由“<strong>数组+链表</strong>”组成，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。</p>
<p>在JDK1.8 中，由“<strong>数组+链表+红黑树</strong>”组成。当链表过长，则会严重影响 HashMap 的性能，红黑树搜索时间复杂度是 O(logn)，而链表是糟糕的 O(n)。因此，JDK1.8 对数据结构做了进一步的优化，引入了红黑树，链表和红黑树在达到一定条件会进行转换：</p>
<ul>
<li>当链表超过 8 且数组大小超过 64 才会转红黑树。</li>
<li>将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树，以减少搜索时间。</li>
</ul>
<h3 id="2-2-HashMap的put流程"><a href="#2-2-HashMap的put流程" class="headerlink" title="2.2 HashMap的put流程"></a>2.2 HashMap的put流程</h3><ul>
<li>首先根据 key 的值计算 hash 值，找到该元素在数组中存储的下标；</li>
<li>如果数组是空的，则调用 resize 进行初始化；</li>
<li>如果没有哈希冲突直接放在对应的数组下标里；</li>
<li>如果冲突了，且 key 已经存在，就覆盖掉 value；</li>
<li>如果冲突后，发现该节点是红黑树，就将这个节点挂在树上；</li>
<li>如果冲突后是链表，判断该链表是否大于 8 ，如果大于 8 并且数组容量小于 64，就进行扩容；如果链表节点大于 8 并且数组的容量大于 64，则将这个结构转换为红黑树；否则，链表插入键值对，若 key 存在，就覆盖掉 value。</li>
</ul>
<h3 id="2-3-HashMap为什么用红黑树不用B树？"><a href="#2-3-HashMap为什么用红黑树不用B树？" class="headerlink" title="2.3 HashMap为什么用红黑树不用B树？"></a>2.3 HashMap为什么用红黑树不用B树？</h3><p>如果用B&#x2F;B+树的话，在数据量不多的情况下，数据都会“挤在”一个节点里面，这样就退化成了链表。</p>
<h3 id="2-4-为什么不直接用红黑树，而是先选择用链表？"><a href="#2-4-为什么不直接用红黑树，而是先选择用链表？" class="headerlink" title="2.4 为什么不直接用红黑树，而是先选择用链表？"></a>2.4 为什么不直接用红黑树，而是先选择用链表？</h3><p>因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡，而单链表不需要。当元素小于 8 个的时候，此时做查询操作，链表结构已经能保证查询性能。当元素大于 8 个的时候， 红黑树搜索时间复杂度是 O(logn)，而链表是 O(n)，此时需要红黑树来加快查询速度，但是新增节点的效率变慢了。</p>
<p>因此，如果一开始就用红黑树结构，元素太少，新增效率又比较慢，无疑这是浪费性能的。</p>
<h3 id="2-5-为什么不用平衡二叉树"><a href="#2-5-为什么不用平衡二叉树" class="headerlink" title="2.5 为什么不用平衡二叉树"></a>2.5 为什么不用平衡二叉树</h3><p>红黑树的插入和删除，旋转操作最多三次就可以完成，而平衡树可能需要logN，且红黑树不要严格的的平衡，可能引发更少的旋转操作。</p>
<h3 id="2-6-HashMap为什么线程不安全？"><a href="#2-6-HashMap为什么线程不安全？" class="headerlink" title="2.6 HashMap为什么线程不安全？"></a>2.6 HashMap为什么线程不安全？</h3><ul>
<li><p><strong>1）多线程下扩容死循环</strong>。<strong>JDK1.7</strong>中的 HashMap 使用<strong>头插法</strong>插入元素，在多线程的环境下，扩容的时候有可能导致<strong>环形链表</strong>的出现，形成死循环。因此，JDK1.8使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题。</p>
<ul>
<li>在多线程的情况下，当重新调整HashMap大小的时候，就会存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历。如果条件竞争发生了，那么就会产生死循环了。</li>
</ul>
</li>
<li><p><strong>2）多线程的put可能导致元素的丢失</strong>。多线程同时执行 put 操作，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失。此问题在JDK 1.7和 JDK 1.8 中都存在。</p>
</li>
<li><p><strong>3）put和get并发时，可能导致get为null</strong>。线程1执行put时，因为元素个数超出hreshold而导致rehash，线程2此时执行get，有可能导致这个问题。此问题在JDK 1.7和 JDK 1.8 中都存在。</p>
</li>
</ul>
<h3 id="2-7-HashMap的扩容方式"><a href="#2-7-HashMap的扩容方式" class="headerlink" title="2.7 HashMap的扩容方式"></a>2.7 HashMap的扩容方式</h3><h4 id="1-数组"><a href="#1-数组" class="headerlink" title="1.数组"></a>1.数组</h4><p>HashMap 在容量超过负载因子所定义的容量之后，就会扩容。Java 里的数组是无法自动扩容的，方法是<strong>将 HashMap 的大小扩大为原来数组的两倍</strong>，并将原来的对象放入新的数组中。</p>
<p>扩容之后，JDK1.7需要重新计算索引；而JDK1.8不需要像 JDK1.7 的实现那样重新计算hash，只需要看看原来的 hash 值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引 + oldCap ”。</p>
<p>例如：</p>
<blockquote>
<p>假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32：</p>
</blockquote>
<blockquote>
<p>old capacity : 00010000<br>new capacity : 00100000</p>
</blockquote>
<p>下标的计算方法，对于一个 Key，如原Hash值 <code>key1 = 0001 1001 key2 = 0000 1001</code><br> 扩容前 hash &amp; (length - 1) :<br> key1 : 0001 1001 &amp; 0000 1111 -&gt; 0000 1001<br> key2 : 0000 1001 &amp; 0000 1111 -&gt; 0000 1001</p>
<p>扩容后   hash &amp; (length - 1) :<br> key1 : 0001 1001 &amp; 0001 1111 -&gt; 0001 1001<br> key2 : 0000 1001 &amp; 0001 1111 -&gt; 0000 1001</p>
<p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，<br>只需要看原来的hash值在扩容后新增的那一位（len-1:0000 1111-&gt;0001 1111）是1还是0，如果是0的话索引没变，是1的话索引变成“原索引+oldCap” 。</p>
<h4 id="2-链表"><a href="#2-链表" class="headerlink" title="2.链表"></a>2.链表</h4><p>JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置（头插法）。JDK1.8不会倒置，使用尾插法。</p>
<ol>
<li>数组的初始容量为16，而容量是以2的次方扩充的，一是为了提高性能使用足够大的数组，二是为了能使用位运算代替取模预算(据说提升了5~8倍)。</li>
<li>数组是否需要扩充是通过负载因子判断的，如果当前元素个数为数组容量的0.75时，就会扩充数组。这个0.75就是默认的负载因子，可由构造器传入。我们也可以设置大于1的负载因子，这样数组就不会扩充，牺牲性能，节省内存。</li>
<li>为了解决碰撞，数组中的元素是单向链表类型。当链表长度到达一个阈值时（7或8），会将链表转换成红黑树提高性能。而当链表长度缩小到另一个阈值时（6），又会将红黑树转换回单向链表提高性能。</li>
<li>对于第三点补充说明，检查链表长度转换成红黑树之前，还会先检测当前数组数组是否到达一个阈值（64），如果没有到达这个容量，会放弃转换，先去扩充数组。所以上面也说了链表长度的阈值是7或8，因为会有一次放弃转换的操作。</li>
</ol>
<h3 id="2-8-HashMap-的长度为什么是-2-的幂次方"><a href="#2-8-HashMap-的长度为什么是-2-的幂次方" class="headerlink" title="2.8 HashMap 的长度为什么是 2 的幂次方"></a>2.8 HashMap 的长度为什么是 2 的幂次方</h3><p>“取余(%)操作中如果<strong>除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作</strong>（也就是说 hash%length&#x3D;&#x3D;hash&amp;(length-1)的前提是 length 是 2 的 n 次方；）。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率。</p>
<h3 id="2-9-HashMap-中-key-的存储索引的计算方式"><a href="#2-9-HashMap-中-key-的存储索引的计算方式" class="headerlink" title="2.9 HashMap 中 key 的存储索引的计算方式"></a>2.9 HashMap 中 key 的存储索引的计算方式</h3><p>取key的 hashCode 值、根据 hashcode 计算出hash值、通过取模计算下标。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK 1.8</span></span><br><span class="line"><span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-10-一般用什么作为HashMap的Key"><a href="#2-10-一般用什么作为HashMap的Key" class="headerlink" title="2.10 一般用什么作为HashMap的Key?"></a>2.10 一般用什么作为HashMap的Key?</h3><p>一般用Integer、String 这种不可变类当 HashMap 当 key，而且 String 最为常用。</p>
<ul>
<li>因为字符串是不可变的，所以在它创建的时候 hashcode 就被缓存了，不需要重新计算。这就是HashMap 中的键往往都使用字符串的原因。</li>
<li>因为获取对象的时候要用到 equals() 和 hashCode() 方法，那么键对象正确的重写这两个方法是非常重要的,这些类已经很规范的重写了 hashCode() 以及 equals() 方法。</li>
</ul>
<h2 id="3-HashMap和HashTable的区别？"><a href="#3-HashMap和HashTable的区别？" class="headerlink" title="3.HashMap和HashTable的区别？"></a>3.HashMap和HashTable的区别？</h2><ol>
<li><strong>线程是否安全：</strong> <code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,因为 <code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）；</li>
<li><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰，不要在代码中使用它；</li>
<li><strong>对 Null key 和 Null value 的支持：</strong> <code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。</li>
<li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ① 创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</li>
<li><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li>
</ol>
<h3 id="3-1-HashMap-和-HashSet-区别"><a href="#3-1-HashMap-和-HashSet-区别" class="headerlink" title="3.1 HashMap 和 HashSet 区别"></a>3.1 HashMap 和 HashSet 区别</h3><p><code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的。（<code>HashSet</code> 的源码非常非常少，因为除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code>是 <code>HashSet</code> 自己不得不实现之外，其他方法都是直接调用 <code>HashMap</code> 中的方法。</p>
<img src="/2022/10/05/Java%E9%9B%86%E5%90%88/image-20220504020551691.png" class="" title="对比表">

<img src="E:\blog\source\_posts\Java集合\image-20220504020551691.png" alt="image-20220504020551691" style="zoom:40%;" />

<h3 id="3-2-HashMap-和-TreeMap-区别"><a href="#3-2-HashMap-和-TreeMap-区别" class="headerlink" title="3.2 HashMap 和 TreeMap 区别"></a>3.2 HashMap 和 TreeMap 区别</h3><p><code>TreeMap</code> 和<code>HashMap</code> 都继承自<code>AbstractMap</code> ，</p>
<p>但是<code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code> 接口。</p>
<ul>
<li>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力，例如返回集合内某一范围 的数据。。</li>
<li>实现<code>SortedMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。</li>
</ul>
<p><strong>相比于<code>HashMap</code>来说 <code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</strong></p>
<h3 id="3-3-HashSet-如何检查重复"><a href="#3-3-HashSet-如何检查重复" class="headerlink" title="3.3 HashSet 如何检查重复"></a>3.3 HashSet 如何检查重复</h3><p>当你把对象加入<code>HashSet</code>时，<code>HashSet</code> 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code>相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p>
<h2 id="4-ConcurrentHashMap的实现"><a href="#4-ConcurrentHashMap的实现" class="headerlink" title="4. ConcurrentHashMap的实现"></a>4. ConcurrentHashMap的实现</h2><p>JDK1.7是 <strong>Segment数据结构</strong>和<strong>HashEntry数组结构</strong>组成<strong>。采用分段锁保证安全性。</strong></p>
<ul>
<li><p>ConcurrentHashMap是由 Segment 数组结构和 HashEntry 数组结构（数组+链表实现）组成，即ConcurrentHashMap 把哈希桶切分成小数组（Segment ），每个小数组有 n 个HashEntry 组成。</p>
</li>
<li><p>ConcurrentHashMap有3个参数：</p>
<ol>
<li>initialCapacity：初始总容量，默认16</li>
<li>loadFactor：加载因子，默认0.75</li>
<li>concurrencyLevel：并发级别，默认16</li>
</ol>
<p><strong>其中并发级别控制了Segment的个数，在一个ConcurrentHashMap创建后Segment的个数是不能变的，扩容过程过改变的是每个Segment的大小。</strong></p>
</li>
<li><p>Segment 继承了 ReentrantLock，所以 Segment 是一种可重入锁，扮演锁的角色；HashEntry用于存储键值对数据。</p>
<p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问，能够实现真正的并发访问。</p>
<img src="/2022/10/05/Java%E9%9B%86%E5%90%88/image-20220504030830009.png" class="" title="JDK1.7中ConcurrentHashMap结构"></li>
</ul>
<p>JDK1.8中，摒弃了Segment的概念，直接用<strong>Node数组+链表+红黑树</strong>。并发控制使用Synchronized和CAS实现更加低粒度的锁。将锁的级别控制在了更细粒度的哈希桶元素级别，也就是说只需要锁住这个链表头结点（红黑树的根节点），就不会影响其他的哈希桶元素的读写，大大提高了并发度。</p>
<img src="/2022/10/05/Java%E9%9B%86%E5%90%88/image-20220504030905643.png" class="" title="JDK1.8中ConcurrentHashMap结构">

<h3 id="4-1-为什么JDK1-8要弃用segment"><a href="#4-1-为什么JDK1-8要弃用segment" class="headerlink" title="4.1 为什么JDK1.8要弃用segment"></a>4.1 为什么JDK1.8要弃用segment</h3><p><strong>1. 锁的粒度</strong><br>首先锁的粒度并没有变粗，甚至变得更细了。每当扩容一次，ConcurrentHashMap的并发度就扩大一倍，而1.7中，并发数由segment个数决定，一旦确定就不改变。<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升。<br><strong>2. Hash冲突</strong><br>JDK1.7中，ConcurrentHashMap通过二次hash的方式（Segment -&gt; HashEntry）能够快速的找到查找的元素。在1.8中通过链表加红黑树的形式弥补了put、get时的性能差距。<br><strong>3. 扩容</strong><br>JDK1.8中，在ConcurrentHashmap进行扩容时，其他线程可以通过检测数组中的节点决定是否对这条链表（红黑树）进行扩容，减小了扩容的粒度，提高了扩容的效率。</p>
<h3 id="4-2-为什么是synchronized，而不是可重入锁"><a href="#4-2-为什么是synchronized，而不是可重入锁" class="headerlink" title="4.2 为什么是synchronized，而不是可重入锁"></a>4.2 为什么是synchronized，而不是可重入锁</h3><p><strong>1. 减少内存开销</strong><br>假设使用可重入锁来获得同步支持，那么每个节点都需要通过继承AQS来获得同步支持。但并不是每个节点都需要获得同步支持的，只有链表的头节点（红黑树的根节点）需要同步，这无疑带来了巨大内存浪费。<br><strong>2. 获得JVM的支持</strong><br>可重入锁毕竟是API这个级别的，后续的性能优化空间很小。<br>synchronized则是JVM直接支持的，JVM能够在运行时作出相应的优化措施：锁粗化、锁消除、锁自旋等等。这就使得synchronized能够随着JDK版本的升级而不改动代码的前提下获得性能上的提升。</p>
<h3 id="4-3-ConcurrentHashMap-的-put-方法执行逻辑是什么？"><a href="#4-3-ConcurrentHashMap-的-put-方法执行逻辑是什么？" class="headerlink" title="4.3 ConcurrentHashMap 的 put 方法执行逻辑是什么？"></a>4.3 ConcurrentHashMap 的 put 方法执行逻辑是什么？</h3><p><strong>JDK1.7</strong>。首先，会尝试获取锁，如果获取失败，利用自旋获取锁；如果自旋重试的次数超过 64 次，则改为阻塞获取锁。获取到锁后：</p>
<ul>
<li>1 将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry。</li>
<li>2 遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的value。</li>
<li>3 不相等则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容。</li>
<li>4 释放 Segment 的锁。</li>
</ul>
<p><strong>JDK1.8</strong>。</p>
<ul>
<li>1 根据 key 计算出 hash值。</li>
<li>2 判断是否需要进行初始化。</li>
<li>3 定位到 Node，拿到首节点 f，判断首节点 f：<ul>
<li>如果为 null ，则通过cas的方式尝试添加。</li>
<li>如果为 f.hash &#x3D; MOVED &#x3D; -1 ，说明其他线程在扩容，参与一起扩容。</li>
<li>如果都不满足 ，synchronized 锁住 f 节点，判断是链表还是红黑树，遍历插入。</li>
</ul>
</li>
<li>4 当在链表长度达到8的时候，数组扩容或者将链表转换为红黑树。</li>
</ul>
<h3 id="4-4-JDK1-7-和-JDK1-8的ConcurrentHashMap实现有什么不同？"><a href="#4-4-JDK1-7-和-JDK1-8的ConcurrentHashMap实现有什么不同？" class="headerlink" title="4.4 JDK1.7 和 JDK1.8的ConcurrentHashMap实现有什么不同？"></a>4.4 JDK1.7 和 JDK1.8的ConcurrentHashMap实现有什么不同？</h3><ul>
<li><strong>线程安全实现方式</strong> ：JDK 1.7 采用 <code>Segment</code> 分段锁来保证安全， <code>Segment</code> 是继承自 <code>ReentrantLock</code>。JDK1.8 放弃了 <code>Segment</code> 分段锁的设计，采用 <code>Node + CAS + synchronized</code> 保证线程安全，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点。</li>
<li><strong>Hash 碰撞解决方法</strong> : JDK 1.7 采用拉链法，JDK1.8 采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。</li>
<li><strong>并发度</strong> ：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</li>
</ul>
<h3 id="4-5-ConcurrentHashMap-和-Hashtable-的区别"><a href="#4-5-ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="4.5 ConcurrentHashMap 和 Hashtable 的区别"></a>4.5 ConcurrentHashMap 和 Hashtable 的区别</h3><p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同。</p>
<ul>
<li><strong>底层数据结构：</strong> JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，数组+链表&#x2F;红黑二叉树。<code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li>
<li><strong>实现线程安全的方式（重要）：</strong> ① <strong>在 JDK1.7 的时候，<code>ConcurrentHashMap</code>（分段锁）</strong> 对整个桶数组进行了分割分段(<code>Segment</code>)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 <strong>到了 JDK1.8 的时候已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。（JDK1.6 以后 对 <code>synchronized</code> 锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；总之，**<code>ConcurrentHashMap</code>（分段锁）对于数据进行分段上锁，不是对所有的数据都 上锁，粒度更小。**② <strong><code>Hashtable** :使用 </code>synchronized<code> 来保证线程安全，**每个可能会存在安全问题的方法都用</code>synchronized&#96; 来修饰，</strong>当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。效率非常低下。</li>
</ul>
<h2 id="5-LinkedHashMap"><a href="#5-LinkedHashMap" class="headerlink" title="5. LinkedHashMap"></a>5. LinkedHashMap</h2><p>继承自HashMap，在HashMap的基础上，使用<strong>双向链表</strong>来维护k&#x2F;v对的顺序，顺序与插入顺序一致。</p>
<h2 id="6-TreeMap"><a href="#6-TreeMap" class="headerlink" title="6. TreeMap"></a>6. TreeMap</h2><p>基于<strong>红黑树</strong>实现，映射根据键的自然顺序进行排序，或者根据创建时提供的Comparator进行排序。</p>
<h2 id="7-ArraryList和LinkedList的异同点"><a href="#7-ArraryList和LinkedList的异同点" class="headerlink" title="7. ArraryList和LinkedList的异同点"></a>7. ArraryList和LinkedList的异同点</h2><ul>
<li><strong>是否保证线程安全</strong>： ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li>
<li><strong>底层数据结构</strong>： Arraylist 底层使用的是Object数组；LinkedList 底层使用的是双向循环链表数据结构；</li>
<li><strong>插入和删除是否受元素位置的影响</strong>： ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行 add(E e) 方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话(add(int index, E element))时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位&#x2F;向前移一位的操作。LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似 O(1)而数组为近似 O(n)。</li>
<li><strong>是否支持快速随机访问</strong>： LinkedList 不支持高效的随机元素访问，而ArrayList 实现了RandmoAccess 接口，所以有随机访问功能。快速随机访问就是通过元素的序号快速获取元素对象(对应于 get(int index) 方法)。</li>
<li><strong>内存空间占用</strong>： ArrayList的空间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。</li>
</ul>
<h2 id="8-ArrayList与Vector的区别？"><a href="#8-ArrayList与Vector的区别？" class="headerlink" title="8.ArrayList与Vector的区别？"></a>8.ArrayList与Vector的区别？</h2><ul>
<li>Vector是线程安全的，ArrayList不是线程安全的。其中，Vector在关键性的方法前面都加了synchronized关键字，来保证线程的安全性。如果有多个线程会访问到集合，那最好是使用Vector，因为不需要我们自己再去考虑和编写线程安全的代码。</li>
<li>ArrayList在底层数组不够用时在原来的基础上扩展0.5倍，Vector是扩展1倍，这样ArrayList就有利于节约内存空间。</li>
<li>底层都使用 <code>Object[ ]</code>存储</li>
</ul>
<h2 id="9-Array和ArrayList的区别"><a href="#9-Array和ArrayList的区别" class="headerlink" title="9.Array和ArrayList的区别"></a>9.Array和ArrayList的区别</h2><ul>
<li>Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。</li>
<li>Array 大小是固定的，ArrayList 的大小是动态变化的。</li>
<li>ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator() 等等。</li>
</ul>
<p>ArrayList的扩容机制：</p>
<p>ArrayList扩容的本质就是计算出新的扩容数组的size后实例化，并将原有数组内容复制到新数组中去。默认情况下，新的容量会是<strong>原容量的1.5倍</strong>。</p>
<p>PS：ArrayList的容量上限是<strong>Integer.MAX_VALUE - 8 字节。(8B是用来表示数组大小的)</strong></p>
<h2 id="10-CopyOnWriteArrayList的原理"><a href="#10-CopyOnWriteArrayList的原理" class="headerlink" title="10. CopyOnWriteArrayList的原理"></a>10. CopyOnWriteArrayList的原理</h2><p>是Java并发包的并发类，简单说是一个线程安全且读操作无锁的ArrayList。</p>
<p>在写操作时会复制一份新的List，在新的list上写，然后再将原因用指向新的list。写的时候是上锁的 ，读的是旧的list。</p>
<h2 id="11-TreeSet和HashSet"><a href="#11-TreeSet和HashSet" class="headerlink" title="11. TreeSet和HashSet"></a>11. TreeSet和HashSet</h2><p>都不能重复，都是线程不安全。</p>
<ul>
<li>HashSet底层是HashMap，不保证元素的排列顺序，元素可以是null</li>
<li>TreeSet中底层是采用红黑树，支持自然排序、定制排序，元素不能是null</li>
</ul>
<h2 id="12-BlockingQueue"><a href="#12-BlockingQueue" class="headerlink" title="12. BlockingQueue"></a>12. BlockingQueue</h2><p><strong>阻塞队列。是一个接口。</strong></p>
<p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。 这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。</p>
<ul>
<li><strong>实现类：</strong><ul>
<li>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。</li>
<li>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。 </li>
<li>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。 </li>
<li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。 </li>
<li>SynchronousQueue：一个不存储元素的阻塞队列。（）</li>
<li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。 </li>
<li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。（无界）</li>
</ul>
</li>
</ul>
<p>它们的区别主要体现在存储结构上或对元素操作上的不同，但是对于put与take操作的原理是类似的。</p>
<ul>
<li><strong>原理：</strong></li>
</ul>
<p>下面以ArrayBlockingQueue为例，来说明BlockingQueue的实现原理。</p>
<p><strong>ArrayBlockingQueue</strong>的构造函数，它初始化了put和take函数中用到的关键成员变量，这两个变量的类型分别是ReentrantLock和Condition。ReentrantLock是AbstractQueuedSynchronizer（AQS）的子类，它的newCondition函数返回的Condition实例，是定义在AQS类内部的ConditionObject类，该类可以直接调用AQS相关的函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity, <span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.items = <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull = lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>put函数</strong>会在队列末尾添加元素，如果队列已经满了，无法添加元素的话，就一直阻塞等待到可以加入为止。函数的源码如下所示。我们会发现put函数使用了wait&#x2F;notify的机制。与一般生产者-消费者的实现方式不同，同步队列使用ReentrantLock和Condition相结合的机制，即先获得锁，再等待，而不是synchronized和wait的机制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length) </span><br><span class="line">            notFull.await();</span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>take函数</strong>在队列为空时会被阻塞，一直到阻塞队列加入了新的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) </span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>await操作：</strong></p>
<p>ArrayBlockingQueue并没有使用Object.wait，而是使用的<strong>Condition.await</strong>，这是为什么呢？Condition对象可以提供和Object的wait和notify一样的行为，但是后者必须先获取synchronized这个内置的monitor锁才能调用，而Condition则必须先获取ReentrantLock。这两种方式在阻塞等待时都会将相应的锁释放掉，但是Condition的等待可以中断，这是二者唯一的区别。</p>
<p>我们先来看一下Condition的await函数。<strong>await函数主要有三个步骤</strong>，</p>
<ul>
<li>一是调用addConditionWaiter函数，在condition wait queue队列中添加一个节点，代表当前线程在等待一个消息。</li>
<li>然后调用fullyRelease函数，将持有的锁释放掉，调用的是AQS的函数。</li>
<li>最后一直调用isOnSyncQueue函数判断节点是否被转移到sync queue队列上，也就是AQS中等待获取锁的队列。如果没有，则进入阻塞状态，如果已经在队列上，则调用acquireQueued函数重新获取锁。</li>
</ul>
</li>
</ul>
<img src="/2022/10/05/Java%E9%9B%86%E5%90%88/image-20220504030600266.png" class="" title="await调用流程">

<ul>
<li><p><strong>signal操作：</strong></p>
<p>signal函数将condition wait queue队列中队首的线程节点转移等待获取锁的sync queue队列中。这样的话，await函数中调用isOnSyncQueue函数就会返回true，导致await函数进入最后一步重新获取锁的状态。</p>
<p>我们这里来详细解析一下condition wait queue和sync queue两个队列的设计原理。condition wait queue是等待消息的队列，因为阻塞队列为空而进入阻塞状态的take函数操作就是在等待阻塞队列不为空的消息。而sync queue队列则是等待获取锁的队列，take函数获得了消息，就可以运行了，但是它还必须等待获取锁之后才能真正进行运行状态。</p>
<p>signal函数其实就做了一件事情，就是不断尝试调用transferForSignal函数，将condition wait queue队首的一个节点转移到sync queue队列中，直到转移成功。因为一次转移成功，就代表这个消息被成功通知到了等待消息的节点。</p>
<img src="/2022/10/05/Java%E9%9B%86%E5%90%88/image-20220504030711959.png" class="" title="signal调用流程"></li>
</ul>
<p><strong>扩展阅读</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>抛异常</th>
<th>特定值</th>
<th>阻塞</th>
<th>超时</th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e, time, unit)</td>
</tr>
<tr>
<td>移除</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time, unit)</td>
</tr>
<tr>
<td>检查</td>
<td>element()</td>
<td>peek()</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>四组不同的行为方式含义如下：</strong></p>
<ul>
<li><strong>抛异常</strong>：如果操作无法立即执行，则抛一个异常；</li>
<li><strong>特定值</strong>：如果操作无法立即执行，则返回一个特定的值(一般是 true &#x2F; false)。</li>
<li><strong>阻塞</strong>：如果操作无法立即执行，则该方法调用将会发生阻塞，直到能够执行；</li>
<li><strong>超时</strong>：如果操作无法立即执行，则该方法调用将会发生阻塞，直到能够执行。但等待时间不会超过给定值，并返回一个特定值以告知该操作是否成功(典型的是true &#x2F; false)。</li>
</ul>
<h2 id="13-红黑树"><a href="#13-红黑树" class="headerlink" title="13. 红黑树"></a>13. 红黑树</h2><p><strong>红黑树作为一种平衡树，和AVL相比，在没有损失太多时间复杂度的前提下，大大的简化了实现的难度，通过几个规则的定义保证了最长的路径不超过最短路径的两倍。</strong></p>
<p><strong>红黑树特点</strong> :</p>
<ol>
<li>每个节点非红即黑；</li>
<li>根节点总是黑色的；</li>
<li>每个叶子节点都是黑色的空节点（NIL节点）；</li>
<li>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；</li>
<li>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。</li>
</ol>
<p><strong>红黑树的应用</strong> ：TreeMap、TreeSet以及JDK1.8的HashMap底层都用到了红黑树。</p>
<h2 id="14-集合框架底层数据结构总结"><a href="#14-集合框架底层数据结构总结" class="headerlink" title="14. 集合框架底层数据结构总结"></a>14. <strong>集合框架底层数据结构总结</strong></h2><p>先来看一下 <code>Collection</code> 接口下面的集合。</p>
<h3 id="14-1-List"><a href="#14-1-List" class="headerlink" title="14.1 List"></a>14.1 <strong>List</strong></h3><ul>
<li><code>Arraylist</code>： <code>Object[]</code> 数组</li>
<li><code>Vector</code>：<code>Object[]</code> 数组</li>
<li><code>LinkedList</code>： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li>
</ul>
<h3 id="14-2-Set"><a href="#14-2-Set" class="headerlink" title="14.2 Set"></a>14.2 <strong>Set</strong></h3><ul>
<li><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素</li>
<li><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。有点类似于我们之前说的 <code>LinkedHashMap</code> 其内部是基于 <code>HashMap</code> 实现一样，不过还是有一点点区别的</li>
<li><code>TreeSet</code>(有序，唯一): 红黑树(自平衡的排序二叉树)</li>
</ul>
<h3 id="14-3-Queue"><a href="#14-3-Queue" class="headerlink" title="14.3 Queue"></a>14.3 <strong>Queue</strong></h3><ul>
<li><code>PriorityQueue</code>: <code>Object[]</code> 数组来实现二叉堆</li>
<li><code>ArrayQueue</code>: <code>Object[]</code> 数组 + 双指针</li>
</ul>
<p>再来看看 <code>Map</code> 接口下面的集合。</p>
<h3 id="14-4-Map"><a href="#14-4-Map" class="headerlink" title="14.4 Map"></a>14.4 <strong>Map</strong></h3><ul>
<li><code>HashMap</code>： JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li>
<li><code>LinkedHashMap</code>： <code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：**<a target="_blank" rel="noopener" href="https://www.imooc.com/article/22931">《LinkedHashMap 源码详细分析（JDK1.8）》open in new window</a>**</li>
<li><code>Hashtable</code>： 数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的</li>
<li><code>TreeMap</code>： 红黑树（自平衡的排序二叉树）</li>
</ul>
<h2 id="15-comparable-和-Comparator-的区别"><a href="#15-comparable-和-Comparator-的区别" class="headerlink" title="15. comparable 和 Comparator 的区别"></a>15. <strong>comparable 和 Comparator 的区别</strong></h2><ul>
<li><code>comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</li>
<li><code>comparator</code>接口实际上是出自 java.util 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li>
</ul>
<p>一般我们需要对一个集合使用自定义排序时，我们就要重写<code>compareTo()</code>方法或<code>compare()</code>方法，当我们需要对某一个集合实现两种排序方式，比如一个 song 对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写<code>compareTo()</code>方法和使用自制的<code>Comparator</code>方法或者以两个 Comparator 来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 <code>Collections.sort()</code>.</p>
<h2 id="16-无序性和不可重复性的含义是什么"><a href="#16-无序性和不可重复性的含义是什么" class="headerlink" title="16. 无序性和不可重复性的含义是什么"></a>16. <strong>无序性和不可重复性的含义是什么</strong></h2><p>1、什么是无序性？无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。</p>
<p>2、什么是不可重复性？不可重复性是指添加的元素按照 equals()判断时 ，返回 false，需要同时重写 equals()方法和 HashCode()方法。</p>
<h2 id="17-比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#17-比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="17. 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>17. <strong>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</strong></h2><ul>
<li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li>
<li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li>
<li>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</li>
</ul>
<h2 id="18-Queue"><a href="#18-Queue" class="headerlink" title="18. Queue"></a>18. Queue</h2><h3 id="18-1-Queue-与-Deque-的区别"><a href="#18-1-Queue-与-Deque-的区别" class="headerlink" title="18.1 Queue 与 Deque 的区别"></a><strong>18.1 Queue 与 Deque 的区别</strong></h3><p><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</p>
<p><code>Queue</code> 扩展了 <code>Collection</code> 的接口，根据 <strong>因为容量问题而导致操作失败后处理方式的不同</strong> 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</p>
<img src="/2022/10/05/Java%E9%9B%86%E5%90%88/image-20220504020808146.png" class="">

<p><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素。</p>
<p><code>Deque</code> 扩展了 <code>Queue</code> 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p>
<img src="/2022/10/05/Java%E9%9B%86%E5%90%88/image-20220504020828592.png" class="">

<p>事实上，<code>Deque</code> 还提供有 <code>push()</code> 和 <code>pop()</code> 等其他方法，可用于模拟栈。</p>
<h3 id="18-2-ArrayDeque-与-LinkedList-的区别"><a href="#18-2-ArrayDeque-与-LinkedList-的区别" class="headerlink" title="18..2 ArrayDeque 与 LinkedList 的区别"></a><strong>18..2 ArrayDeque 与 LinkedList 的区别</strong></h3><p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能，但两者有什么区别呢？</p>
<ul>
<li><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</li>
<li><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</li>
<li><code>ArrayDeque</code> 是在 JDK1.6 才被引入的，而<code>LinkedList</code> 早在 JDK1.2 时就已经存在。</li>
<li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li>
</ul>
<p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈。</p>
<h3 id="18-3-PriorityQueue"><a href="#18-3-PriorityQueue" class="headerlink" title="18.3  PriorityQueue"></a>18.3  PriorityQueue</h3><p><code>PriorityQueue</code> 是在 JDK1.5 中被引入的, 其与 <code>Queue</code> 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</p>
<p>这里列举其相关的一些要点：</p>
<ul>
<li><code>PriorityQueue</code> 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</li>
<li><code>PriorityQueue</code> 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</li>
<li><code>PriorityQueue</code> 是非线程安全的，且不支持存储 <code>NULL</code> 和 <code>non-comparable</code> 的对象。</li>
<li><code>PriorityQueue</code> 默认是小顶堆，但可以接收一个 <code>Comparator</code> 作为构造参数，从而来自定义元素优先级的先后。</li>
</ul>
<p><code>PriorityQueue</code> 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第K大的数、带权图的遍历等，所以需要会熟练使用才行</p>
<h2 id="19-DelayQueue"><a href="#19-DelayQueue" class="headerlink" title="19. DelayQueue"></a>19. DelayQueue</h2><ul>
<li><p>DelayQueue是一个无界阻塞的队列，<strong>队列中的每个元素都有一个过期时间</strong>，当要从队列中取出数据时，<strong>只有过期元素才会出队</strong>。</p>
</li>
<li><p>DelayQueue内部使用<strong>PriorityQueue</strong>存放元素，又用<strong>ReentrantLock</strong>实现线程同步。</p>
</li>
<li><p>因为DelayQueue内部要获取元素的剩余时间，所以我们的数据类需要继承<strong>Delayed</strong>接口，Delayed又继承<strong>Comparable</strong>接口，实现<strong>排序</strong>，而自身只有一个**getDelay()**方法，用来获取元素的剩余时间，如果getDelay()返回 &lt;&#x3D;0 的值，则表示这个元素过期，通过take()方法即可取出他，如果没有过期值，则take()会一直阻塞。</p>
</li>
</ul>
<p>（DelayQueue类涉及到TimeUnit，是在java.util.concurrent包下的一个枚举类，可以非常方便实现时间单位的转化。）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DelayQueue的主要成员属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayQueue</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Delayed</span>&gt; <span class="keyword">extends</span> <span class="title class_">AbstractQueue</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">BlockingQueue</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">// 持有内部重入锁。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">// 优先级队列，存放工作任务。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;E&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;E&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Thread</span> <span class="variable">leader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 依赖于重入锁的condition。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">available</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>入队</strong></p>
<p><strong>首先获取独占锁</strong>，<strong>然后添加元素到优先级队列</strong>，由于q是优先级队列，所以添加完元素后，peek()方法返回的并不一定是刚才添加的元素，如果判断为true，说明当前元素e的优先级最小也就是即将过期的，这时候激活avaliable变量条件队列里面的线程，通知它们队列里面有元素了。</p>
</li>
<li><p><strong>从队列中取元素</strong></p>
<p>有两个方法可以取元素（都是取队头），poll()方法取队头当队头元素没过期时返回null，take()方法取队头当队头元素没过期时会一直等待。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">//获取到重入锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        q.offer(e);</span><br><span class="line">        <span class="comment">//添加成功元素</span></span><br><span class="line">        <span class="keyword">if</span> (q.peek() == e) &#123;</span><br><span class="line">            leader = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 将等待队列中的头节点移动到同步队列。</span></span><br><span class="line">            available.signal();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>总结<ul>
<li>DelayQueue是一个内部依靠AQS队列同步器所实现的无界延迟阻塞队列。</li>
<li>延迟对象需要覆盖 getDelay()与compareTo()方法，并且要注意 getDelay()的时间单位的统一，compareTo()根据业务逻辑进行合理的比较逻辑重写。</li>
<li>DelayQueue中内聚的重入锁是非公平的。</li>
<li>DelayQueue是实现定时任务的关键，ScheduledThreadPoolExecutor中就用到了DelayQueue。</li>
</ul>
</li>
</ul>
<h2 id="20-集合的快速失败"><a href="#20-集合的快速失败" class="headerlink" title="20.集合的快速失败"></a>20.集合的快速失败</h2><p>在使用迭代器对集合对象进行遍历的时候，如果 A 线程正在对集合进行遍历，此时 B 线程对集合进行修改（增加、删除、修改），或者 A 线程在遍历过程中对集合进行修改，都会导致 A 线程抛出 ConcurrentModificationException 异常。</p>
<p><strong>快速失败相对于安全失败：</strong></p>
<p>安全失败概念：采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</p>
<p>fail-fast 机制是java集合(Collection)中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2022/10/05/Java%E9%9B%86%E5%90%88/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/" rel="tag">八股文</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2022/10/05/Java%E5%9F%BA%E7%A1%80/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            Java基础
          
        </div>
      </a>
    
    
      <a href="/2022/10/05/Java%E9%9D%A2%E7%BB%8F/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">java</div>
      </a>
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022
        <i class="ri-heart-fill heart_icon"></i> pp-lv
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.png" alt="LPL&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">Categories</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">Tags</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">About</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i></p>
  <div class="reward-box">
    
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>