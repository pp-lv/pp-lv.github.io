<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>设计模式 |  LPL&#39;s Blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-设计模式"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  设计模式
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/10/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2022-10-11T13:40:58.000Z" itemprop="datePublished">2022-10-11</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%85%AB%E8%82%A1%E6%96%87/">八股文</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">7.3k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">25 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="1-手写单例模式"><a href="#1-手写单例模式" class="headerlink" title="1. 手写单例模式"></a>1. 手写单例模式</h2><h3 id="1-饿汉式——静态常量方式（线程安全）"><a href="#1-饿汉式——静态常量方式（线程安全）" class="headerlink" title="1. 饿汉式——静态常量方式（线程安全）"></a>1. 饿汉式——静态常量方式（线程安全）</h3><ul>
<li>类加载时就初始化实例，避免了多线程同步问题。天然线程安全。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>(); <span class="comment">// 静态对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;  <span class="comment">// 私有构造方法保证没办法创建其他对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123; <span class="comment">// 返回唯一的对象</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-饿汉式——静态代码块（线程安全）"><a href="#2-饿汉式——静态代码块（线程安全）" class="headerlink" title="2. 饿汉式——静态代码块（线程安全）"></a>2. 饿汉式——静态代码块（线程安全）</h3><p>其实就是在上面 静态常量饿汉式 实现上稍微变动了一下，将<strong>类的实例化放在了静态代码块中</strong>而已。其他没区别。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">				instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">		<span class="keyword">public</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">				<span class="keyword">return</span> instance;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-懒汉式——线程不安全"><a href="#3-懒汉式——线程不安全" class="headerlink" title="3. 懒汉式——线程不安全"></a>3. 懒汉式——线程不安全</h3><p>这是最基本的实现方式，第一次调用才初始化，实现了<strong>懒加载</strong>的特性。多线程场景下禁止使用，因为可能会产生多个对象，不再是单例。</p>
<ul>
<li>多线程场景下禁止使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;  </span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-懒汉式——线程安全，方法上加同步锁"><a href="#4-懒汉式——线程安全，方法上加同步锁" class="headerlink" title="4. 懒汉式——线程安全，方法上加同步锁"></a>4. 懒汉式——线程安全，方法上加同步锁</h3><p>和上面 懒汉式（线程不安全）实现上唯一不同是：获取实例的getInstance()方法上加了同步锁。保证了多线程场景下的单例。但是效率会有所折损，不过还好。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123; <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-双重校验锁——线程安全、效率高"><a href="#5-双重校验锁——线程安全、效率高" class="headerlink" title="5. 双重校验锁——线程安全、效率高"></a>5. 双重校验锁——线程安全、效率高</h3><p>此种实现中不用每次需要获得锁，减少了获取锁和等待的事件。</p>
<p>注意volatile关键字的使用，保证了各线程对singleton静态实例域修改的可见性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-静态内部类实现单例——线程安全、效率高"><a href="#6-静态内部类实现单例——线程安全、效率高" class="headerlink" title="6. 静态内部类实现单例——线程安全、效率高"></a>6. 静态内部类实现单例——线程安全、效率高</h3><p>这种方式下 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。</p>
<p>注意内部类SingletonHolder要用static修饰且其中的静态变量INSTANCE必须是final的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123; <span class="comment">// 内部类</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123; <span class="comment">// final</span></span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-设计模式的六大原则-总原则（七个）"><a href="#2-设计模式的六大原则-总原则（七个）" class="headerlink" title="2. 设计模式的六大原则+总原则（七个）"></a>2. 设计模式的六大原则+总原则（七个）</h2><p>设计模式是对面向对象的原则的具体实现</p>
<p> <strong>总原则——开闭原则</strong></p>
<blockquote>
<p>一个软件实体，如类、模块和函数应该<strong>对扩展开放，对修改关闭</strong>。</p>
</blockquote>
<p>在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。</p>
<p><strong>1）单一职责原则（Single Responsibility Principle）</strong></p>
<blockquote>
<p>一个类应该只有一个发生变化的原因。</p>
</blockquote>
<p>不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，否则就应该把类拆分。</p>
<p><strong>2）里氏替换原则（Liskov Substitution Principle）</strong></p>
<blockquote>
<p>所有引用基类的地方必须能透明地使用其子类的对象。</p>
</blockquote>
<p><strong>任何基类可以出现的地方，子类一定可以出现。</strong>里氏替换原则是继承复用的基石，只有当衍生类可以替换基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。</p>
<p>里氏代换原则是对“开-闭”原则的补充。实现“开闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏替换原则是对实现抽象化的具体步骤的规范。里氏替换原则中，<strong>子类对父类的方法尽量不要重写和重载</strong>。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。</p>
<p><strong>3）依赖倒置原则（Dependence Inversion Principle）</strong></p>
<blockquote>
<p>1、上层模块不应该依赖底层模块，它们都应该依赖于抽象。<br>2、抽象不应该依赖于细节，细节应该依赖于抽象。</p>
</blockquote>
<p>面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。</p>
<p><strong>4）接口隔离原则（Interface Segregation Principle）</strong></p>
<blockquote>
<p>1、客户端不应该依赖它不需要的接口。<br>2、类间的依赖关系应该建立在最小的接口上。</p>
</blockquote>
<p>每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。</p>
<p><strong>5）迪米特法则（最少知道原则）(Law of Demeter)</strong></p>
<blockquote>
<p>只与你的直接朋友交谈，不跟“陌生人”说话。</p>
</blockquote>
<p>一个类对自己依赖的类知道的越少越好。无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。</p>
<p>最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。</p>
<p><strong>6）合成复用原则（Composite Reuse Principle）</strong></p>
<blockquote>
<p>尽量使用对象组合&#x2F;聚合，而不是继承关系达到软件复用的目的。</p>
</blockquote>
<p>合成或聚合可以将已有对象纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能。</p>
<h2 id="3-设计模式的三大类"><a href="#3-设计模式的三大类" class="headerlink" title="3. 设计模式的三大类"></a>3. 设计模式的三大类</h2><p><strong>创建型模式（Creational Pattern）：</strong>对类的实例化过程进行了抽象，能够将软件模块中<strong>对象的创建</strong>和对象的<strong>使用</strong>分离。</p>
<p>（5种）工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式</p>
<p><strong>结构型模式（Structural Pattern）</strong>：关注于对象的组成以及对象之间的依赖关系，描述如何将类或者对象结合在一起形成更大的结构，就像<strong>搭积木</strong>，可以通过简单积木的组合形成复杂的、功能更为强大的结构。</p>
<p>（7种）适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式</p>
<p><strong>行为型模式（Behavioral Pattern）</strong>：关注于对象的行为问题，是对在不同的对象之间划分责任和算法的抽象化；不仅仅关注类和对象的结构，而且重点关注它们之间的<strong>相互作用</strong>。</p>
<p>（11种）策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式</p>
<h2 id="4-简述23种设计模式"><a href="#4-简述23种设计模式" class="headerlink" title="4. 简述23种设计模式"></a>4. 简述23种设计模式</h2><h3 id="1-创建型模式"><a href="#1-创建型模式" class="headerlink" title="1. 创建型模式"></a>1. 创建型模式</h3><h4 id="1）工厂模式"><a href="#1）工厂模式" class="headerlink" title="1）工厂模式"></a>1）工厂模式</h4><p>在工厂模式中，我们在创建对象时<strong>不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</strong></p>
<p>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p>
<blockquote>
<p>应用实例：您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。而至于需要哪个牌子的汽车，就到哪个牌子的工厂。</p>
</blockquote>
<h4 id="2）抽象工厂模式"><a href="#2）抽象工厂模式" class="headerlink" title="2）抽象工厂模式"></a>2）抽象工厂模式</h4><p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。</p>
<p>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p>
<p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
<blockquote>
<p>应用实例：对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，都是成套的，即一系列具体产品。假设一种情况，在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OO 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。</p>
</blockquote>
<h4 id="3）单例模式"><a href="#3）单例模式" class="headerlink" title="3）单例模式"></a>3）单例模式</h4><p>单例模式（Singleton Pattern）是Java中最简单的设计模式之一。</p>
<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<blockquote>
<p>应用实例：一个班级只能有一个班主任。</p>
</blockquote>
<h4 id="4）建造者模式（构建者模式）"><a href="#4）建造者模式（构建者模式）" class="headerlink" title="4）建造者模式（构建者模式）"></a>4）建造者模式（构建者模式）</h4><p>建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。</p>
<p>一个Builder类会一步一步构造最终的对象。该Builder类是独立于其他对象的。相当于是把各个部件（对象）组合在一起生成一个对象。</p>
<p>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p>
<blockquote>
<p>应用实例：<br>1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的“套餐”；<br>2、Java 中的 StringBuilder。需要往这个对象中加多少内容，自己说了算。</p>
</blockquote>
<h4 id="5）原型模式"><a href="#5）原型模式" class="headerlink" title="5）原型模式"></a>5）原型模式</h4><p>原型模式（Prototype Pattern）是<strong>用于创建重复的对象</strong>，同时又能保证性能。</p>
<p>这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，<strong>一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆</strong>，在需要的时候更新数据库，以此来减少数据库调用。</p>
<p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
<blockquote>
<p>应用实例：<br>1、细胞分裂；<br>2、Java中的 Object clone() 方法。</p>
</blockquote>
<h3 id="2-结构型模式"><a href="#2-结构型模式" class="headerlink" title="2. 结构型模式"></a>2. 结构型模式</h3><h4 id="1）适配器模式"><a href="#1）适配器模式" class="headerlink" title="1）适配器模式"></a>1）适配器模式</h4><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。</p>
<p>这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。</p>
<p>将一个类的接口转换成客户希望的另外一个接口。<strong>适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</strong></p>
<blockquote>
<p>应用实例：<br>1、读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡；<br>2、美国电器110V，中国220V，就要有一个变压器将110V转化为220V。</p>
</blockquote>
<h4 id="2）装饰器模式"><a href="#2）装饰器模式" class="headerlink" title="2）装饰器模式"></a>2）装饰器模式</h4><p><strong>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。</strong></p>
<p>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</p>
<p>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p>
<blockquote>
<p>应用实例：<br>1、孙悟空有72变，当他变成”庙宇”后，他的根本还是一只猴子，但是他又有了庙宇的功能；<br>2、将一个形状装饰上不同的颜色，同时又不改变形状。</p>
</blockquote>
<h4 id="3）代理模式"><a href="#3）代理模式" class="headerlink" title="3）代理模式"></a>3）代理模式</h4><p>在<strong>代理模式（Proxy Pattern）中，一个类代表另一个类的功能</strong>。</p>
<p>在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。</p>
<p>为其他对象提供一种代理以控制对这个对象的访问。</p>
<blockquote>
<p>应用实例：<br>1、Windows里面的快捷方式；<br>2、买火车票不一定在火车站买，也可以去代售点；<br>3、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制；<br>4、Spring AOP。</p>
</blockquote>
<p>注意事项：</p>
<p>1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。</p>
<p>2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</p>
<h4 id="4）外观模式"><a href="#4）外观模式" class="headerlink" title="4）外观模式"></a>4）外观模式</h4><p>外观模式（Facade Pattern）<strong>隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口</strong>。</p>
<p>这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。</p>
<p><strong>为子系统中的一组接口提供一个一致的界面</strong>，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>
<blockquote>
<p>应用实例：<br>去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。</p>
</blockquote>
<h4 id="5）桥接模式桥接模式（Bridge-Pattern）-（最通俗易懂的案例）"><a href="#5）桥接模式桥接模式（Bridge-Pattern）-（最通俗易懂的案例）" class="headerlink" title="5）桥接模式桥接模式（Bridge Pattern）-（最通俗易懂的案例）"></a>5）桥接模式<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39296283/article/details/104953668">桥接模式（Bridge Pattern）-（最通俗易懂的案例）</a></h4><p>桥接模式（Bridge Pattern）是<strong>用于把抽象化与实现化解耦</strong>，使得二者可以独立变化。它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。</p>
<p>这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。</p>
<p><strong>将抽象部分与实现部分分离</strong>，使它们都可以独立的变化。</p>
<p>又称为柄体（Handle and Body）模式或接口（Interface）模式。</p>
<blockquote>
<p>应用实例：<br>1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择；<br>2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的；<br>3、如果要绘制不同的颜色，如红色、绿色、蓝色的矩形、圆形、椭圆、正方形，我们需要根据实际需要对形状和颜色进行组合，那么颜色、形状就是抽象部分，组合后的就是实现部分。</p>
</blockquote>
<p>注意事项：对于两个独立变化的维度，使用桥接模式再适合不过了。</p>
<h4 id="6）组合模式"><a href="#6）组合模式" class="headerlink" title="6）组合模式"></a>6）组合模式</h4><p>组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了<strong>对象组的树形结构</strong>。</p>
<p>这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。</p>
<p>将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<blockquote>
<p>应用实例：<br>1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作数也可以是操作数、操作符和另一个操作数。<br>2、在JAVAAWT和SWING中，对于Button和Checkbox是树叶，Container是树枝。</p>
</blockquote>
<h4 id="7）享元模式"><a href="#7）享元模式" class="headerlink" title="7）享元模式"></a>7）享元模式</h4><p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。</p>
<p>享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。</p>
<p>运用共享技术有效地支持大量细粒度的对象。</p>
<blockquote>
<p>应用实例：<br>1、Java中的String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面；<br>2、数据库的数据池。</p>
</blockquote>
<h3 id="3-行为型模式"><a href="#3-行为型模式" class="headerlink" title="3.行为型模式"></a>3.行为型模式</h3><h4 id="1）策略模式"><a href="#1）策略模式" class="headerlink" title="1）策略模式"></a>1）策略模式</h4><p><strong>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。</strong></p>
<p>在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的context对象。策略对象改变context对象的执行算法。</p>
<p>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。</p>
<blockquote>
<p>应用实例：<br>1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略；<br>2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。</p>
</blockquote>
<h4 id="2）模板模式"><a href="#2）模板模式" class="headerlink" title="2）模板模式"></a>2）模板模式</h4><p>在模板模式（Template Pattern）中，<strong>一个抽象类公开定义了执行它的方法的方式&#x2F;模板。</strong>它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。</p>
<p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<blockquote>
<p>应用实例：<br>1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异；<br>2、西游记里面菩萨定好的81难，这就是一个顶层的逻辑骨架；<br>3、spring中对Hibernate的支持，将一些已经定好的方法封装起来，比如开启事务、获取Session、关闭Session等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。</p>
</blockquote>
<h4 id="3）观察者模式"><a href="#3）观察者模式" class="headerlink" title="3）观察者模式"></a>3）观察者模式</h4><p>当对象间存在一对多关系时，则使用观察者模式（ObserverPattern）。比如，<strong>当一个对象被修改时，则会自动通知它的依赖对象。</strong></p>
<p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
<blockquote>
<p>应用实例：<br>1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价；<br>2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。</p>
</blockquote>
<h4 id="4）迭代器模式"><a href="#4）迭代器模式" class="headerlink" title="4）迭代器模式"></a>4）迭代器模式</h4><p>迭代器模式（Iterator Pattern）是Java和.Net编程环境中非常常用的设计模式。这种模式用于<strong>顺序访问集合对象的元素，不需要知道集合对象的底层表示。</strong></p>
<p>迭代器模式属于行为型模式。</p>
<p>提供一种方法顺序访问一个聚合对象中各个元素，而又无须暴露该对象的内部表示。</p>
<blockquote>
<p>应用实例：JAVA中的iterator。</p>
</blockquote>
<h4 id="5）责任链模式"><a href="#5）责任链模式" class="headerlink" title="5）责任链模式"></a>5）责任链模式</h4><p>顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。</p>
<p>在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。</p>
<p><strong>避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</strong></p>
<blockquote>
<p>应用实例：红楼梦中的”击鼓传花”。</p>
</blockquote>
<h4 id="6）命令模式"><a href="#6）命令模式" class="headerlink" title="6）命令模式"></a>6）命令模式</h4><p>命令模式（Command Pattern）是一种数据驱动的设计模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。</p>
<p>将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。</p>
<blockquote>
<p>应用实例：电视机是请求的接收者，遥控器是请求的发送者，遥控器上有一些按钮，不同的按钮对应电视机的不同操作。抽象命令角色由一个命令接口来扮演，有三个具体的命令类实现了抽象命令接口，这三个具体命令类分别代表三种操作：打开电视机、关闭电视机和切换频道。</p>
</blockquote>
<h4 id="7）备忘录模式"><a href="#7）备忘录模式" class="headerlink" title="7）备忘录模式"></a>7）备忘录模式</h4><p>备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。</p>
<p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p>
<blockquote>
<p>应用实例：<br>1、后悔药；<br>2、打游戏时的存档；<br>3、Windows里的ctri+z；<br>4、IE中的后退；<br>5、数据库的事务管理。</p>
</blockquote>
<h4 id="8）状态模式"><a href="#8）状态模式" class="headerlink" title="8）状态模式"></a>8）状态模式</h4><p>在状态模式（State Pattern）中，<strong>类的行为是基于它的状态改变的。</strong></p>
<p>在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的context对象。</p>
<p>允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。</p>
<blockquote>
<p>应用实例：<br>1、打篮球的时候运动员可以有正常状态、不正常状态和超常状态；<br>2、曾侯乙编钟中，’钟是抽象接口’，’钟A’等是具体状态，’曾侯乙编钟’是具体环境（Context）。</p>
</blockquote>
<h4 id="9）访问者模式"><a href="#9）访问者模式" class="headerlink" title="9）访问者模式"></a>9）访问者模式</h4><p>在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。</p>
<p>主要将数据结构与数据操作分离。</p>
<p>主要解决：稳定的数据结构和易变的操作耦合问题。</p>
<blockquote>
<p>应用实例：您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。</p>
</blockquote>
<h4 id="10）中介者模式"><a href="#10）中介者模式" class="headerlink" title="10）中介者模式"></a>10）中介者模式</h4><p>中介者模式（Mediator Pattern）是用来<strong>降低多个对象和类之间的通信复杂性</strong>。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。</p>
<p>用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p>
<blockquote>
<p>应用实例：<br>1、中国加入WTO之前是各个国家相互贸易，结构复杂，现在是各个国家通过WTO来互相贸易；<br>2、机场调度系统；<br>3、MVC框架，其中C（控制器）就是M（模型）和V（视图）的中介者。</p>
</blockquote>
<h4 id="11）解释器模式"><a href="#11）解释器模式" class="headerlink" title="11）解释器模式"></a>11）解释器模式</h4><p>解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在SQL解析、符号处理引擎等。</p>
<p>给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。</p>
<blockquote>
<p>应用实例：编译器、运算表达式计算。</p>
</blockquote>
<h2 id="5-单例bean的线程安全问题了解吗？"><a href="#5-单例bean的线程安全问题了解吗？" class="headerlink" title="5.单例bean的线程安全问题了解吗？"></a>5.单例bean的线程安全问题了解吗？</h2><p>大部分时候我们并没有在项目中使用多线程，所以很少有人会关注这个问题。单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候是存在资源竞争的。</p>
<p>常见的有两种解决办法：</p>
<ol>
<li>在 bean 中尽量避免定义可变的成员变量。</li>
<li>在类中定义一个 <code>ThreadLocal</code> 成员变量，将需要的可变成员变量保存在 <code>ThreadLocal</code> 中（推荐的一种方式）。</li>
</ol>
<p>不过，大部分 bean 实际都是无状态（没有实例变量）的（比如 Dao、Service），这种情况下， bean 是线程安全的。</p>
<h2 id="6-单例模式中为什么要用双重检测"><a href="#6-单例模式中为什么要用双重检测" class="headerlink" title="6.单例模式中为什么要用双重检测"></a>6.单例模式中为什么要用双重检测</h2><p>第一层 if (instance &#x3D;&#x3D; null)是为了减少线程对同步锁锁的竞争，第二层if(instance&#x3D;&#x3D;nul)是保证单例。即</p>
<p>（1）if (instance &#x3D;&#x3D; null) 的懒汉式多线程下是不安全的；因为没有锁</p>
<p>（2）synchronized&#x2F;lock + if (instance &#x3D;&#x3D; null) 的懒汉式多线程下是安全的；</p>
<p>（3）if (instance &#x3D;&#x3D; null) + synchronized + if (instance &#x3D;&#x3D; null) 的懒汉式在（2）的情况下减少对同步锁的竞争，提高效率。</p>
<p>① synchronized&#x2F;lock + if (instance &#x3D;&#x3D; null) 变为 if (instance &#x3D;&#x3D; null) + synchronized&#x2F;lock，但是这样修改后，第一批进入的线程破坏单例模式。因为多个判断为null，然后实例对象，再进行加锁。</p>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>（1）外层 if (instance &#x3D;&#x3D; null) 保证，除了第一批进入的 t（t&lt;&#x3D;m） 次调用，其他的 n-t 次调用都无法进入，减少对于 synchronized&#x2F;lock 同步锁的竞争，提高效率。</p>
<p>（2）synchronized&#x2F;lock 保证对于第一批进入的 t 次调用，对于同步锁的竞争，只有一个线程可以得到同步锁，其他的 t - 1 个线程都在等待，唯一的线程新建对象的原子性。</p>
<p>（3）内层if(instance &#x3D;&#x3D; null) 保证，第一个获取同步锁进来的线程创建完对象之后，释放同步锁之后，第一批进来的 t-1 线程，即使得到同步锁，也不能再创建对象了，所有对于后面的 t - 1 个线程，它们会一个线程得到同步锁，然后内层 if (instance &#x3D;&#x3D; null) 为false，然后释放同步锁，然后又一个线程得到同步锁，然后内层 if (instance &#x3D;&#x3D; null) 为false，然后释放同步锁，直至 t-1 个都完成。</p>
<h2 id="7-单例模式的应用场景"><a href="#7-单例模式的应用场景" class="headerlink" title="7.单例模式的应用场景"></a>7.单例模式的应用场景</h2><p>为了解决一个全局使用的类频繁地创建与销毁。节省系统资源。</p>
<p>许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。</p>
<p>1.比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。</p>
<p>2.Windows的任务管理器</p>
<p>3.在一个程序中往往都只会使用一个线程池，因此线程池的创建也用单例模式</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2022/10/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/" rel="tag">八股文</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2022/10/11/Redis/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            Redis
          
        </div>
      </a>
    
    
      <a href="/2022/10/10/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">数据库</div>
      </a>
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022
        <i class="ri-heart-fill heart_icon"></i> pp-lv
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.png" alt="LPL&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">Categories</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">Tags</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">About</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i></p>
  <div class="reward-box">
    
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>