<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>JVM |  LPL&#39;s Blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-JVM"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  JVM
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/10/09/JVM/" class="article-date">
  <time datetime="2022-10-09T01:56:42.000Z" itemprop="datePublished">2022-10-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%85%AB%E8%82%A1%E6%96%87/">八股文</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">15.1k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">53 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="0-JVM运行时数据区域"><a href="#0-JVM运行时数据区域" class="headerlink" title="0. JVM运行时数据区域"></a>0. JVM运行时数据区域</h2>

<span id="more"></span>

<p><strong>1. 虚拟机栈</strong> </p>
<ul>
<li>线程私有。</li>
<li>生命周期与线程相同。</li>
<li>为虚拟机执行Java方法服务。</li>
<li><strong>虚拟机栈中执行每个方法的时候，都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用到结束就对应于一个栈桢在虚拟机栈中的入栈和出栈过程。</strong></li>
<li>会出现OOM（内存溢出）。</li>
<li>会有StackOverFlowError（栈溢出)。</li>
</ul>
<p>【注】：局部变量表存放了编译器可知的各种Java虚拟机基本数据类型、对象引用、returnAddress类型。</p>
<p><strong>2. 本地方法栈</strong></p>
<p>本地方法一般由C&#x2F;C++、汇编编写，被编译为基于本机硬件或操作系统的程序。</p>
<ul>
<li>线程私有</li>
<li>与虚拟机栈的作用类似。</li>
<li>为虚拟机使用到的本地方法服务。</li>
<li>会出现OOM。</li>
<li>会有StackOverFlowError。</li>
</ul>
<p><strong>3. Java堆</strong></p>
<ul>
<li>线程共享；</li>
<li>JVM内存中最大的一块；</li>
<li>在虚拟机启动时创建；</li>
<li>唯一目的：存放对象实例（非静态成员变量存在这）；所有的对象实例以及数组都应当在堆上分配；</li>
<li><strong>是GC的主要区域</strong>；通常分为年轻代和老年代；</li>
<li>会有OOM。</li>
<li>不需要连续的内存</li>
</ul>
<p><strong>4. 方法区</strong></p>
<ul>
<li>线程共享；</li>
<li>存储已被虚拟机加载的类型信息（就是<strong>类</strong>）、<strong>常量</strong>、<strong>静态变量</strong>(<strong>static</strong>)、即时编译器编译后的代码缓存等数据。</li>
<li>运行时常量池：是方法区的一部分。Class文件中的常量池表（用于存放编译器生成的各种字面量与符号引用）。这部分内容将在类加载后存放到方法区的运行时常量池中。</li>
<li><strong>JDK1.8开始，方法区被移至元空间，位于本地内存</strong>，元空间存储类的元信息，静态变量和常量池等放入堆中。</li>
</ul>
<p><strong>5.程序计数器</strong></p>
<ul>
<li>线程私有；</li>
<li>记录 正在执行的虚拟机字节码指令的地址；通过改变计数器的值来确定下一条指令；</li>
<li>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地方法，这个计数器值则应为空。</li>
<li><strong>不会出现OOM</strong>。（唯一一个）</li>
</ul>
<p><strong>6. Java中的堆和栈有什么区别？</strong></p>
<ul>
<li><strong>栈</strong>内存主要用来存放基本数据类型与引用变量。</li>
<li><strong>栈</strong>内存的管理是通过压栈和弹栈操作来完成的，以栈帧为基本单位来管理程序的调用关系，每当有函数调用时，都会通过压栈方式创建新的栈帧，每当函数调用结束后都会通过弹栈的方式释放栈帧。</li>
<li><strong>堆</strong>内存用来存放运行时创建的对象。</li>
<li>一般来讲，通过new关键字创建出来的对象都存放在<strong>堆</strong>内存中。由于JVM是基于堆栈的虚拟机，而每个Java程序都运行在一个单独的JVM实例上，每一个实例唯一对应一个堆，一个Java程序内的多个线程也就运行在同一个JVM。</li>
</ul>
<h2 id="1-JVM包含哪几部分？"><a href="#1-JVM包含哪几部分？" class="headerlink" title="1. JVM包含哪几部分？"></a>1. JVM包含哪几部分？</h2><ul>
<li>类加载器</li>
<li>运行时数据区（内存分区）</li>
<li>执行引擎</li>
<li>本地库接口</li>
</ul>
<img src="/2022/10/09/JVM/image-20220504025446361.png" class="">

<h2 id="2-JVM是如何运行的？"><a href="#2-JVM是如何运行的？" class="headerlink" title="2. JVM是如何运行的？"></a>2. JVM是如何运行的？</h2><ul>
<li><ol>
<li>JVM装入运行环境和配置——找jre——自己目录→父级目录→注册中的</li>
</ol>
</li>
<li><ol start="2">
<li>装载JVM</li>
</ol>
</li>
<li><ol start="3">
<li>初始化JVM，获得本地调用接口</li>
</ol>
</li>
<li><ol start="4">
<li>运行Java程序——运行方式：jar和class</li>
</ol>
</li>
</ul>
<h2 id="3-Java程序是怎么运行的？"><a href="#3-Java程序是怎么运行的？" class="headerlink" title="3. Java程序是怎么运行的？"></a>3. Java程序是怎么运行的？</h2><ul>
<li><strong>编译</strong>：写好的源代码文件经过Java编译器编译成字节码文件后，</li>
<li><strong>加载</strong>：通过类加载器加载到内存中，才能被实例化，</li>
<li><strong>解释</strong>：然后到Java虚拟机中解释执行，</li>
<li><strong>执行</strong>：最后通过操作系统CPU执行获取结果。</li>
</ul>
<p>概括来说，写好的 Java 源代码文件经过 Java 编译器编译成字节码文件后，通过类加载器加载到内存中，才能被实例化，然后到 Java 虚拟机中解释执行，最后通过操作系统操作 CPU 执行获取结果。</p>
<img src="/2022/10/09/JVM/image-20220504021408271.png" class="">

<h2 id="4-本地方法栈有什么用？"><a href="#4-本地方法栈有什么用？" class="headerlink" title="4. 本地方法栈有什么用？"></a>4. 本地方法栈有什么用？</h2><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。</p>
<p>《Java虚拟机规范》对本地方法栈中方法使用的语言、使用方式与数据结构并没有任何强制规定，因此具体的虚拟机可以根据需要自由实现它，甚至有的Java虚拟机（譬如Hot-Spot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。</p>
<h2 id="5-没有程序计数器会怎么样？"><a href="#5-没有程序计数器会怎么样？" class="headerlink" title="5. 没有程序计数器会怎么样？"></a>5. 没有程序计数器会怎么样？</h2><p><strong>程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器，即正在执行的指令地址。</strong>在Java虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<p>没有程序计数器，Java程序中的流程控制将无法得到正确的控制，多线程也无法正确的轮换。</p>
<p>由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p>
<p>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。</p>
<h2 id="6-Java代码的编译过程——1个准备过程、3个处理过程"><a href="#6-Java代码的编译过程——1个准备过程、3个处理过程" class="headerlink" title="6. Java代码的编译过程——1个准备过程、3个处理过程"></a>6. Java代码的编译过程——1个准备过程、3个处理过程</h2><p>从Javac代码的总体结构来看，编译过程大致可以分为1个准备过程和3个处理过程，它们分别如下所示。</p>
<ol>
<li><p>准备过程：初始化插入式注解处理器。</p>
</li>
<li><p>解析与填充符号表过程，包括：</p>
<ul>
<li>词法、语法分析，将源代码的字符流转变为标记集合，构造出抽象语法树。</li>
<li>填充符号表，产生符号地址和符号信息。</li>
</ul>
</li>
<li><p>插入式注解处理器的注解处理过程：</p>
<p>在Javac源码中，插入式注解处理器的初始化过程是在initPorcessAnnotations()方法中完成的，而它的执行过程则是在processAnnotations()方法中完成。这个方法会判断是否还有新的注解处理器需要执行，如果有的话，通过JavacProcessing-Environment类的doProcessing()方法来生成一个新的JavaCompiler对象，对编译的后续步骤进行处理。</p>
</li>
<li><p>分析与字节码生成过程，包括：</p>
<ul>
<li>标注检查，对语法的静态信息进行检查。</li>
<li>数据流及控制流分析，对程序动态运行过程进行检查。</li>
<li>解语法糖，将简化代码编写的语法糖还原为原有的形式。</li>
<li>字节码生成，将前面各个步骤所生成的信息转化成字节码。</li>
</ul>
</li>
</ol>
<p>上述3个处理过程里，执行插入式注解时又可能会产生新的符号，如果有新的符号产生，就必须转回到之前的解析、填充符号表的过程中重新处理这些新符号，从总体来看，三者之间的关系与交互顺序如图所示。</p>
<img src="/2022/10/09/JVM/image-20220504021709622.png" class="">

<h2 id="7-类加载过程"><a href="#7-类加载过程" class="headerlink" title="7. 类加载过程"></a>7. 类加载过程</h2>

<p>![Untitled](E:\blog\source_posts\JVM\Untitled 13.png)</p>
<p>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个部分统称为连接（Linking）。</p>
<p><strong>前5个阶段为类加载过程</strong>。</p>
<ul>
<li><p><strong>1.  加载</strong></p>
<ul>
<li>通过一个类的<strong>全限定名</strong>来获取定义此类的<strong>二进制字节流</strong>。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的<strong>运行时数据结构</strong>。</li>
<li>在内存中生成一个代表这个类的<code>java.lang.Class</code> 对象<strong>，作为方法区这个类的各种数据的</strong>访问入口。</li>
<li>加载阶段结束后，Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了，方法区中的数据存储格式完全由虚拟机实现自行定义</li>
</ul>
</li>
<li><p><strong>2.  验证</strong></p>
<ul>
<li>文件格式验证——验证<strong>字节流class</strong>是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。</li>
<li>元数据验证——对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求。</li>
<li>字节码验证——通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。</li>
<li>符号引用验证——可以看作是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。</li>
</ul>
</li>
<li><p><strong>3.准备</strong></p>
<ul>
<li><p>为类变量（即静态变量，被static修饰的变量）分配内存并设置初始值，初始值为0，放进方法区中。</p>
</li>
<li><p>被final修饰的常量，初始为指定的值。</p>
</li>
<li><p>实例变量在此阶段不会分配内存，而是在实例化时（并非类加载阶段），放进堆里。</p>
</li>
<li><p>从概念上讲，这些变量所使用的内存都应当在方法区中进行分配，但必须注意到方法区本身是一个逻辑上的区域，在JDK7及之前，HotSpot使用永久代来实现方法区时，实现是完全符合这种逻辑概念的。而在JDK 8及之后，类变量则会随着Class对象一起存放在Java堆中，这时候“类变量在方法区”就完全是一种对逻辑概念的表述了。</p>
</li>
</ul>
</li>
<li><p><strong>4.  解析</strong>——JVM将<strong>常量池内的符号引用替换为直接引用</strong>的过程</p>
<ul>
<li>PS：<strong>符号引用</strong>（Symbolic References）：**被final修饰的常量，初始为指定的值。(逻辑概念)**，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中。</li>
<li>PS：<strong>直接引用</strong>（Direct References）：<strong>直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。（物理概念）</strong>直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。</li>
</ul>
</li>
<li><p><strong>5.  初始化</strong></p>
<ul>
<li><p>类的初始化阶段是类加载过程的最后一个步骤，之前介绍的几个类加载的动作里，除了在加载阶段用户应用程序可以通过自定义类加载器的方式局部参与外，其余动作都完全由Java虚拟机来主导控制。<strong>直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将主导权移交给应用程序。</strong></p>
</li>
<li><p>进行准备阶段时，变量已经赋过一次系统要求的初始零值，而<strong>在初始化阶段，则会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。</strong>我们也可以从另外一种更直接的形式来表达：<strong>初始化阶段就是执行类构造器&lt;clinit&gt;()方法的过程。</strong>&lt;clinit&gt;()并不是程序员在Java代码中直接编写的方法，它是Javac编译器的自动生成物。</p>
</li>
<li><p><strong>Java程序初始化顺序</strong></p>
<p>1、父类的静态变量<br>2、父类的静态代码块<br>3、子类的静态变量<br>4、子类的静态代码块<br>5、父类的非静态变量<br>6、父类的非静态代码块<br>7、父类的构造方法<br>8、子类的非静态变量<br>9、子类的非静态代码块<br>10、子类的构造方法</p>
</li>
</ul>
</li>
</ul>
<h2 id="8-对象是如何被创建的"><a href="#8-对象是如何被创建的" class="headerlink" title="8. 对象是如何被创建的"></a>8. 对象是如何被创建的</h2><p>在jvm中的加载流程如下所示：</p>
<img src="/2022/10/09/JVM/123.png" class="">

<p><strong>Step1：类加载检查</strong></p>
<p>JVM 虚拟机遇到⼀条 new 指令时，⾸先会检查在常量池中是否可以定位到这个类的符号引⽤（比如 org.simple.Person），并且检查这个符号引⽤代表的类是否已被加载、解析和初始化过。</p>
<p>如果没有，那必须先执⾏相应的类加载过程。</p>
<p>Step2：分配内存</p>
<p>当类加载完成后，就可以确定对象所需的内存大小了。给对象分配内存。</p>
<p>Step3：初始化零值</p>
<p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）。</p>
<p>这⼀步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使⽤，也就是说，程序能访问到这些字段的数据类型所对应的零值。</p>
<p>Step4：设置对象头</p>
<p>初始化零值完成之后，虚拟机要对对象进⾏必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息，这些信息都存放在对象头中。</p>
<p>另外，根据虚拟机当前运⾏状态的不同，如是否启⽤偏向锁等，对象头会有不同的设置⽅式。</p>
<p>Step5：执行 init 方法</p>
<p>此时从虚拟机的视⻆来看，⼀个新的对象已经产⽣了，但从 Java 程序的视⻆来看，对象创建才刚开始， ⽅法还没有执⾏，所有的字段都还为零。</p>
<p>所以⼀般来说，执⾏ new 指令之后会接着执⾏初始化方法，把对象按照程序员的意愿进⾏初始化，这样⼀个真正可⽤的对象才算完全创建成功。</p>
<h2 id="9-元空间和永久代、元空间在栈内还是栈外？"><a href="#9-元空间和永久代、元空间在栈内还是栈外？" class="headerlink" title="9. 元空间和永久代、元空间在栈内还是栈外？"></a>9. 元空间和永久代、元空间在栈内还是栈外？</h2><p>元空间和永久代都是方法区的实现方式，在jdk 1.8中取消了永久代的概念，引入了元空间。</p>
<p>区别：<strong>永久代位于虚拟机栈中</strong>，而<strong>元空间位于本地内存</strong>，存放类的元信息。</p>
<p>为什么取消永久代？</p>
<p>1.永久代的大小不好确定，容易出现OOM，容易触发full gc，元空间位于本地内存，不会满</p>
<p>2.永久代会随着full fc发生移动，增加full gc的复杂度。</p>
<p><strong>元空间在栈外</strong>。元空间占用的是本地内存。</p>
<ul>
<li>注：JDK8之后，用元空间代替了永久代。</li>
</ul>
<h2 id="10-JVM的类加载器？"><a href="#10-JVM的类加载器？" class="headerlink" title="10. JVM的类加载器？"></a>10. JVM的类加载器？</h2><p>JVM设计的时候，把类加载阶段中的“<strong>通过一个类的全限定名来获取描述该类的二进制字节流</strong>”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为“<strong>类加载器</strong>”。</p>
<p>对于任意一个类，都必须由<strong>类加载器和这个类本身</strong>一起共同确立其在Java虚拟机中的唯一性，每一个类加载器都拥有一个独立的类命名空间。</p>
<h2 id="11-类的初始化时机"><a href="#11-类的初始化时机" class="headerlink" title="11.类的初始化时机"></a>11.类的初始化时机</h2><h3 id="11-1-类的主动引用会引起初始化"><a href="#11-1-类的主动引用会引起初始化" class="headerlink" title="11.1 类的主动引用会引起初始化"></a>11.1 类的主动引用会引起初始化</h3><ol>
<li>new一个类的对象</li>
<li>调用类静态变量，和静态方法</li>
<li>对类进行反射调用</li>
<li>启动main方法所在的类</li>
<li>当初始化一个类，如果其父类没有被初始化，则先会初始化他的父类</li>
</ol>
<h3 id="11-2-类的被动引用不会引起初始化"><a href="#11-2-类的被动引用不会引起初始化" class="headerlink" title="11.2 类的被动引用不会引起初始化"></a>11.2 类的被动引用不会引起初始化</h3><ol>
<li>子类调用父类的静态变量，子类不会被初始化，只有父类被初始化。对于静态字段，只有直接定义这个字段的类才会被初始化。</li>
<li>通过数组定义来引用类，不会触发类的初始化</li>
<li>访问类的常量，不会初始化类（常量在编译阶段就存入调用类的常量池中了）</li>
</ol>
<h2 id="12-方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？"><a href="#12-方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？" class="headerlink" title="12.方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？"></a>12.方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</h2><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong> ：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的 <code>ClassLoader</code> 已经被回收。</li>
<li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p>
<h2 id="13-双亲委派机制？"><a href="#13-双亲委派机制？" class="headerlink" title="13. 双亲委派机制？"></a>13. 双亲委派机制？</h2><h3 id="13-1-类加载器"><a href="#13-1-类加载器" class="headerlink" title="13.1 类加载器"></a>13.1 类加载器</h3><ul>
<li><p><strong>启动类加载器（引导类加载器）</strong>：加载存放在<JAVA_HOME>\lib目录，或者指定路径存放的可识别的类库。无法被Java程序直接引用，是用原生代码（C语言）来实现的，并不继承自 java.lang.ClassLoader。</p>
</li>
<li><p><strong>扩展类加载器</strong>：加载<JAVA_HOME>\lib\ext目录或指定路径的所有类库。开发者可以直接在程序中使用扩展类加载器加载Class文件。</p>
</li>
<li><p><strong>应用程序加载器</strong>：加载用户类路径(ClassPath)上所有的类库。开发者可以直接在代码中使用这个类加载器。程序中默认的类加载器。</p>
</li>
<li><p><strong>自定义类加载器</strong><br>（1）开发人员可以通过继承 java.lang.ClassLoader类的方式实现自己的类加载器，以满足一些特殊的需求。</p>
<h4 id="java-class-ClassLoader类"><a href="#java-class-ClassLoader类" class="headerlink" title="java.class.ClassLoader类"></a>java.class.ClassLoader类</h4><p><strong>（1）作用：</strong></p>
<ul>
<li>java.lang.ClassLoader类的基本职责就是根据一个指定的类的名称，找到或者生成其对应的字节代码，然后从这些字节代码中定义出一个Java类，即java.lang.Class类的一个实例。</li>
<li>ClassLoader还负责加载 Java 应用所需的资源，如图像文件和配置文件等</li>
</ul>
<p><strong>（2）常用方法：</strong></p>
<ul>
<li>getParent() 返回该类加载器的父类加载器。</li>
<li>loadClass(String name) 加载名称为 name的类，返回的结果是java.lang.Class类的实例。<br><strong>此方法负责加载指定名字的类，首先会从已加载的类中去寻找，如果没有找到；从parent ClassLoader[ExtClassLoader]中加载；如果没有加载到，则从Bootstrap ClassLoader中尝试加载(findBootstrapClassOrNull方法), 如果还是加载失败，则自己加载。如果还不能加载，则抛出异常ClassNotFoundException。</strong></li>
<li>findClass(String name) 查找名称为 name的类，返回的结果是java.lang.Class类的实例。</li>
<li>findLoadedClass(String name) 查找名称为 name的已经被加载过的类，返回的结果是 java.lang.Class类的实例。</li>
</ul>
</li>
</ul>
<img src="/2022/10/09/JVM/image-20220504025254409.png" class="">

<p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。</p>
<p><strong>双亲委派模型的工作过程</strong>是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求式，子加载器才会尝试自己去完成加载。</p>
<p><strong>好处</strong>：Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系。避免类的重复加载，保证加载的类是同一个。</p>
<p>避免核心类被纂改，通过委派模式，传递到启动类加载器，假如启动类加载器在核心API发现这个名字的类，就不会加载自定义的。</p>
<h3 id="13-2-双亲委派机制被打破的例子"><a href="#13-2-双亲委派机制被打破的例子" class="headerlink" title="13.2 双亲委派机制被打破的例子"></a>13.2 双亲委派机制被打破的例子</h3><ul>
<li><strong>JNDI</strong>通过引入线程上下文类加载器，可以在 Thread.setContextClassLoader 方法设置，默认是应用程序类加载器，来加载 SPI 的代码。有了线程上下文类加载器，就可以完成父类加载器请求子类加载器完成类加载的行为。<strong>打破的原因</strong>，是为了 JNDI 服务的类加载器是启动器类加载，为了完成高级类加载器请求子类加载器（即上文中的线程上下文加载器）加载类。（Java Naming and Directory Interface, Java命名和目录接口）</li>
<li><strong>Tomcat</strong>，应用的类加载器优先自行加载应用目录下的 class，并不是先委派给父加载器，加载不了才委派给父加载器。tomcat之所以造了一堆自己的classloader，大致是出于下面<strong>三类目的</strong>：<ul>
<li>对于各个 webapp 中的 class 和 lib ，需要相互隔离，不能出现一个应用中加载的类库会影响另一个应用的情况，而对于许多应用，需要有共享的lib以便不浪费资源。</li>
<li>与 jvm 一样的安全性问题。使用单独的 classloader 去装载 tomcat 自身的类库，以免其他恶意或无意的破坏；</li>
<li>热部署。</li>
</ul>
</li>
<li><strong>OSGi</strong>，实现模块化热部署，为每个模块都自定义了类加载器，需要更换模块时，模块与类加载器一起更换。其类加载的过程中，有平级的类加载器加载行为。<strong>打破的原因</strong>是为了实现模块热替换。</li>
<li><strong>JDK 9</strong>，Extension ClassLoader 被 Platform ClassLoader 取代，当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。<strong>打破的原因</strong>，是为了添加模块化的特性。</li>
</ul>
<h2 id="14-Java的垃圾回收机制"><a href="#14-Java的垃圾回收机制" class="headerlink" title="14. Java的垃圾回收机制"></a>14. Java的垃圾回收机制</h2><h3 id="14-1-Java的引用类型（判断对象能否被回收）"><a href="#14-1-Java的引用类型（判断对象能否被回收）" class="headerlink" title="14.1 Java的引用类型（判断对象能否被回收）"></a>14.1 Java的引用类型（判断对象能否被回收）</h3><ul>
<li><strong>强引用</strong>：new，在Java中最常见的就是强引用，<strong>把一个对象赋给一个引用变量</strong>，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是<strong>不可能被垃圾回收机制回收的</strong>，即使该对象以后永远都不会被用到JVM也不会回收。因此强引用是造成Java内存泄漏的主要原因之一。</li>
<li><strong>软引用</strong>：软引用需要用SoftReference类来实现，对于只有软引用的对象来说，<strong>当系统内存足够时它不会被回收</strong>，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。</li>
<li><strong>弱引用</strong>：弱引用需要用WeakReference类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，<strong>总会回收该对象占用的内存</strong>。</li>
<li><strong>虚引用</strong>：虚引用需要PhantomReference类来实现，它不能单独使用，必须和引用队列联合使用。虚引用的主要作用是跟踪对象被垃圾回收的状态。</li>
</ul>
<h3 id="14-2-哪些内存需要回收？"><a href="#14-2-哪些内存需要回收？" class="headerlink" title="14.2 哪些内存需要回收？"></a>14.2 哪些内存需要回收？</h3><p>主要关注<strong>堆和方法区</strong>。</p>
<h3 id="14-3-怎么定义垃圾？"><a href="#14-3-怎么定义垃圾？" class="headerlink" title="14.3 怎么定义垃圾？"></a>14.3 怎么定义垃圾？</h3><ul>
<li><p><strong>引用计数法</strong>：在Java中，引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，很显然一个简单的办法是通过引用计数来判断一个对象是否可以回收。简单说，即一个对象如果没有任何与之关联的引用，即他们的引用计数都不为0，则说明对象不太可能再被用到，那么这个对象就是可回收对象。</p>
</li>
<li><p><strong>可达性分析</strong></p>
<p>通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”，如果 某个对象到GC Roots间没有任何引用链相连，则证明此对象是不可能再被使用的。</p>
<ul>
<li>可作为GC Roots的对象：<ul>
<li><strong>虚拟栈</strong>中引用的对象</li>
<li><strong>方法区</strong>中类<strong>静态属性</strong>引用的对象</li>
<li><strong>方法区</strong>中<strong>常量</strong>引用的对象</li>
<li><strong>本地方法栈</strong>中<strong>JNI</strong>引用的对象</li>
<li><strong>JVM内部</strong>的引用</li>
<li>所有被<strong>同步锁</strong>(Synchronized关键字)持有的对象</li>
<li>反应Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>回收方法区</strong>：</p>
<ul>
<li>主要回收<strong>废弃的常量</strong>和<strong>不再使用的类型</strong><ul>
<li>废弃的常量：没有对象引用此常量</li>
<li>不再使用的类型：<ul>
<li>该类所有的实例都已被回收（包括子类的实例）</li>
<li>加载该类的类加载器已被回收</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="14-4-垃圾收集算法"><a href="#14-4-垃圾收集算法" class="headerlink" title="14.4 垃圾收集算法"></a>14.4 垃圾收集算法</h3><ul>
<li><p><strong>分代收集理论</strong>——经验法则</p>
<ul>
<li>弱分代假说：绝大多数对象都是朝生夕灭的</li>
<li>强分代假说：熬过越多次垃圾收集过程的对象越难消亡</li>
</ul>
<p>基于以上两点，收集器应该将Java堆划分出不同的区域，然后将回收对象依据年龄等分配到不同的区域中存储。但是可能会有跨代引用，于是就有了</p>
<ul>
<li>跨代引用假说：跨代引用相对于同代引用来说仅占极少数。</li>
</ul>
<p>只需在新生代上建立一个全局的数据结构（记忆集），这个结构把老年代划分为若干小块，标识出老年代的哪一块内存会存在跨代引用。当发生MinorGC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。</p>
</li>
<li><p><strong>分代收集</strong>——将堆分为新生代和老年代，不同的区域采用不同的回收算法。新生代：标记-复制算法；老年代：标记-清除或者标记-整理算法。</p>
</li>
<li><p><strong>标记-清除</strong>——效率不稳定、空间碎片化。最基础的垃圾回收算法，分为两个阶段，标注和清除。标记阶段标记出所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。</p>
<ul>
<li>分配：顺序查找空间，找到&gt;&#x3D;size的空间，分割空间</li>
<li>不足：效率低，产生时间碎片</li>
</ul>
</li>
<li><p><strong>标记-复制</strong>——为了解决Mark-Sweep算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉。新生代MinorGC使用这个。</p>
<ul>
<li>不足：内存只使用了1&#x2F;2</li>
</ul>
</li>
<li><p><strong>标记-整理</strong>——结合了以上两个算法，为了避免缺陷而提出。标记阶段和Mark-Sweep算法相同，标记后不是清理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。老年代FullGC使用这个。</p>
<ul>
<li>优点：无空间碎片</li>
<li>不足：需要移动，效率低</li>
</ul>
</li>
</ul>
<h2 id="15-新生代、老年代"><a href="#15-新生代、老年代" class="headerlink" title="15.新生代、老年代"></a>15.新生代、老年代</h2><p>垃圾回收时，将堆分为两个区域：新生代、老年代。</p>
<p>年轻代又划分为：1个Eden、2个Survivor（from和to）</p>
<h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>​	是所有新对象产生的地方，当尺寸随堆的大小变化，默认为堆的1&#x2F;15。</p>
<p>​	每次新生代使用1个Eden区和1个Survivor区，新对象先进入Eden，当Eden没有空间时，会触发回收机制，称作Minor GC，经过一次Minor GC，若对象还存在，则放入Survivor区，年龄加1。同时回收时清除正在使用的Survivor区域，将存活对象放入另一个Survivor区，并整理保证空间连续，Survivor中的对象每撑过一轮Minor GC，年龄加1。</p>
<h3 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h3><p>存放年龄大于15的对象。</p>
<p>在老年代触发的GC叫做Major GC，也称为Full GC。Full GC包含新生代的GC。</p>
<h2 id="16-为什么新生代要设置两个Survivor区域？"><a href="#16-为什么新生代要设置两个Survivor区域？" class="headerlink" title="16.为什么新生代要设置两个Survivor区域？"></a>16.为什么新生代要设置两个Survivor区域？</h2><p>解决内存碎片化。</p>
<h2 id="17-为什么老年代不能使用标记复制？"><a href="#17-为什么老年代不能使用标记复制？" class="headerlink" title="17. 为什么老年代不能使用标记复制？"></a>17. 为什么老年代不能使用标记复制？</h2><p>因为老年代保留的对象都是难以消亡的，而标记复制算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。</p>
<h2 id="18-垃圾收集器"><a href="#18-垃圾收集器" class="headerlink" title="18. 垃圾收集器"></a>18. 垃圾收集器</h2><img src="/2022/10/09/JVM/image-20220605030553617.png" class="">

<h3 id="1-Serial收集器"><a href="#1-Serial收集器" class="headerlink" title="1. Serial收集器"></a>1. Serial收集器</h3><ul>
<li><strong>新生代；单线程；复制算法。</strong></li>
</ul>
<p>它的“单线程”的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强调在它进行垃圾收集时，必须<strong>暂停其他所有工作线程</strong>，直到它收集结束。</p>
<img src="/2022/10/09/JVM/image-20220605030735446.png" class="">

<ul>
<li><strong>优点</strong>：简单。对于内存资源受限的环境，它是所有收集器里<strong>额外内存消耗最小</strong>的；对于单核处理器或处理器核心数较少的环境来说，Serial收集器由于<strong>没有线程交互的开销</strong>，专心做垃圾收集自然可以获得最高的单线程收集效率。</li>
<li><strong>缺点</strong>：单线程，stop the world并且时间长。</li>
<li><strong>场景</strong>：对于运行在<strong>客户端</strong>模式下的虚拟机来说是一个很好的选择。</li>
</ul>
<h3 id="2-ParNew收集器"><a href="#2-ParNew收集器" class="headerlink" title="2. ParNew收集器"></a>2. ParNew收集器</h3><ul>
<li><strong>新生代；多线程；复制算法</strong>。</li>
</ul>
<p>实质上是Serial的多线程并行版本。除了同时使用多个线程进行垃圾回收之外，其余的行为与实现都与Serial收集器一样。</p>
<img src="/2022/10/09/JVM/image-20220605031907374.png" class="">

<ul>
<li>默认开启的收集线程数与处理器核心数量相同。</li>
<li>场景：<strong>服务端</strong></li>
</ul>
<h3 id="3-Parallel-Scavenge收集器"><a href="#3-Parallel-Scavenge收集器" class="headerlink" title="3. Parallel Scavenge收集器"></a>3. Parallel Scavenge收集器</h3><ul>
<li><p><strong>新生代；多线程；标记-复制</strong>。</p>
</li>
<li><p>目标是达到一个可控制的吞吐量，所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值。<img src="/2022/10/09/JVM/image-20220605172820260.png" class=""></p>
</li>
<li><p>高吞吐量则可以最高效率地利用处理器资源，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的分析任务。</p>
</li>
</ul>
<h3 id="4-Serial-Old收集器"><a href="#4-Serial-Old收集器" class="headerlink" title="4. Serial Old收集器"></a>4. Serial Old收集器</h3><ul>
<li><strong>老年代；单线程；标记-整理</strong>。</li>
<li>这个收集器的主要意义是供<strong>客户端模式</strong>下的HotSpot虚拟机使用。</li>
<li>如果在<strong>服务端模式</strong>下，它也可能有两种用途：<ul>
<li>一种是在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用；</li>
<li>另外一种就是作为CMS收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用。</li>
</ul>
</li>
</ul>
<img src="/2022/10/09/JVM/image-20220606000647278.png" class="">

<h3 id="5-Parallel-Old收集器"><a href="#5-Parallel-Old收集器" class="headerlink" title="5. Parallel Old收集器"></a>5. Parallel Old收集器</h3><ul>
<li><strong>是Parallel Scavenge的老年代版本；吞吐量优先；多线程；标记-整理</strong>。</li>
</ul>
<img src="/2022/10/09/JVM/image-20220606000835133.png" class="">

<h3 id="6-CMS垃圾回收器"><a href="#6-CMS垃圾回收器" class="headerlink" title="6.CMS垃圾回收器"></a>6.CMS垃圾回收器</h3><ul>
<li>CMS收集器是一种以获取最短回收停顿时间为目标的收集器。</li>
<li><strong>标记-清除</strong></li>
</ul>
<p>CMS的运作过程分为四个步骤：</p>
<ul>
<li><strong>1）初始标记</strong><ul>
<li>仅仅标记一下GC Roots能直接关联到的对象，速度很快。会“Stop The World”。</li>
</ul>
</li>
<li><strong>2）并发标记</strong><ul>
<li>从GCRoots的直接关联开始遍历整个对象图。比较耗时。但是不用停顿其他用户线程，可以与GC线程并发运行。</li>
</ul>
</li>
<li><strong>3）重新标记</strong><ul>
<li>为了修正并发标记期间，因用户程序继续运作而导致标记产A生变动的那一部分对象的标记记录。会“Stop The World”。</li>
<li>耗时比初始标记长，但比并发标记短</li>
</ul>
</li>
<li><strong>4）并发清除</strong><ul>
<li>清理删除标记阶段判断的已经死亡的对象。</li>
<li>并发进行，不需要移动存活对象。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>并发阶段，占用线程，降低总吞吐量</li>
<li>无法处理“<strong>浮动垃圾</strong>”，有可能导致另一次完全“Stop The World”的Full GC产生。——解决：留待下一次垃圾收集时再清理掉。</li>
<li>产生大量<strong>碎片</strong>，不得不触发Full GC——移动整理来消除碎片。</li>
</ul>
</li>
<li>PS：<strong>浮动垃圾</strong>：在CMS的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，<strong>只好留待下一次垃圾收集时再清理掉</strong>。这一部分垃圾就称为“浮动垃圾”。</li>
</ul>
<h3 id="7-G1垃圾收集器"><a href="#7-G1垃圾收集器" class="headerlink" title="7.G1垃圾收集器"></a>7.G1垃圾收集器</h3><p>整体上是标记-整理，局部是基于标记-复制。</p>
<p>G1仍遵循分代收集理论，但G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间、老年代空间。收集器能够对扮演不同角色的Region采用不同的策略区处理。</p>
<p>G1收集器建立了<strong>可预测的停顿时间模型，每次回收的空间都是Region大小的整数倍，这样可以避免在整个Java堆中进行全区域的垃圾回收。</strong></p>
<p><strong>CSET</strong> ：G1收集器出现之前的收集器，垃圾回收的目标范围要么是整个新生代(Minor GC) 或 老年代(Major GC)、要么是整个Java堆(Full GC)。而G1跳出了这个限制，任何部分来组成**回收集(CSet)**进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大。这就是G1收集器的Mixed GC模式。</p>
<p><strong>G1收集器的运作过程：</strong></p>
<ul>
<li><strong>初始标记</strong>：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运作时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，并且是借助运行Minor GC的时候同步完成的，所以G1收集器在这个阶段并没有额外的停顿。</li>
<li><strong>并发标记</strong>：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这个阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。</li>
<li><strong>最终标记</strong>：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后的那少量的SATB记录。</li>
<li><strong>筛选回收</strong>：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来指定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作设计存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。</li>
</ul>
<p><strong>G1中是否还有新生代和老年代的概念</strong></p>
<p>保留新生代和老年代的概念，但是不在进行物理上的隔离。</p>
<p><strong>G1适合的场景</strong></p>
<p>G1适合内存比较大的场景。重新定义堆空间，打破了原有的分代模型，可以回收部分空间，避免了在整个Java堆中进行全域的收集，因此适用于内存较大的场景，因为内存小的话，局部的回收，不足以满足空间的需求。</p>
<h2 id="19-内存分配策略"><a href="#19-内存分配策略" class="headerlink" title="19.内存分配策略"></a>19.内存分配策略</h2><ul>
<li><p>新对象优先在新生代分配</p>
</li>
<li><p>大对象直接进入老年代</p>
</li>
<li><p>年龄大于阈值（15）进入老年代</p>
</li>
<li><p>动态对象年龄判定</p>
<p>Survivor中的相同年龄的所有对象大小总和大于Survivor空间的一半，则年龄大于或等于该年龄的所有对象直接进入老年代。</p>
</li>
</ul>
<h2 id="20-什么时候触发GC，如何减少Full-GC的次数？"><a href="#20-什么时候触发GC，如何减少Full-GC的次数？" class="headerlink" title="20. 什么时候触发GC，如何减少Full GC的次数？"></a>20. 什么时候触发GC，如何减少Full GC的次数？</h2><ul>
<li><p><strong>触发GC</strong></p>
<ol>
<li><p>新生代的Eden区的空间耗尽时，触发Minor GC</p>
</li>
<li><p>调用System.gc()  （不建议）</p>
</li>
<li><p>老年代空间不足</p>
</li>
<li><p>空间分配担保失败</p>
<p><strong>空间分配担保：</strong>Minor GC之前先检查老年代的连续空间是否大于新生代所有对象总空间之和，若成立，则GC安全；否则，查看是否允许空间分配担保失败，若允许，检查老年代空间是否大于历次晋升到老年代的对象总空间的平均大小，如果大于，则进行Minor GC，否则进行Full GC。</p>
</li>
<li><p>JDK1.7之前的永久代空间不足</p>
</li>
<li><p>在CMS等并发收集器中，每隔一段时间检查一下老年代内存的使用量，超过一定比例则进行Full GC回收。</p>
</li>
</ol>
</li>
<li><p><strong>减少Full GC次数的措施</strong></p>
<ul>
<li>增加方法区的空间</li>
<li>增加老年代的空间</li>
<li>减少新生代的空间</li>
<li>禁止使用System.gc()方法</li>
<li>使用标记-整理算法，尽量保持较大的连续内存空间</li>
<li>排查代码中无用的大对象</li>
</ul>
</li>
</ul>
<h2 id="21-JVM一次完整的GC流程？"><a href="#21-JVM一次完整的GC流程？" class="headerlink" title="21. JVM一次完整的GC流程？"></a>21. JVM一次完整的GC流程？</h2><ul>
<li><p>1）新创建的对象会被分配在<strong>新生代</strong>中。</p>
<ul>
<li>新生代按照8：1：1将新生代划分成Eden区、两个Survivor区。</li>
<li>当Eden满之后，<strong>Minor GC就触发</strong>了。</li>
</ul>
</li>
<li><p>2）在Minor GC前，JVM先比较<strong>新生代中对象</strong>和<strong>老年代剩余空间的大小</strong>：</p>
<ul>
<li>如果老年代剩余空间 &gt; 新生代中对象的大小：直接GC。</li>
<li>如果老年代剩余空间 &lt; 新生代中对象的大小：就要看“老年代空间分配担保规则”：<ul>
<li>老年代剩余空间 &gt; 历次MinorGC后剩余对象的大小，进行Minor GC；</li>
<li>老年代剩余空间 &lt; 历次MinorGC后剩余对象的大小，进行<strong>Full GC</strong>，把老年代空出来再检查。</li>
</ul>
</li>
</ul>
</li>
<li><p>3）开启老年代空间担保分配规则只能说是大概率上来说，Minor GC剩余的对象能够放到老年代，但也有可能出现意外：</p>
<p>Minor GC之后的对象：</p>
<ul>
<li>足够放到Survivor区，GC结束；</li>
<li>不够放到Survivor区，接着进入老年代，<ul>
<li>如果老年代能放下，GC结束。</li>
<li>老年代放不下，只能<strong>触发Full GC</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p>4）3种OOM（Out Of Memory）：</p>
<ul>
<li>Full GC之后，老年代仍然放不下剩余对象；</li>
<li>未开启老年代分配担保机制，且第一次Full GC后，老年代仍放不下剩余对象；</li>
<li>开启老年代分配担保，但是担保不通过，一次Full GC后，老年代仍放不下剩余对象。</li>
</ul>
</li>
</ul>
<h2 id="22-触发GC之后，会立刻进行GC吗？"><a href="#22-触发GC之后，会立刻进行GC吗？" class="headerlink" title="22.触发GC之后，会立刻进行GC吗？"></a>22.触发GC之后，会立刻进行GC吗？</h2><p>不会。</p>
<h4 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h4><p>虚拟机为“会长时间执行”的程序设置了<strong>安全点</strong>，这就决定了用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是强制要求必须执行到达安全点之后才能够暂停。</p>
<p>对于安全点，另一个需要考虑的问题就是如何在GC发生时让所有线程（这里不包括执行JNI调用的线程）都“跑”到最近的安全点上再停顿下来。</p>
<p>两种解决方案：</p>
<ul>
<li><p>抢先式中断（Preemptive Suspension）</p>
<p>抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机采用这种方式来暂停线程从而响应GC事件。</p>
</li>
<li><p>主动式中断（Voluntary Suspension）</p>
<p>主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。（即每次到安全点，就去询问当前是否进行GC，是的话，将线程挂起）</p>
</li>
</ul>
<p>但是这种情况下，<strong>程序“不执行”的时候呢？</strong></p>
<p>所谓的程序不执行就是没有分配处理器时间，典型的场景便是用户线程处于Sleep状态或者Blocked状态，这时候线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂起自己，虚拟机也显然不可能持续等待线程重新被激活分配处理器时间。</p>
<h4 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h4><p><strong>安全区域</strong>是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。我们也可以把安全区域看作被扩展拉伸了的安全点。</p>
<p><strong>当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域</strong>，那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的阶段），如果完成了，那线程就当作没事发生过，继续执行；否则它就必须一直等待，直到收到可以离开安全区域的信号为止。</p>
<h2 id="23-Full-GC会导致什么？"><a href="#23-Full-GC会导致什么？" class="headerlink" title="23. Full GC会导致什么？"></a>23. Full GC会导致什么？</h2><p>会 “Stop The World”，即在GC期间全程暂停用户的应用程序。</p>
<h2 id="24-内存泄漏"><a href="#24-内存泄漏" class="headerlink" title="24. 内存泄漏"></a>24. 内存泄漏</h2><ul>
<li>程序运行过程中分配内存给临时变量，用完之后却没有被GC回收，始终占用着内存，既不能被使用也不能分配给其他程序。</li>
<li>原因：长生命周期的对象持有短生命周期对象的引用。</li>
<li>分类——根据发生的方式：<ul>
<li>常发性——内存泄漏的代码多次被执行到，每次执行都泄露</li>
<li>偶发性——特定条件才被执行到</li>
<li>一次性——只会执行一次</li>
<li>隐式——程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。——很长时间才停止运行。</li>
</ul>
</li>
<li>避免：<ul>
<li>尽早释放无用对象的内存</li>
<li>避免在循环中创建对象</li>
<li>使用字符串处理时避免使用String，应使用StringBuffer</li>
<li>尽量少使用静态变量，因为静态变量存放在永久代，基本不参与垃圾回收</li>
</ul>
</li>
</ul>
<h3 id="ThreadLocal-内存泄露问题是怎么导致的？"><a href="#ThreadLocal-内存泄露问题是怎么导致的？" class="headerlink" title="ThreadLocal 内存泄露问题是怎么导致的？"></a>ThreadLocal 内存泄露问题是怎么导致的？</h3><p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</p>
<p>这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。<code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法</p>
<h2 id="25-内存溢出（OOM）"><a href="#25-内存溢出（OOM）" class="headerlink" title="25. 内存溢出（OOM）"></a>25. 内存溢出（OOM）</h2><ul>
<li><p>程序运行过程中申请的内存大于系统能提供的内存。</p>
</li>
<li><p><strong>原因</strong>：</p>
<ul>
<li>内存中加载的数据量过于庞大</li>
<li>集合类中有对对象的引用，使用完后未清空，使得JVM不能回收</li>
<li>代码中存在死循环或循环产生过多重复的对象实体</li>
<li>使用的第三方软件中的bug</li>
<li>启动参数内存值设定的过小</li>
</ul>
</li>
<li><p>最常见的OOM</p>
<ul>
<li>java.lang.OutOfMemoryError: Java heap space ——&gt;<strong>java堆内存溢出</strong>，此种情况最常见，一般由于<strong>内存泄露或者堆的大小设置不当引起</strong>。对于内存泄露，需要通过内存监控软件查找程序中的泄露代码，而堆大小可以通过虚拟机参数-Xms,-Xmx等修改。</li>
<li>java.lang.OutOfMemoryError: PermGen space ——&gt;java<strong>永久代溢出</strong>，即<strong>方法区溢出</strong>了，一般出现于<strong>大量Class或者jsp页面</strong>，或者采用cglib等反射机制的情况，因为上述情况会产生大量的Class信息存储于方法区。此种情况可以通过更改方法区的大小来解决，使用类似-XX:PermSize&#x3D;64m -XX:MaxPermSize&#x3D;256m的形式修改。另外，过多的常量尤其是字符串也会导致方法区溢出。</li>
</ul>
</li>
<li><p>内存溢出的<strong>解决方案</strong>：</p>
<ul>
<li>1）修改JVM启动参数，直接增加内存</li>
<li>2）检查错误日志，查看OOM错误前是否有其他异常或错误</li>
<li>3）对代码进行走查和分析，找到可能发生OOM的位置</li>
<li>4）使用内存查看工具动态查看内存使用情况</li>
</ul>
</li>
<li><p><strong>哪些区域会OOM</strong></p>
<ul>
<li>1）<strong>Java堆</strong><ul>
<li>不断创建对象，并且保证GCRoots到对象之间有可达路径</li>
</ul>
</li>
<li>2）<strong>虚拟机栈</strong>和<strong>本地方法栈</strong></li>
<li>3）<strong>方法区</strong>和<strong>运行时常量池</strong><ul>
<li>方法区溢出原因：经常运行时生成大量动态类的应用场景。</li>
</ul>
</li>
<li>4）<strong>本地直接内存</strong></li>
</ul>
</li>
</ul>
<h2 id="26-栈溢出原因"><a href="#26-栈溢出原因" class="headerlink" title="26. 栈溢出原因"></a>26. 栈溢出原因</h2><ul>
<li>栈是线程私有的，栈的生命周期和线程一样，每个方法在执行的时候就会创建一个栈帧，它包含局部变量表、操作数栈、动态链接、方法出口等信息，局部变量表又包括基本数据类型和对象的引用；</li>
<li>当线程请求的栈深度超过了虚拟机允许的最大深度时，会抛出StackOverFlowError异常，方法递归调用或者死循环可能会出现该问题；</li>
<li>大量循环或死循环</li>
<li>全局变量过多</li>
<li>数组、List、map数据过大</li>
</ul>
<h2 id="27-高耗CPU怎么排查？"><a href="#27-高耗CPU怎么排查？" class="headerlink" title="27. 高耗CPU怎么排查？"></a><strong>27. 高耗CPU怎么排查？</strong></h2><p>使用<strong>top命令</strong>查看目前服务所占cpu情况。</p>
<p>接下来排查系统代码中哪些逻辑导致CPU过高。</p>
<p><strong>第一步：通过ps命令查看这个程序的线程信息</strong>。</p>
<p>​		执行命令：ps -mp [pid]-o THREAD, tid, time</p>
<p>​		属性介绍：tid代表线程ID，time代表这个线程的已运行时间，27291为对应pid的值。</p>
<p><strong>第二步：将TID(代码线程ID)转为16进制</strong></p>
<p>​		因为jvm运行信息都是16进制，所以，这里需要将十进制转为16进制。</p>
<p><strong>第三步：jstack查看进程信息</strong></p>
<ul>
<li><strong>执行命令：jstack[pid] | grep [tid] -A 30</strong></li>
</ul>
<p>​		内容介绍：27291 为pid进程，6d05 为需要查看的线程tid</p>
<p>​		输出信息有较为明显的的代码信息。</p>
<ul>
<li><strong>根据上面输出信息可以很快定位到本地代码存在的问题。</strong></li>
</ul>
<p><strong>PS：容易造成cpu占用过高的情况</strong></p>
<p>1.代码中写死循环时,一直占用cpu</p>
<p>2.如在循环中不停的创建对象,也会导致GC频繁 。</p>
<h2 id="28-JVM调优参数总结"><a href="#28-JVM调优参数总结" class="headerlink" title="28. JVM调优参数总结"></a>28. JVM调优参数总结</h2><p>Xmn、Xms、Xmx、Xss都是JVM对内存的配置参数。</p>
<h3 id="堆内存分配"><a href="#堆内存分配" class="headerlink" title="堆内存分配"></a>堆内存分配</h3><ul>
<li><p>JVM<strong>初始</strong>分配的内存由-Xms指定，默认是物理内存的1&#x2F;64</p>
</li>
<li><p>JVM<strong>最大</strong>分配的内存由-Xmx指定，默认是物理内存的1&#x2F;4</p>
</li>
</ul>
<p>默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制；空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。</p>
<p>因此服务器一般设置-Xms、-Xmx相等以避免在每次GC 后调整堆的大小。对象的堆内存由称为垃圾回收器的自动内存管理系统回收。</p>
<h3 id="堆设置"><a href="#堆设置" class="headerlink" title="堆设置"></a>堆设置</h3><p>-<strong>Xms</strong>:初始堆大小</p>
<p>-<strong>Xmx</strong>:最大堆大小</p>
<p>-<strong>Xmn</strong>:新生代大小</p>
<p>-<strong>XX:NewRatio</strong>：设置<strong>新生代和老年代的比值</strong>。如：为2，表示年轻代与老年代比值为1:2</p>
<p>-XX:SurvivorRatio：新生代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：为3，表示Eden : Survivor&#x3D;3:2，一个Survivor区占整个新生代的1&#x2F;5。</p>
<p>-XX:MaxTenuringThreshold：设置转入老年代的存活次数。如果是0，则直接跳过新生代进入老年代</p>
<p>-XX:PermSize、-XX:MaxPermSize：分别设置永久代最小大小与最大大小（Java8以前）</p>
<p>-XX:MetaspaceSize、-XX:MaxMetaspaceSize：分别设置元空间最小大小与最大大小（Java8以后）</p>
<h3 id="收集器设置"><a href="#收集器设置" class="headerlink" title="收集器设置"></a>收集器设置</h3><p>-XX:+UseSerialGC：设置串行收集器</p>
<p>-XX:+UseParallelGC：设置并行收集器</p>
<p>-XX:+UseParalledlOldGC：设置并行老年代收集器</p>
<p>-XX:+UseConcMarkSweepGC设置并发收集器</p>
<h3 id="垃圾回收统计信息"><a href="#垃圾回收统计信息" class="headerlink" title="垃圾回收统计信息"></a>垃圾回收统计信息</h3><p>-XX:+PrintGC</p>
<p>-XX:+PrintGCDetails</p>
<p>-XX:+PrintGCTimeStamps</p>
<p>-Xloggc:filename</p>
<h3 id="并行收集器设置"><a href="#并行收集器设置" class="headerlink" title="并行收集器设置"></a>并行收集器设置</h3><p>-XX:ParallelGCThreads&#x3D;n:设置并行收集器收集时使用的CPU数。并行收集线程数。</p>
<p>-XX:MaxGCPauseMillis&#x3D;n:设置并行收集最大暂停时间</p>
<p>-XX:GCTimeRatio&#x3D;n:设置垃圾回收时间占程序运行时间的百分比。公式为1&#x2F;(1+n)</p>
<h3 id="并发收集器设置"><a href="#并发收集器设置" class="headerlink" title="并发收集器设置"></a>并发收集器设置</h3><p>-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。</p>
<p>-XX:ParallelGCThreads&#x3D;n:设置并发收集器新生代收集方式为并行收集时，使用的CPU数。并行收集线程数。</p>
<h3 id="非堆内存分配"><a href="#非堆内存分配" class="headerlink" title="非堆内存分配"></a>非堆内存分配</h3><p>JVM使用-XX:PermSize设置非堆内存初始值，默认是物理内存的1&#x2F;64；</p>
<p>由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1&#x2F;4。</p>
<p>-Xss 设置每个线程可使用的内存大小，即栈的大小。在相同物理内存下，减小这个值能生成更多的线程，当然操作系统对一个进程内的线程数还是有限制的，不能无限生成。线程栈的大小是个双刃剑，如果设置过小，可能会出现栈溢出，特别是在该线程内有递归、大的循环时出现溢出的可能性更大，如果该值设置过大，就有影响到创建栈的数量，如果是多线程的应用，就会出现内存溢出的错误。</p>
<h2 id="29-如何查看字节码文件（命令）"><a href="#29-如何查看字节码文件（命令）" class="headerlink" title="29.如何查看字节码文件（命令）"></a>29.如何查看字节码文件（命令）</h2><p><code>javap -verbose XXX.class</code></p>
<h2 id="30-对象的访问定位有哪两种方式"><a href="#30-对象的访问定位有哪两种方式" class="headerlink" title="30.对象的访问定位有哪两种方式?"></a>30.对象的访问定位有哪两种方式?</h2><p>Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有<strong>① 使用句柄</strong>和<strong>② 直接指针</strong>两种：</p>
<p><strong>句柄：</strong> 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；</p>
<p><strong>直接指针：</strong> 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。</p>
<p><strong>各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</strong></p>
<h2 id="31-内存逃逸"><a href="#31-内存逃逸" class="headerlink" title="31.内存逃逸"></a>31.内存逃逸</h2><p>假如一个对象只在当前线程中使用，那么他会优先分配到栈中，不会在堆上进行分配。而内存逃逸就是原本应该被存储在栈上的变量，因为一些原因被存储到了堆上。</p>
<p>JVM的内存分配主要在是运行时数据区(Runtime Data Areas)，而运行时数据区又分为了：方法区，堆区，PC寄存器，Java虚拟机栈(就是栈区，官方文档还是叫Java虚拟机栈)，本地方法区，而内存逃逸主要是对象的动态作用域的改变而引起的，故而内存逃逸的分析就是分析对象的动态作用域。</p>
<p><code>方法逃逸</code>：在一个方法中定义一个对象后(方法内局部的)，这个对象被外部方法引用，比如作为返回值返回传递到其他的地方，当这个方法执行结束要进行GC时，这个方法中的对象本应该被回收，却发现该对象还是存活状态没法回收，就称为<code>方法逃逸</code>：</p>
<p><code>线程逃逸</code>：函数直接将对象返回，该对象可能被外部线程访问，如：赋值给类变量等，称为线程逃逸。总的来说就是一个对象的指针被多个方法或者线程引用时，我们就称这个对象的指针发生了逃逸。</p>
<p><strong>逃逸分析</strong>：即证明一个对象不会逃逸到方法或线程外。</p>
<p><strong>在对象进行内存分配时，进行以下优化</strong></p>
<ul>
<li>栈上分配：</li>
</ul>
<p>说起对象，那你第一个想到的是在堆空间上进行内存分配，GC在堆空间上筛选可回收的对象，回收对象，整理内存都需要浪费时间，若能通过逃逸分析确定某些对象是一定不会逃逸出方法之外的，就可以直接让这个对象在栈上分配内存，该对象随方法的执行结束栈帧出栈而销毁，减轻了GC的压力。</p>
<ul>
<li>同步消除：</li>
</ul>
<p>线程同步本身比较耗时，若确定了一个变量不会逃逸出线程，无法被其他线程访问到，那这个变量的读写就不会存在竞争，这个变量的同步措施就可以清除掉。</p>
<ul>
<li>标量替换：</li>
</ul>
<p><strong>标量</strong>：Java中的原始数据类型(int，char，long等)都不能再进一步分解，他们就可以称为标量。</p>
<p><strong>聚合量</strong>：若一个数据可以继续分解，那就称之为聚合量，而对象就是典型的聚合量，因为他可以分解成其他聚合量和标量。</p>
<p>若逃逸分析证明一个对象不会逃逸出方法，不会被外部访问，并且这个对象是可以被分解的，那程序在真正执行的时候可能不创建这个对象，而是直接创建这个对象分解后的标量来代替。这样就无需在堆上给对象分配空间了，只在栈上为分解出的变量分配内存即可。</p>
<h2 id="32-内存屏障"><a href="#32-内存屏障" class="headerlink" title="32.内存屏障"></a>32.内存屏障</h2><ul>
<li>硬件层的内存屏障分为两种：<code>Load Barrier</code> 和 <code>Store Barrier</code>即读屏障和写屏障。</li>
<li>内存屏障有两个作用：</li>
</ul>
<blockquote>
<ol>
<li>阻止屏障两侧的指令重排序；</li>
<li>强制把写缓冲区&#x2F;高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。</li>
</ol>
</blockquote>
<ul>
<li>对于Load Barrier来说，在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制从新从主内存加载数据；</li>
<li>对于Store Barrier来说，在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。</li>
</ul>
<hr>
<h3 id="java内存屏障"><a href="#java内存屏障" class="headerlink" title="java内存屏障"></a>java内存屏障</h3><ul>
<li>java的内存屏障通常所谓的四种即<code>LoadLoad</code>,<code>StoreStore</code>,<code>LoadStore</code>,<code>StoreLoad</code>实际上也是上述两种的组合，完成一系列的屏障和数据同步功能。</li>
<li>LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li>
<li>StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li>
<li>LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li>
<li>StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。<strong>它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能</strong></li>
</ul>
<hr>
<h3 id="volatile语义中的内存屏障"><a href="#volatile语义中的内存屏障" class="headerlink" title="volatile语义中的内存屏障"></a>volatile语义中的内存屏障</h3><ul>
<li>volatile的内存屏障策略非常严格保守，非常悲观且毫无安全感的心态：</li>
</ul>
<blockquote>
<p>在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障；<br>在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障；</p>
</blockquote>
<ul>
<li>由于内存屏障的作用，避免了volatile变量和其它指令重排序、线程之间实现了通信，使得volatile表现出了锁的特性。</li>
</ul>
<h3 id="final语义中的内存屏障"><a href="#final语义中的内存屏障" class="headerlink" title="final语义中的内存屏障"></a>final语义中的内存屏障</h3><ul>
<li>对于final域，编译器和CPU会遵循两个排序规则：</li>
</ul>
<blockquote>
<ol>
<li>新建对象过程中，构造体中对final域的初始化写入和这个对象赋值给其他引用变量，这两个操作不能重排序；（废话嘛）</li>
<li>初次读包含final域的对象引用和读取这个final域，这两个操作不能重排序；（晦涩，意思就是先赋值引用，再调用final值）</li>
</ol>
</blockquote>
<ul>
<li>总之上面规则的意思可以这样理解，必需保证一个对象的所有final域被写入完毕后才能引用和读取。这也是内存屏障的起的作用：</li>
<li>写final域：在编译器写final域完毕，构造体结束之前，会插入一个StoreStore屏障，保证前面的对final写入对其他线程&#x2F;CPU可见，并阻止重排序。</li>
<li>读final域：在上述规则2中，两步操作不能重排序的机理就是在读final域前插入了LoadLoad屏障。</li>
<li>X86处理器中，由于CPU不会对写-写操作进行重排序，所以StoreStore屏障会被省略；而X86也不会对逻辑上有先后依赖关系的操作进行重排序，所以LoadLoad也会变省略。</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2022/10/09/JVM/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
    
      <a href="/2022/10/09/Shell/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Shell</div>
      </a>
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022
        <i class="ri-heart-fill heart_icon"></i> pp-lv
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.png" alt="LPL&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">Categories</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">Tags</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">About</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i></p>
  <div class="reward-box">
    
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>