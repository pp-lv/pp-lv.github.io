<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>并发编程 |  LPL&#39;s Blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-并发编程"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  并发编程
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/10/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="article-date">
  <time datetime="2022-10-07T13:29:40.000Z" itemprop="datePublished">2022-10-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%85%AB%E8%82%A1%E6%96%87/">八股文</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">13.5k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">48 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="1-并发编程的三个特性"><a href="#1-并发编程的三个特性" class="headerlink" title="1.并发编程的三个特性"></a>1.并发编程的三个特性</h2><p><strong>原子性</strong>：一个操作或者多个操作，要么全部执行成功，要么全部执行失败。满足原子性的操作，中途不可被中断</p>
<p><strong>有序性</strong>：程序执行的顺序按照代码的先后顺序执行。</p>
<p><strong>可见性</strong>：多个线程共同访问共享变量时，某个线程修改了此变量，其他线程能立即看到修改后的值。</p>
<h2 id="2-Java内存模型（JMM）"><a href="#2-Java内存模型（JMM）" class="headerlink" title="2.Java内存模型（JMM）"></a>2.Java内存模型（JMM）</h2><h3 id="2-1-JMM是什么"><a href="#2-1-JMM是什么" class="headerlink" title="2.1 JMM是什么"></a>2.1 JMM是什么</h3><p><strong>JMM 看作是 Java 定义的并发编程相关的一组规范</strong>，用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果，JMM规范了Java虚拟机与计算机内存是如何协同工作的。<strong>定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的细节</strong>。其主要目的是为了简化多线程编程，增强程序可移植性的。例如：规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。</p>
<p>在当前的 Java 内存模型下，线程可以把变量保存在 <strong>工作内存</strong> （比如机器的寄存器）中，而不是直接在主存中进行读写。</p>
<p><strong>什么是主内存？什么是工作内存？</strong></p>
<ul>
<li><strong>主内存</strong> ：所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)</li>
<li><strong>工作内存（本地内存）</strong> ：每个线程都有一个私有的本地内存来存储共享变量的副本，并且，每个线程只能访问自己的本地内存，无法访问其他线程的本地内存。本地内存是 JMM 抽象出来的一个概念，存储了主内存中的共享变量副本。</li>
</ul>
<p>Java 内存模型的抽象示意图如下：</p>
<img src="/2022/10/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/jmm.png" class="" title="内存模型">

<h3 id="2-2-为什么要有Java内存模型"><a href="#2-2-为什么要有Java内存模型" class="headerlink" title="2.2 为什么要有Java内存模型"></a>2.2 为什么要有Java内存模型</h3><p>在当前的硬件内存模型下，运行多线程会存在一些问题。（如下）1.而Java 语言是跨平台的，它需要自己提供一套内存模型以屏蔽系统差异。2.JMM 定义了一些规范来解决这些问题，开发发者可以利用这些规范更方便地开发多线程程序。不需要了解底层原理，直接使用并发相关的一些关键字和类即可。</p>
<h4 id="缓存一致性问题："><a href="#缓存一致性问题：" class="headerlink" title="缓存一致性问题："></a><strong>缓存一致性问题</strong>：</h4><p>在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（MainMemory）。基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也引入了新的问题：缓存一致性（CacheCoherence）。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致的情况。CPU 为了解决内存缓存不一致性问题可以通过制定缓存一致协议（比如 MESI 协议open in new window）或者其他手段来解决。 操作系统通过 <strong>内存模型（Memory Model）</strong> 定义一系列规范来解决这个问题。无论是 Windows 系统，还是 Linux 系统，它们都有特定的内存模型。</p>
<h4 id="指令重排序问题："><a href="#指令重排序问题：" class="headerlink" title="指令重排序问题："></a><strong>指令重排序问题</strong>：</h4><p>为了提升执行速度&#x2F;性能，计算机在执行程序代码的时候，会对指令进行重排序。</p>
<p><strong>什么是指令重排序？</strong> 简单来说就是系统在执行代码的时候并不一定是按照你写的代码的顺序依次执行。</p>
<p>常见的指令重排序有下面 2 种情况：</p>
<ul>
<li><strong>编译器优化重排</strong> ：编译器（包括 JVM、JIT 编译器等）在不改变单线程程序语义的前提下，重新安排语句的执行顺序。</li>
<li><strong>指令并行重排</strong> ：现代处理器采用了指令级并行技术(Instruction-Level Parallelism，ILP)来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
</ul>
<p>另外，内存系统也会有“重排序”，但有不是真正意义上的重排序。在 JMM 里表现为主存和本地内存的内容可能不一致，进而导致程序在多线程下执行可能出现问题。</p>
<p>Java 源代码会经历 <strong>编译器优化重排 —&gt; 指令并行重排 —&gt; 内存系统重排</strong> 的过程，最终才变成操作系统可执行的指令序列。</p>
<p><strong>指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong> ，所以在多线程下，指令重排序可能会导致一些问题。</p>
<p>编译器和处理器的指令重排序的处理方式不一样。对于编译器，通过禁止特定类型的编译器的方式来禁止重排序。对于处理器，通过插入内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）的方式来禁止特定类型的处理器重排序。指令并行重排和内存系统重排都属于是处理器级别的指令重排序。</p>
<h3 id="2-3-Java内存区域和-JMM-有何区别？"><a href="#2-3-Java内存区域和-JMM-有何区别？" class="headerlink" title="2.3 Java内存区域和 JMM 有何区别？"></a>2.3 Java内存区域和 JMM 有何区别？</h3><p> <strong>Java 内存区域和内存模型是完全不一样的两个东西</strong> ：</p>
<ul>
<li>JVM 内存结构和 Java 虚拟机的运行时区域相关，定义了 JVM 在运行时如何分区存储程序数据，就比如说堆主要用于存放对象实例。</li>
<li>Java 内存模型和 Java 的并发编程相关，抽象了线程和主内存之间的关系就比如说线程之间的共享变量必须存储在主内存中，规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。</li>
</ul>
<h2 id="3-i-是线程安全的吗？"><a href="#3-i-是线程安全的吗？" class="headerlink" title="3. i++是线程安全的吗？"></a>3. i++是线程安全的吗？</h2><p><strong>i++是不安全的</strong></p>
<p><strong>i++是一个复合操作，可分为三个阶段：</strong></p>
<ul>
<li>读值，从内存到寄存器</li>
<li>+1，寄存器自增</li>
<li>写值，写回内存</li>
</ul>
<p>在这三步之间的都可能会有CPU调度，造成i的值被修改。造成脏读脏写。</p>
<p><strong>如果是方法里定义的，一定是线程安全的，方法中的变量放在栈中，是线程私有的；</strong></p>
<p><strong>如果是类的静态成员变量，i++则不是线程安全的，因为类的变量放在堆中，堆是共享的</strong></p>
<p><strong>如何解决线程安全性呢？</strong></p>
<ul>
<li>可以使用原子变量（AtomicInteger，参考 Java并发编程之原子变量）</li>
<li>sychronized关键字、Lock锁实现（参考 Java关键字 volatile、synchronized和Lock锁）。</li>
</ul>
<p>AtomicInteger 和 各种 Lock 都可以确保线程安全。AtomicInteger 的效率高是因为它是互斥区非常小，只有一条指令，而 Lock 的互斥区是拿锁到放锁之间的区域，至少三条指令。</p>
<h2 id="4-创建线程的四种方式"><a href="#4-创建线程的四种方式" class="headerlink" title="4.创建线程的四种方式"></a>4.创建线程的四种方式</h2><p>Java使用Thread类代表线程，所有的线程对象都必须是Thread类或其子类的实例。Java可以用四种方式来创建线程，如下所示：</p>
<p>1）继承Thread类创建线程</p>
<p>2）实现Runnable接口创建线程</p>
<p>3）使用Callable和Future创建线程</p>
<p>4）使用线程池例如用Executor框架</p>
<h3 id="4-1-继承Thread类创建线程"><a href="#4-1-继承Thread类创建线程" class="headerlink" title="4.1 继承Thread类创建线程"></a>4.1 继承Thread类创建线程</h3><p>通过继承Thread类来创建并启动多线程的一般步骤如下</p>
<p>1、定义Thread类的子类，并重写该类的run()方法，该方法的方法体就是线程需要完成的任务，run()方法也称为线程执行体。</p>
<p>2、创建Thread子类的实例，也就是创建了线程对象</p>
<p>3、启动线程，即调用线程的start()方法</p>
<p>代码实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;<span class="comment">//继承Thread类</span></span><br><span class="line"></span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="comment">//重写run方法</span></span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">new</span> <span class="title class_">MyThread</span>().start();<span class="comment">//创建并启动线程</span></span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-实现Runnable接口创建线程"><a href="#4-2-实现Runnable接口创建线程" class="headerlink" title="4.2 实现Runnable接口创建线程"></a>4.2 实现Runnable接口创建线程</h3><p>通过实现Runnable接口创建并启动线程一般步骤如下：</p>
<p>1、定义Runnable接口的实现类，一样要重写run()方法，这个run()方法和Thread中的run()方法一样是线程的执行体</p>
<p>2、创建Runnable实现类的实例，并用这个实例作为Thread的target来创建Thread对象，这个Thread对象才是真正的线程对象</p>
<p>3、第三步依然是通过调用线程对象的start()方法来启动线程</p>
<p>代码实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;<span class="comment">//实现Runnable接口</span></span><br><span class="line"></span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;undefined</span><br><span class="line"></span><br><span class="line">　　<span class="comment">//重写run方法</span></span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">　　　　<span class="comment">//创建并启动线程</span></span><br><span class="line"></span><br><span class="line">　　　　MyThread2 myThread=<span class="keyword">new</span> <span class="title class_">MyThread2</span>();</span><br><span class="line"></span><br><span class="line">　　　　Thread thread=<span class="keyword">new</span> <span class="title class_">Thread</span>(myThread);</span><br><span class="line"></span><br><span class="line">　　　　thread().start();</span><br><span class="line"></span><br><span class="line">　　　　<span class="comment">//或者    new Thread(new MyThread2()).start();</span></span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-使用Callable和Future创建线程"><a href="#4-3-使用Callable和Future创建线程" class="headerlink" title="4.3 使用Callable和Future创建线程"></a>4.3 使用Callable和Future创建线程</h3><p>和Runnable接口不一样，Callable接口提供了一个call()方法作为线程执行体，call()方法比run()方法功能要强大。</p>
<ul>
<li>call()方法可以有返回值</li>
<li>call()方法可以声明抛出异常</li>
</ul>
<p>Java5提供了Future接口来代表Callable接口里call()方法的返回值，并且为Future接口提供了一个实现类FutureTask，这个实现类既实现了Future接口，还实现了Runnable接口，因此可以作为Thread类的target。在Future接口里定义了几个公共方法来控制它关联的Callable任务。</p>
<blockquote>
<p>boolean cancel(boolean mayInterruptIfRunning)：视图取消该Future里面关联的Callable任务</p>
</blockquote>
<blockquote>
<p>V get()：返回Callable里call（）方法的返回值，调用这个方法会导致程序阻塞，必须等到子线程结束后才会得到返回值</p>
</blockquote>
<blockquote>
<p>V get(long timeout,TimeUnit unit)：返回Callable里call（）方法的返回值，最多阻塞timeout时间，经过指定时间没有返回抛出TimeoutException</p>
</blockquote>
<blockquote>
<p>boolean isDone()：若Callable任务完成，返回True</p>
</blockquote>
<blockquote>
<p>boolean isCancelled()：如果在Callable任务正常完成前被取消，返回True</p>
</blockquote>
<p>创建并启动有返回值的线程的步骤如下：</p>
<p>1、创建Callable接口的实现类，并实现call()方法，然后创建该实现类的实例（从java8开始可以直接使用Lambda表达式创建Callable对象）。</p>
<p>2、使用FutureTask类来包装Callable对象，该FutureTask对象封装了Callable对象的call()方法的返回值</p>
<p>3、使用FutureTask对象作为Thread对象的target，创建并启动线程（因为FutureTask实现了Runnable接口）</p>
<p>4、调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread3</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">　　　MyThread3 th=<span class="keyword">new</span> <span class="title class_">MyThread3</span>();</span><br><span class="line"></span><br><span class="line">　　　<span class="comment">//也可以直接使用Lambda表达式创建Callable对象</span></span><br><span class="line"></span><br><span class="line">　　   <span class="comment">//使用FutureTask类来包装Callable对象</span></span><br><span class="line"></span><br><span class="line">　　　FutureTask&lt;Integer&gt; future=<span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Integer&gt;(</span><br><span class="line"></span><br><span class="line">　　　　(Callable&lt;Integer&gt;)()-&gt;&#123;</span><br><span class="line">　　　　　　<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　  );</span><br><span class="line"></span><br><span class="line">　　　<span class="keyword">new</span> <span class="title class_">Thread</span>(future,<span class="string">&quot;有返回值的线程&quot;</span>).start();<span class="comment">//实质上还是以Callable对象来创建并启动线程</span></span><br><span class="line"></span><br><span class="line">　　  <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">　　　　System.out.println(<span class="string">&quot;子线程的返回值：&quot;</span>+future.get());<span class="comment">//get()方法会阻塞，直到子线程执行结束才返回</span></span><br><span class="line"></span><br><span class="line"> 　　 &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">　　　　ex.printStackTrace();</span><br><span class="line"></span><br><span class="line">　　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-使用线程池，例如用Executor框架"><a href="#4-4-使用线程池，例如用Executor框架" class="headerlink" title="4.4 使用线程池，例如用Executor框架"></a>4.4 使用线程池，例如用Executor框架</h3><p>创建的几种方式：</p>
<p><strong>方式一：通过<code>ThreadPoolExecutor</code>构造函数实现（推荐）</strong></p>
<p><strong>方式二：通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来实现</strong> </p>
<p>Executors提供的四种线程池：</p>
<p><code>newFixedThreadPool</code> 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p>
<p><code>newSingleThreadExecutor</code> 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p>
<p><code>newCachedThreadPool</code> 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p>
<p><code>newScheduledThreadPoolExecutor</code>创建一个线程池，支持定时及周期性任务执行</p>
<p><strong>Tips</strong>：《阿里巴巴 Java 开发手册》中强制线程池不允许使用 <code>Executors</code> 去创建，而是通过 <code>ThreadPoolExecutor</code> 构造函数的方式。</p>
<p><code>Executors</code> 返回线程池对象的弊端如下：</p>
<ul>
<li><strong><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code></strong> ： 允许请求的队列长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>
<li><strong><code>CachedThreadPool</code> 和 <code>ScheduledThreadPool</code></strong> ： 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 OOM。</li>
</ul>
<h2 id="5-算法题"><a href="#5-算法题" class="headerlink" title="5.算法题"></a>5.算法题</h2><h3 id="Java实现两个线程交替打印1-100"><a href="#Java实现两个线程交替打印1-100" class="headerlink" title="Java实现两个线程交替打印1-100"></a>Java实现两个线程交替打印1-100</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">/*指代的为TestThread,因为使用的是implements方式。若使用继承Thread类的方式，慎用this*/</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="comment">/*唤醒另外一个线程，注意是this的方法，而不是Thread*/</span></span><br><span class="line">                notify();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">/*使其休眠100毫秒，放大线程差异*/</span></span><br><span class="line">                    Thread.currentThread();<span class="comment">//此句可以省略</span></span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">                    i++;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">/*放弃资源，等待*/</span></span><br><span class="line">                        wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*只有一个TestThread对象*/</span></span><br><span class="line">        <span class="type">TestThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestThread</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-run-和start-有什么区别？"><a href="#6-run-和start-有什么区别？" class="headerlink" title="6.run()和start()有什么区别？"></a>6.run()和start()有什么区别？</h2><ul>
<li><strong>run</strong>()：线程执行体，方法体代表线程需要完成的任务。run()会理解被执行，在它结束之前无法并发（就是当成了普通对象执行）</li>
<li><strong>start</strong>()：用来启动线程。系统会把run()当成线程执行体来处理。</li>
</ul>
<p>【注】线程不可以重复调用start()方法，否则会引发IllegalThreadDtateException异常。</p>
<p>​			若直接调用run()，则不会通过线程去执行。</p>
<h2 id="7-sleep-和wait"><a href="#7-sleep-和wait" class="headerlink" title="7.sleep()和wait()"></a>7.sleep()和wait()</h2><ul>
<li>sleep()：1.Thread类的静态方法，2.可用在任何地方，3.释放CPU执行权，不释放锁，4.必须指定时间。</li>
<li>wait()：1.Object类中的成员方法，2.只能在同步方法或同步代码块中使用，3.释放CPU执行权，释放锁，然后进入对象的等待池，只有通过notify()&#x2F;notifyAll()才能唤醒进入等锁池（lock pool）重新获得锁。4.wait可以指定时间，也可以不指定。指定时间时，在时间内不会被notifyAll函数唤醒。</li>
</ul>
<h2 id="8-什么是-Callable-和-Future"><a href="#8-什么是-Callable-和-Future" class="headerlink" title="8.什么是 Callable 和 Future?"></a>8.什么是 Callable 和 Future?</h2><ul>
<li><strong>Callable 接口</strong>类似于 Runnable，但是 Runnable 不会返回结果，并且无法抛出返回结果的异常，而 Callable 功能更强大一些，被线程执行后，可以返回值，这个返回值可以被 Future 拿到，也就是说，Future 可以拿到 异步执行任务的返回值。 可以认为是带有回调的 Runnable。</li>
<li><strong>Future 接口</strong>表示异步任务，是还没有完成的任务给出的未来结果。所以说 Callable 用于产生结果，Future 用于获取结果。</li>
</ul>
<h2 id="9-Java中线程同步的方法（五种）"><a href="#9-Java中线程同步的方法（五种）" class="headerlink" title="9.Java中线程同步的方法（五种）"></a>9.Java中线程同步的方法（五种）</h2><h3 id="9-1-同步方法"><a href="#9-1-同步方法" class="headerlink" title="9.1 同步方法"></a>9.1 同步方法</h3><p>即有synchronized关键字修饰的方法。 由于java的每个对象都有一个内置锁，当用此关键字修饰方法时， 内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。</p>
<h3 id="9-2-同步代码块"><a href="#9-2-同步代码块" class="headerlink" title="9.2 同步代码块"></a>9.2 同步代码块</h3><p>　　即有synchronized关键字修饰的语句块。 被该关键字修饰的语句块会自动被加上内置锁，从而实现同步。</p>
<p>  代码如： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">synchronized(object)&#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-3-使用特殊域变量-volatile-实现线程同步"><a href="#9-3-使用特殊域变量-volatile-实现线程同步" class="headerlink" title="9.3 使用特殊域变量(volatile)实现线程同步"></a>9.3 使用特殊域变量(volatile)实现线程同步</h3><p>1.volatile关键字为域变量的访问提供了一种免锁机制，属于轻量级同步策略</p>
<p>2.使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新，</p>
<p>3.因此每次使用该域就要重新计算，而不是使用寄存器中的值 </p>
<p>4.volatile不会提供任何原子操作，它也不能用来修饰final类型的变量 ，保证可见性和禁止指令重排</p>
<h3 id="9-4-使用重入锁实现线程同步"><a href="#9-4-使用重入锁实现线程同步" class="headerlink" title="9.4 使用重入锁实现线程同步"></a>9.4 使用重入锁实现线程同步</h3><p>ReentrantLock类是可重入、互斥、实现了Lock接口的锁，它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力。</p>
<h3 id="9-5-使用局部（本地）变量实现线程同步"><a href="#9-5-使用局部（本地）变量实现线程同步" class="headerlink" title="9.5 使用局部（本地）变量实现线程同步"></a>9.5 使用局部（本地）变量实现线程同步</h3><p>如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本，副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。</p>
<p>ThreadLocal 类的常用方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal() : 创建一个线程本地变量 </span><br><span class="line">get() : 返回此线程局部变量的当前线程副本中的值 </span><br><span class="line">initialValue() : 返回此线程局部变量的当前线程的&quot;初始值&quot; </span><br><span class="line">set(T value) : 将此线程局部变量的当前线程副本中的值设置为value</span><br></pre></td></tr></table></figure>

<h2 id="10-Java线程之间的通信"><a href="#10-Java线程之间的通信" class="headerlink" title="10.Java线程之间的通信"></a>10.Java线程之间的通信</h2><ul>
<li>wait()、notify()、notifyAll()——Object类的方法<ul>
<li>本地方法、final修饰、必须与synchronized一起</li>
<li>wait()：让当前线程释放对象锁并进入阻塞状态</li>
<li>notify()：用于唤醒一个正在等待响应对象锁的线程，使其进入就绪队列</li>
<li>每个锁都有两个队列：就绪队列、阻塞队列。</li>
</ul>
</li>
<li>await()、signal()、signalAll()——Condition接口的方法<ul>
<li>依赖于Lock，更安全高效</li>
<li>必须在lock.lock()和lock.unlock()之间使用</li>
</ul>
</li>
<li>BlockingQueue——生产者&#x2F;消费者模式<ul>
<li>放时 队满阻塞</li>
<li>取时 队空阻塞</li>
</ul>
</li>
</ul>
<h2 id="11-Java的锁"><a href="#11-Java的锁" class="headerlink" title="11.Java的锁"></a>11.Java的锁</h2><img src="/2022/10/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/20181122101753671.png" class="">

<h3 id="1）乐观锁和悲观锁"><a href="#1）乐观锁和悲观锁" class="headerlink" title="1）乐观锁和悲观锁"></a>1）乐观锁和悲观锁</h3><ul>
<li><p><strong>悲观锁</strong>：每次拿数据都都认为别人会修改，所以每次拿数据都会上锁，其他想获取数据的会被阻塞。通过<strong>synchronized或Lock</strong>接口实现。</p>
</li>
<li><p><strong>乐观锁</strong>：每次拿数据的时候都认为别人不会修改，所以不会上锁。但在更新时会判断一下在此期间别人有没有去更新这个数据。提高了吞吐量。乐观锁适用于多读的应用类型，这样可以提高吞吐量。在JDK1.5 中新增 java.util.concurrent (J.U.C)就是建立在<strong>CAS</strong>之上的。相对于对于 synchronized 这种阻塞算法，CAS是非阻塞算法的一种常见实现。所以J.U.C在性能上有了很大的提升。</p>
</li>
<li><p>CAS——含三个操作数：需要读写的内存位置（V）、进行比较的预期原值（A） 和拟写入的新值(B)。CAS指令执行时，当且仅当内存地址V中的值与预期值A相等时，将内存地址V中的值修改为B，否则就什么都不做。整个比较并替换的操作是一个原子操作。有以下缺点：</p>
<ul>
<li><strong>ABA问题</strong>。</li>
<li><strong>循环时间长</strong>。</li>
<li><strong>只能保证一个变量的原子操作</strong>。</li>
</ul>
</li>
<li><p><strong>什么是ABA问题？ABA问题怎么解决？</strong></p>
<p>CAS 的使用流程通常如下：1）首先从地址 V 读取值 A；2）根据 A 计算目标值 B；3）通过 CAS 以原子的方式将地址 V 中的值从 A 修改为 B。</p>
<p>但是在第1步中读取的值是A，并且在第3步修改成功了，我们就能说它的值在第1步和第3步之间没有被其他线程改变过了吗？</p>
<p>如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ABA”问题。Java并发包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。</p>
</li>
</ul>
<h3 id="2）公平锁与非公平锁"><a href="#2）公平锁与非公平锁" class="headerlink" title="2）公平锁与非公平锁"></a>2）公平锁与非公平锁</h3><p>根据多个线程是否按照申请锁的顺序来获取锁，Java中将实现锁的方式分为两种：</p>
<ul>
<li><p>一种是使用Java自带的关键字<strong>synchronized</strong>对相应的类或者方法以及代码块进行加锁，只能是非公平锁。</p>
</li>
<li><p>另一种是<strong>ReentrantLock</strong>，默认非公平但可实现公平的一把锁。</p>
</li>
<li><p>synchronized：非公平锁</p>
</li>
<li><p>ReentrantLock：默认非公平，可以公平。基于内部类：</p>
<ul>
<li>FairSyn：公平锁</li>
<li>NonFairSync：非公平锁</li>
</ul>
<p>并且依赖于AQS。</p>
</li>
</ul>
<p>tryAcquire()是一个抽象方法，是公平与非公平的实现原理所在。</p>
<h3 id="3）-无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁"><a href="#3）-无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁" class="headerlink" title="3） 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁"></a>3） 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁</h3><p>这四种锁是指锁的状态，专门针对synchronized的。synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。</p>
<p><strong>锁的状态</strong>（这些锁不等同于Java API中的ReentratLock这种锁，这些锁是概念上的，是JDK1.6中为了对synchronized同步关键字进行优化而产生的的锁机制。）对象头中有Mark Word字段，含有所得状态信息。</p>
<ul>
<li><p><strong>无锁</strong>——锁标志位 01、偏向锁标志位 0</p>
</li>
<li><p><strong>偏向锁</strong>——锁标志位 01、偏向锁标志位 1</p>
<p>通俗的讲，偏向锁就是在运行过程中，对象的锁偏向某个线程。即在开启偏向锁机制的情况下，某个线程获得锁，当该线程下次再想要获得锁时，不需要再获得锁（即忽略synchronized关键词），直接就可以执行同步代码，比较适合竞争较少的情况。</p>
</li>
<li><p><strong>轻量级锁</strong>——锁标志位 00</p>
<p>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。轻量级锁不是用来替代传统的重量级锁的，而是在没有多线程竞争的情况下，使用轻量级锁能够减少性能消耗，但是当多个线程同时竞争锁时，轻量级锁会膨胀为重量级锁。</p>
</li>
<li><p><strong>重量级锁</strong>——锁标志位 10 </p>
<p>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低</p>
<img src="/2022/10/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220504021022415.png" class=""></li>
</ul>
<p><strong>synchronized 锁升级原理</strong>：</p>
<ul>
<li>在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id;</li>
<li>再次进入的时候会先判断threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，当前线程通过CAS操作竞争锁，若竞争成功，threadid 设置为当前线程ID，然后执行同步代码。</li>
<li>当前线程通过CAS竞争锁失败的情况下，说明有竞争，当到达全局安全点时之前获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。</li>
<li>通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。</li>
</ul>
<img src="/2022/10/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220608004006489.png" class="">

<p><strong>锁的升级的目的</strong>：</p>
<p>锁升级是<strong>为了减低了锁带来的性能消耗。</strong>在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p>
<h3 id="4）自旋锁-与-自适应锁"><a href="#4）自旋锁-与-自适应锁" class="headerlink" title="4）自旋锁 与 自适应锁"></a>4）自旋锁 与 自适应锁</h3><p><strong>自旋锁</strong>：许多情况下，共享数据的锁定状态持续时间较短，切换线程不值得，通过让线程执行循环等待锁的释放，不让出CPU。如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式。但是它也存在<strong>缺点</strong>：如果锁被其他线程长时间占用，一直不释放CPU，会带来许多的性能开销。<strong>实现原理一样是CAS</strong></p>
<p><strong>自适应自旋锁</strong>：这种相当于是对上面自旋锁优化方式的进一步优化，它的自旋的次数不再固定，其自旋的次数由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定，这就解决了自旋锁带来的缺点。</p>
<h3 id="5）为什么要引入偏向锁和轻量级锁？为什么重量级锁开销大？"><a href="#5）为什么要引入偏向锁和轻量级锁？为什么重量级锁开销大？" class="headerlink" title="5）为什么要引入偏向锁和轻量级锁？为什么重量级锁开销大？"></a>5）为什么要引入偏向锁和轻量级锁？为什么重量级锁开销大？</h3><p>重量级锁底层依赖于系统的同步函数来实现，在 linux 中使用 pthread_mutex_t（互斥锁）来实现。</p>
<p>这些底层的同步函数操作会涉及到：操作系统用户态和内核态的切换、进程的上下文切换，而这些操作都是比较耗时的，因此重量级锁操作的开销比较大。</p>
<p>而在很多情况下，可能获取锁时只有一个线程，或者是多个线程交替获取锁，在这种情况下，使用重量级锁就不划算了，因此引入了偏向锁和轻量级锁来降低没有并发竞争时的锁开销。</p>
<h3 id="6）锁消除"><a href="#6）锁消除" class="headerlink" title="6）锁消除"></a>6）锁消除</h3><p>消除锁是虚拟机另外一种锁的优化，这种优化更彻底，在JIT编译时，对运行上下文进行扫描，去除不可能存在竞争的锁。</p>
<h3 id="7）锁粗化"><a href="#7）锁粗化" class="headerlink" title="7）锁粗化"></a>7）锁粗化</h3><p>锁粗化是虚拟机对另一种极端情况的优化处理，通过扩大锁的范围，避免反复加锁和释放锁。</p>
<h3 id="8）synchronized-锁降级"><a href="#8）synchronized-锁降级" class="headerlink" title="8）synchronized 锁降级"></a>8）synchronized 锁降级</h3><p>JDK 1.6 之后为了提高 synchronized 的效率，才引入了偏向锁、轻量级锁。 随着锁竞争逐渐激烈，其状态会按照「无锁 &#x3D;&#x3D;&gt; 偏向锁 &#x3D;&#x3D;&gt; 轻量级锁 &#x3D;&#x3D;&gt; 重量级锁 」这个方向逐渐升级，并且不可逆，只能进行锁升级，而<strong>无法进行锁降级</strong>。</p>
<h3 id="9）互斥锁？"><a href="#9）互斥锁？" class="headerlink" title="9）互斥锁？"></a>9）互斥锁？</h3><ul>
<li><strong>synchronized——一种块结构</strong><ul>
<li>会在同步块的前后形成monitorenter和monitorexit这两个字节码指令。字节码指令都需要一个引用类型的参数来指明要锁定和解锁的对象。不指定时，根据synchronized修饰的方法类型来决定是取代码所在的对象实例还是取类型对应的Class对象来作为线程要持有的锁。</li>
</ul>
</li>
<li>JDK5起，提供了<strong>JUC包</strong>。——基于Lock接口，用非块结构实现互斥同步。</li>
</ul>
<h3 id="10）分段锁"><a href="#10）分段锁" class="headerlink" title="10）分段锁"></a>10）分段锁</h3><p>首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p>
<p>ConcurrentHashMap——数组+数组+链表</p>
<h3 id="11）读写锁"><a href="#11）读写锁" class="headerlink" title="11）读写锁"></a>11）读写锁</h3><ul>
<li>共享读，但只能一个写</li>
<li>适用于读远远大于写</li>
<li>读写锁由于需要额外维护读锁的状态，当并发不是很高的情况下，效率可能不如独占锁高。</li>
<li>Java的ReadWriteLock的主要实现主要为ReentrantReadWriteLock，其提供了以下特性：<ul>
<li>公平性选择：默认非公平，也可以公平。非公平的吞吐量大于公平</li>
<li>可重入：读线程获取读锁后可以再次获取读锁，写线程获取写锁之后可以再次获取写锁</li>
<li>可降级：写线程获取写锁之后，还能再次获取读锁，然后释放掉写锁之后，此时是读锁状态</li>
</ul>
</li>
</ul>
<h3 id="12）如何自己实现一个锁？"><a href="#12）如何自己实现一个锁？" class="headerlink" title="12）如何自己实现一个锁？"></a>12）如何自己实现一个锁？</h3><ul>
<li><p>需要一个锁标记，来记录当前持有锁的进程，考虑到它的原子性，我们用 AtomicReference 类来存放。</p>
</li>
<li><p>需要一个线程的等待集合，所以我们要定义一个list，考虑到先进先出机制，我们用 LinkedBlockingQueue 来存放线程集合。</p>
</li>
<li><p>线程执行完，会释放锁，此时要通知其他线程争抢锁，这里又涉及到线程通信。</p>
</li>
<li><p>PS：细致的话，还需要公平性，是否可重入等</p>
</li>
</ul>
<h2 id="12-Java中实现锁的方式"><a href="#12-Java中实现锁的方式" class="headerlink" title="12.Java中实现锁的方式"></a>12.Java中实现锁的方式</h2><p>两种：synchronized关键字和并发包中的锁类。</p>
<p>下图显示了Lock接口的继承关系，ReentrantLock是Lock的重要实现类</p>
<img src="/2022/10/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1771072-20200216201818148-1683117055.png" class="">

<h2 id="13-Synchronized与Lock的区别？"><a href="#13-Synchronized与Lock的区别？" class="headerlink" title="13.Synchronized与Lock的区别？"></a>13.Synchronized与Lock的区别？</h2><ul>
<li>Synchronized是Java关键字，在JVM层面实现加解锁；Lock是接口，在代码层面实现加解锁。</li>
<li>Synchronized可以用在代码块、方法上；Lock只能写在代码上；</li>
<li>Synchronized在代码执行完成或出现异常时自动解锁；Lock必须显示解锁；</li>
<li>Synchronized会使拿不到锁的线程一直等待；Lock可以设置获取锁失败的超时时间；</li>
<li>Synchronized无法得知是否会成功获得锁；Lock可以通过tryLock得知加锁是否成功；</li>
<li>Synchronized锁可重入、不可中断、非公平；Lock锁可重入、可中断、可公平&#x2F;不公平，还可以分读写锁。</li>
</ul>
<h2 id="14-synchronized和RenntrantLock的区别"><a href="#14-synchronized和RenntrantLock的区别" class="headerlink" title="14.synchronized和RenntrantLock的区别"></a>14.synchronized和RenntrantLock的区别</h2><p>① <strong>底层实现</strong></p>
<p>synchronized 是<strong>JVM</strong>层面的锁，是<strong>Java关键字</strong>，通过monitor对象来完成（monitorenter与monitorexit），对象只有在同步块或同步方法中才能调用wait&#x2F;notify方法，ReentrantLock 是从jdk1.5以来（java.util.concurrent.locks.Lock）提供的<strong>API层面</strong>的锁。</p>
<p>② <strong>是否可手动释放：</strong></p>
<p>synchronized 不需要用户去手动释放锁，synchronized 代码执行完后系统会自动让线程释放对锁的占用； ReentrantLock则需要用户去手动释放锁，如果没有手动释放锁，就可能导致死锁现象。一般通过lock()和unlock()方法配合try&#x2F;finally语句块来完成，使用释放更加灵活。</p>
<p>③ <strong>是否可中断</strong></p>
<p>synchronized是不可中断类型的锁，除非加锁的代码中出现异常或正常执行完成； ReentrantLock则可以中断</p>
<p>④ <strong>是否公平锁</strong></p>
<p>synchronized为非公平锁 ReentrantLock则即可以选公平锁也可以选非公平锁，通过构造方法new ReentrantLock时传入boolean值进行选择，为空默认false非公平锁，true为公平锁。</p>
<p>⑤ <strong>锁是否可绑定条件Condition</strong></p>
<p>synchronized不能绑定； ReentrantLock通过绑定Condition结合await()&#x2F;singal()方法实现线程的精确唤醒，而不是像synchronized通过Object类的wait()&#x2F;notify()&#x2F;notifyAll()方法要么随机唤醒一个线程要么唤醒全部线程。</p>
<p>⑥ <strong>锁的对象</strong></p>
<p>synchronzied锁的是对象，锁是保存在对象头里面的，根据对象头数据来标识是否有线程获得锁&#x2F;争抢锁；ReentrantLock锁的是线程，根据进入的线程和int类型的state标识锁的获得&#x2F;争抢。</p>
<p>⑦ReentrantLock 比 synchronized 增加了一些高级功能</p>
<p>相比<code>synchronized</code>，<code>ReentrantLock</code>增加了一些高级功能。主要来说主要有三点：</p>
<ul>
<li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li>
<li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li>
<li><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>&#x2F;<code>notifyAll()</code>方法相结合可以实现等待&#x2F;通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</li>
</ul>
<h2 id="15-AQS-AbstractQueueSynchronizer"><a href="#15-AQS-AbstractQueueSynchronizer" class="headerlink" title="15.AQS(AbstractQueueSynchronizer)"></a>15.AQS(AbstractQueueSynchronizer)</h2><p><strong>AQS(抽象队列同步器) 核心思想</strong>是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p>
<p>AQS就是基于CLH队列（同步队列，FIFO双向队列），用volatile修饰共享变量state，线程通过CAS去改变状态符，成功则获取锁成功，失败则进入等待队列，等待被唤醒。</p>
<ul>
<li>AQS内部维护了一个int成员变量来表示同步状态，通过内置的FIFO同步队列来控制获取共享资源的线程。AQS主要做这么几件事：<ul>
<li>同步状态的维护管理</li>
<li>等待队列的维护管理</li>
<li>线程的阻塞与唤醒</li>
</ul>
</li>
<li>AQS采用<strong>模板方法模式</strong>，在内部维护了很多的模板的方法，子类只需要实现特定的几个方法（非抽象方法！！），就可以实现子类自己的需求。</li>
<li>基于AQS实现的组件：<ul>
<li>ReentrantLock——可重入锁</li>
<li>Semaphore——计数信号量</li>
<li>ReentrantReadWriteLock——读写锁</li>
</ul>
</li>
</ul>
<h2 id="16-线程池"><a href="#16-线程池" class="headerlink" title="16.线程池"></a>16.线程池</h2><p><strong>思想</strong>：线程池在系统启动时即创建大量空闲的线程，程序将一个Runnable对象或Callable对象传给线程池，线程池就会启动一个空闲的线程来执行他们的run()或call()方法，当执行结束后，该线程并不会死亡，而是再次返回线程池中成为空闲状态，等待执行下一个Runnable对象的run()或call()方法。</p>
<h3 id="16-1-使用线程池的好处"><a href="#16-1-使用线程池的好处" class="headerlink" title="16.1 使用线程池的好处"></a>16.1 使用线程池的好处</h3><ul>
<li><strong>降低资源消耗</strong>。 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。 当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<h3 id="16-2-线程池的状态："><a href="#16-2-线程池的状态：" class="headerlink" title="16.2 线程池的状态："></a>16.2 线程池的状态：</h3><ul>
<li><strong>Running</strong>：能接受新提交的任务，并且能处理阻塞队列中的任务。</li>
<li><strong>Shutdown</strong>：关闭状态，不再接受新任务，但是可以继续处理阻塞队列中已保存的任务。</li>
<li><strong>Stop</strong>：不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。</li>
<li><strong>Tidying</strong>：如果所有的任务都已终止，workerCount为0，线程池进入该状态后会调用terminated()方法（默认啥也不做）进入Terminated状态。</li>
<li><strong>Terminated</strong>：在terminated()方法执行完后进入该状态。</li>
</ul>
<h3 id="16-3-线程池中的关键参数"><a href="#16-3-线程池中的关键参数" class="headerlink" title="16.3 线程池中的关键参数"></a>16.3 线程池中的关键参数</h3><p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p>
<ul>
<li><strong><code>corePoolSize</code> :</strong> 核心线程数线程数定义了最小可以同时运行的线程数量。</li>
<li><strong><code>maximumPoolSize</code> :</strong> 最大线程数。当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li><strong><code>workQueue</code>:</strong> 工作队列。当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>
</ul>
<p><code>ThreadPoolExecutor</code>其他常见参数 :</p>
<ol>
<li><strong><code>keepAliveTime</code></strong>:存活时间。当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li>
<li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li>
<li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li>
<li><strong><code>handler</code></strong> :饱和策略。关于饱和策略下面单独介绍一下。</li>
</ol>
<h3 id="16-4-饱和策略"><a href="#16-4-饱和策略" class="headerlink" title="16.4 饱和策略"></a>16.4 饱和策略</h3><p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p>
<ul>
<li><strong><code>ThreadPoolExecutor.AbortPolicy</code></strong> ：抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li>
<li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code></strong> ：调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li>
<li><strong><code>ThreadPoolExecutor.DiscardPolicy</code></strong> ：不处理新任务，直接丢弃掉。</li>
<li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code></strong> ： 此策略将丢弃最早的未处理的任务请求。</li>
</ul>
<h3 id="16-5-shutdown-与-shutdownNow-的区别："><a href="#16-5-shutdown-与-shutdownNow-的区别：" class="headerlink" title="16.5 shutdown() 与 shutdownNow()的区别："></a>16.5 shutdown() 与 shutdownNow()的区别：</h3><ul>
<li><strong>shutdown</strong>() ：关闭线程池，线程池的状态变为 SHUTDOWN。线程池不再接受新任务了，但是队列里的任务得执行完毕。</li>
<li><strong>shutdownNow</strong>() ：关闭线程池，线程的状态变为 STOP。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。<br>shutdownNow的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终</li>
</ul>
<h3 id="16-6-执行execute-方法和submit-方法的区别是什么呢？"><a href="#16-6-执行execute-方法和submit-方法的区别是什么呢？" class="headerlink" title="16.6 执行execute()方法和submit()方法的区别是什么呢？"></a>16.6 执行execute()方法和submit()方法的区别是什么呢？</h3><ul>
<li><strong>execute() 方法</strong>用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</li>
<li><strong>submit()方法</strong>用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 get（long timeout，TimeUnit unit） 方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li>
</ul>
<h3 id="16-7-Executor和Executors的区别？"><a href="#16-7-Executor和Executors的区别？" class="headerlink" title="16.7 Executor和Executors的区别？"></a>16.7 Executor和Executors的区别？</h3><ul>
<li>Executors <strong>工具类</strong>的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。</li>
<li>Executor <strong>接口</strong>对象能执行我们的线程任务。ExecutorService接口继承了Executor接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。</li>
</ul>
<h2 id="17-ThreadLocal"><a href="#17-ThreadLocal" class="headerlink" title="17.ThreadLocal"></a>17.ThreadLocal</h2><h3 id="17-1-解决什么问题？"><a href="#17-1-解决什么问题？" class="headerlink" title="17.1 解决什么问题？"></a><strong>17.1 解决什么问题？</strong></h3><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong></p>
<p>JDK中提供的ThreadLocal类就是解决这个问题的。换句话说，类ThreadLocal主要解决的就是每个线程绑定自己的值，可以将ThreadLocal类比喻成全局存放数据的盒子，盒子中可以存储每个线程的私有数据。</p>
<p><strong>ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用</strong>。作用：提供一个<strong>线程内</strong>公共变量（比如当前请求的用户信息），减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度，或者为线程提供一个<strong>私有的变量副本</strong>，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。</p>
<h3 id="17-2-原理："><a href="#17-2-原理：" class="headerlink" title="17.2 原理："></a><strong>17.2 原理</strong>：</h3><p><strong>每个<code>Thread</code>中都具备一个<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为 key ，Object 对象为 value 的键值对。</strong>此处key为弱引用，value为强引用。【弱引用是为了GC】</p>
<img src="/2022/10/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1156565-20170724100913883-243740206.png" class="">

<p>ThreadLocalMap类的定义是在ThreadLocal类中（内部类），真正的引用却是在Thread类中。</p>
<p>Thread类中有一行，引用ThreadLocalMap</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained by the ThreadLocal class. */</span></span><br><span class="line">   ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>ThreadLocalMap中用于存储数据的entry定义：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    <span class="type">Object</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="type">Entry</span>(<span class="type">ThreadLocal</span>&lt;?&gt; k, <span class="type">Object</span> v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Map的key是ThreadLocal类的实例对象，value为用户的值</strong></p>
<h4 id="ThreadLocal的工作原理"><a href="#ThreadLocal的工作原理" class="headerlink" title="ThreadLocal的工作原理"></a><strong>ThreadLocal的工作原理</strong></h4><ol>
<li><strong>Thread类中有一个成员变量属于ThreadLocalMap类</strong>(一个定义在ThreadLocal类中的内部类)，它是一个Map，他的key是ThreadLocal实例对象。</li>
<li><strong>当为ThreadLocal类的对象set值时，首先获得当前线程的ThreadLocalMap类属性</strong>，然后以ThreadLocal类的对象为key，设定value。get值时则类似。</li>
<li><strong>ThreadLocal变量的活动范围为某线程</strong>，是该线程“专有的，独自霸占”的，对该变量的所有操作均由该线程完成！也就是说，ThreadLocal 不是用来解决共享对象的多线程访问的竞争问题的，因为ThreadLocal.set() 到线程中的对象是该线程自己使用的对象，其他线程是不需要访问的，也访问不到的。当线程终止后，这些值会作为垃圾回收。</li>
<li>由ThreadLocal的工作原理决定了：每个线程独自拥有一个变量，并非是共享的</li>
</ol>
<h4 id="如过实现一个线程多个ThreadLocal对象，每一个ThreadLocal对象是如何区分的呢？"><a href="#如过实现一个线程多个ThreadLocal对象，每一个ThreadLocal对象是如何区分的呢？" class="headerlink" title="如过实现一个线程多个ThreadLocal对象，每一个ThreadLocal对象是如何区分的呢？"></a>如过实现一个线程多个ThreadLocal对象，每一个ThreadLocal对象是如何区分的呢？</h4><p>​	对于每一个ThreadLocal对象，都有一个final修饰的int型的<strong>threadLocalHashCode</strong>不可变属性，对于<strong>基本数据类型，可以认为它在初始化后就不可以进行修改，所以可以唯一确定一个ThreadLocal对象。</strong><br>　　但是如何保证两个同时实例化的ThreadLocal对象有不同的threadLocalHashCode属性：在ThreadLocal类中，还包含了一个static修饰的AtomicInteger（[əˈtɒmɪk]提供原子操作的Integer类）成员变量（即类变量）和一个static final修饰的常量（作为两个相邻nextHashCode的差值）。由于nextHashCode是类变量，所以每一次调用ThreadLocal类都可以保证nextHashCode被更新到新的值，并且下一次调用ThreadLocal类，这个被更新的值仍然可用，同时AtomicInteger保证了nextHashCode自增的原子性。</p>
<h4 id="为什么不直接用线程id来作为ThreadLocalMap的key？"><a href="#为什么不直接用线程id来作为ThreadLocalMap的key？" class="headerlink" title="为什么不直接用线程id来作为ThreadLocalMap的key？"></a>为什么不直接用线程id来作为ThreadLocalMap的key？</h4><p>　　这一点很容易理解，因为<strong>直接用线程id来作为ThreadLocalMap的key，无法区分放入ThreadLocalMap中的多个value。</strong>比如我们放入了两个字符串，你如何知道我要取出来的是哪一个字符串呢？<br>　　而使用ThreadLocal作为key就不一样了，由于每一个ThreadLocal对象都可以由threadLocalHashCode属性唯一区分或者说每一个<strong>ThreadLocal对象都可以由这个对象的名字唯一区分</strong>（下面的例子），所以可以用不同的ThreadLocal作为key，区分不同的value，方便存取。</p>
<h3 id="17-3-为什么key要设置成弱引用"><a href="#17-3-为什么key要设置成弱引用" class="headerlink" title="17.3.为什么key要设置成弱引用"></a>17.3.为什么key要设置成弱引用</h3><h4 id="对象的引用关系"><a href="#对象的引用关系" class="headerlink" title="对象的引用关系"></a>对象的引用关系</h4><img src="/2022/10/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1156565-20170724121152430-1111069410.png" class="">

<p>ThreadLocalMap在ThreadLocal中定义，在中引用了Thread，外界是通过ThreadLocal对象来对ThreadLocalMap进行操作的（ThreadLocalMap是ThreadLocal的内部类），假设外界使用ThreadLocal的对象被被回收，即ThreadLocalMap指向的ThreadLocal也不会再被访问，在此时应该对其（ThreadLocalMap引用的）进行GC。但是由于ThreadLocalMap被Thread引用，假如ThreadLocal为强引用，只要线程一直运行，因为ThreadLocal放在线程中的ThreadLocalMap中，**ThreadLocal一直被线程对象引用，所以在线程销毁之前都是可达的，都无法<code>GC</code>**，因此采用弱引用（只要发生GC，只有弱引用指向的对象就会被回收）</p>
<h3 id="17-4-内存泄漏（key为弱引用）"><a href="#17-4-内存泄漏（key为弱引用）" class="headerlink" title="17.4 内存泄漏（key为弱引用）"></a>17.4 内存泄漏（key为弱引用）</h3><p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</p>
<p>这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。<code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法</p>
<h3 id="17-5-为什么value不设置为弱引用"><a href="#17-5-为什么value不设置为弱引用" class="headerlink" title="17.5 为什么value不设置为弱引用"></a>17.5 为什么value不设置为弱引用</h3><p>假如key为弱引用，在其他的地方没有引用时，直接将其GC，而此时我们的<code>ThreadLocal</code>还处于使用期间，就会造成Value为null的错误，所以将其设置为强引用。</p>
<h3 id="17-6-很多人说建议把ThreadLocal修饰为static，为什么？"><a href="#17-6-很多人说建议把ThreadLocal修饰为static，为什么？" class="headerlink" title="17.6 很多人说建议把ThreadLocal修饰为static，为什么？"></a>17.6 很多人说建议把ThreadLocal修饰为static，为什么？</h3><p>ThreadLocal能实现了线程的数据隔离，不在于它自己本身，而在于Thread的ThreadLocalMap。所以，ThreadLocal可以只初始化一次，只分配一块存储空间就足以了，没必要作为成员变量多次被初始化。</p>
<h3 id="17-7-应用场景"><a href="#17-7-应用场景" class="headerlink" title="17.7 应用场景"></a>17.7 应用场景</h3><ul>
<li>数据库连接的时候，我们会创建一个<code>Connection</code>连接，让不同的线程使用。这个时候就会出现多个线程争抢同一个资源的情况。因此使用TreadLocal管理JDBC连接Connection，保证每个线程使用各自连接。</li>
<li>管理Session会话，将Session保存在ThreadLocal中，使线程多次处理会话时始终是同一个属于自己的Session。</li>
</ul>
<h3 id="17-8-实际应用"><a href="#17-8-实际应用" class="headerlink" title="17.8 实际应用"></a>17.8 实际应用</h3><p>Spring提供了事务相关的操作，而事务是得保证一组操作同时成功或失败的，这意味着一次事务的所有操作需要在同一个数据库连接上，Spring就是用的ThreadLocal来实现，ThreadLocal存储的类型是一个Map，Map中的key是DataSource，value 是Connection（为了应对多数据源的情况，所以是一个Map），用了ThreadLocal保证了同一个线程获取一个Connection对象。</p>
<h3 id="17-9-使用建议"><a href="#17-9-使用建议" class="headerlink" title="17.9 使用建议"></a>17.9 使用建议</h3><ul>
<li>用static修饰，static ThreadLocal headerLocal &#x3D; new ThreadLocal();</li>
<li>使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法</li>
</ul>
<h2 id="18-Volatile"><a href="#18-Volatile" class="headerlink" title="18.Volatile"></a>18.Volatile</h2><p>保证可见性和有序性</p>
<h3 id="18-1-造成可见性问题的原因"><a href="#18-1-造成可见性问题的原因" class="headerlink" title="18.1 造成可见性问题的原因"></a>18.1 造成可见性问题的原因</h3><p>在Java中造成可见性问题的原因是<code>Java内存模型(JMM)</code>，在Java内存模型中，规定了共享变量是存放在<code>主内存</code>中，然后每个线程都有自己的<code>工作内存</code>，而线程对共享变量的操作，必须先从主内存中读到工作内存中去，至于什么时候写回到主内存是不可预知的，这就导致每个线程之间对共享变量的操作是封闭的，其他线程不可见的。</p>
<h3 id="18-2-volatile如何解决可见性问题"><a href="#18-2-volatile如何解决可见性问题" class="headerlink" title="18.2 volatile如何解决可见性问题"></a>18.2 volatile如何解决可见性问题</h3><p>有volatile修饰的共享变量进行写操作的时候多出一条带<code>lock前缀的指令</code>，如下所示</p>
<img src="/2022/10/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/20200510191415431.png" class="">

<p>lock前缀的指令在多核处理器下会引发两件事情<br><code>1. 将当前处理器缓存行的数据写回到系统内存。</code><br><code>2. 这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</code></p>
<p>为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存后再进行操作，但是操作完了不知道什么时候写回内存。而对声明了volatile关键字的变量进行写操作，JVM会向处理器发送一条lock前缀的指令，将这个变量所在的缓存行立即写回系统内存。并且为了保证各个处理器的缓存是一致的，实现了<code>缓存一致性协议</code>，各个处理通过<code>嗅探</code>在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成<code>无效状态</code>，那么下次对这个数据进行操作，就会重新从系统内存中获取最新的值。对应JMM来说就是：</p>
<ol>
<li><code>Lock前缀的指令让线程工作内存中的值写回主内存中；</code></li>
<li><code>通过缓存一致性协议，其他线程如果工作内存中存了该共享变量的值，就会失效；</code></li>
<li><code>其他线程会重新从主内存中获取最新的值；</code></li>
</ol>
<h3 id="18-3-volatile保证有序性的原理"><a href="#18-3-volatile保证有序性的原理" class="headerlink" title="18.3 volatile保证有序性的原理"></a>18.3 volatile保证有序性的原理</h3><blockquote>
<p>为了性能优化，JVM会在不改变<code>数据依赖性</code>的情况下，允许<code>编译器和处理器对指令序列进行重排序</code>，而有序性问题指的就是程序代码执行的顺序与程序员编写程序的顺序不一致，导致程序结果不正确的问题。而加了volatile修饰的共享变量，则通过<code>内存屏障</code>解决了多线程下有序性问题。</p>
</blockquote>
<p>加了volatile关键字以后，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序</p>
<h3 id="18-4-volatile语义中的内存屏障"><a href="#18-4-volatile语义中的内存屏障" class="headerlink" title="18.4 volatile语义中的内存屏障"></a>18.4 volatile语义中的内存屏障</h3><ul>
<li>volatile的内存屏障策略非常严格保守，非常悲观且毫无安全感的心态：</li>
</ul>
<blockquote>
<p>在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障；<br>在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障；</p>
</blockquote>
<ul>
<li>由于内存屏障的作用，避免了volatile变量和其它指令重排序、线程之间实现了通信，使得volatile表现出了锁的特性。</li>
</ul>
<h2 id="19-Sychronized"><a href="#19-Sychronized" class="headerlink" title="19.Sychronized"></a>19.Sychronized</h2><p><code>synchronized</code>关键字同时保证上述三种特性（原子性、有序性、可见性）。</p>
<ul>
<li><p><code>synchronized</code>是同步锁，同步块内的代码相当于同一时刻单线程执行，故不存在原子性和指令重排序的问题</p>
</li>
<li><p><code>synchronized</code>关键字的语义JMM有两个规定，保证其实现内存可见性：</p>
<ul>
<li><p>线程解锁前，必须把共享变量的最新值刷新到主内存中；</p>
</li>
<li><p>线程加锁前，将清空工作内存中共享变量的值，从主内存中冲洗取值。</p>
</li>
</ul>
</li>
</ul>
<h3 id="19-1-如何使用-synchronized-关键字？"><a href="#19-1-如何使用-synchronized-关键字？" class="headerlink" title="19.1 如何使用 synchronized 关键字？"></a>19.1 如何使用 synchronized 关键字？</h3><p>synchronized 关键字最主要的三种使用方式：</p>
<ol>
<li>修饰实例方法</li>
<li>修饰静态方法</li>
<li>修饰代码块</li>
</ol>
<p><strong>1、修饰实例方法</strong> （锁当前对象实例）</p>
<p>给当前对象实例加锁，进入同步代码前要获得 <strong>当前对象实例的锁</strong> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、修饰静态方法</strong> （锁当前类）</p>
<p>给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 <strong>当前 class 的锁</strong>。</p>
<p>这是因为静态成员不属于任何一个实例对象，归整个类所有，不依赖于类的特定实例，被类的所有实例共享。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态 <code>synchronized</code> 方法和非静态 <code>synchronized</code> 方法之间的调用互斥么？不互斥！如果一个线程 A 调用一个实例对象的非静态 <code>synchronized</code> 方法，而线程 B 需要调用这个实例对象所属类的静态 <code>synchronized</code> 方法，是允许的，不会发生互斥现象，因为访问静态 <code>synchronized</code> 方法占用的锁是当前类的锁，而访问非静态 <code>synchronized</code> 方法占用的锁是当前实例对象锁。</p>
<p><strong>3、修饰代码块</strong> （锁指定对象&#x2F;类）</p>
<p>对括号里指定的对象&#x2F;类加锁：</p>
<ul>
<li><code>synchronized(object)</code> 表示进入同步代码库前要获得 <strong>给定对象的锁</strong>。</li>
<li><code>synchronized(类.class)</code> 表示进入同步代码前要获得 <strong>给定 Class 的锁</strong></li>
</ul>
<h3 id="19-2-构造方法可以使用-synchronized-关键字修饰么？"><a href="#19-2-构造方法可以使用-synchronized-关键字修饰么？" class="headerlink" title="19.2 构造方法可以使用 synchronized 关键字修饰么？"></a>19.2 构造方法可以使用 synchronized 关键字修饰么？</h3><p>先说结论：<strong>构造方法不能使用 synchronized 关键字修饰。</strong></p>
<p>构造方法本身就属于线程安全的，不存在同步的构造方法一说</p>
<h3 id="19-3-底层原理"><a href="#19-3-底层原理" class="headerlink" title="19.3 底层原理"></a>19.3 底层原理</h3><p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p>
<p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 <code>monitor</code></strong> 的持有权。</p>
<p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code>标识，该标识指明了该方法是一个同步方法。</p>
<h3 id="19-4-synchronized中有几个队列"><a href="#19-4-synchronized中有几个队列" class="headerlink" title="19.4 synchronized中有几个队列"></a>19.4 synchronized中有几个队列</h3><p><strong>三个</strong></p>
<p>同步队列：排队取锁的线程所在的队列</p>
<p>等待队列：调用 <code>wait</code> 方法后，线程会从同步队列转移到等待队列</p>
<p>synchronized 中同步队列有两个_cxq 与 EntryList，基于不同的 QMode 来调整线程的出队策略</p>
<p>_cxq (竞争队列): <strong>抢锁失败后，线程会进入此队列</strong>，此队列大部分情况是<strong>单向链表</strong>，入队策略是<strong>后来者当头</strong></p>
<p>EntryList: 默认情况下（根据 Knob_MoveNotifyee 判断，源码默认为 2 ，当 EntryList 不为空，Policy &#x3D;&#x3D; 2 时，参阅 源码 1720-1735 行)，<strong>线程被唤醒时，会从等待队列转移到此队列</strong>，此队列是一个<strong>双向链表</strong>，在此队列中去抢锁。</p>
<p>WaitSet: 等待队列，调用 wait 方法后，线程会进入此队列</p>
<h2 id="20-volatile和synchronized的区别"><a href="#20-volatile和synchronized的区别" class="headerlink" title="20.volatile和synchronized的区别"></a>20.volatile和synchronized的区别</h2><ul>
<li><strong>本质：</strong>volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</li>
<li><strong>锁级别：</strong>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。</li>
<li><strong>原子性：</strong>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。</li>
<li><strong>阻塞</strong>：volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。</li>
<li><strong>优化</strong>：volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化</li>
<li><code>volatile</code> 关键字是线程同步的轻量级实现，所以 <code>volatile</code>性能肯定比<code>synchronized</code>关键字要好 。但是 <code>volatile</code> 关键字只能用于变量，而 <code>synchronized</code> 关键字可以修饰方法以及代码块 。</li>
<li><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2022/10/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/" rel="tag">八股文</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
    
      <a href="/2022/10/05/Java%E5%9F%BA%E7%A1%80/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Java基础</div>
      </a>
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022
        <i class="ri-heart-fill heart_icon"></i> pp-lv
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.png" alt="LPL&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">Categories</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">Tags</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">About</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i></p>
  <div class="reward-box">
    
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>