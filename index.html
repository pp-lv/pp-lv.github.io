<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> LPL&#39;s Blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">LPL&#39;s Blog</a></h1>
      <div id="subtitle-box">
        
          <span id="subtitle">每个人都是一座孤岛</span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>




<!-- Subtitle -->

<div id="main">
  <section class="outer">
  
  
  
<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content">譬如工画师，分布诸彩色，虚妄取异相，大种无差别．</div>
</div>


<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-Java基础"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/10/05/Java%E5%9F%BA%E7%A1%80/"
    >Java基础</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/10/05/Java%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2022-10-05T12:45:00.000Z" itemprop="datePublished">2022-10-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%85%AB%E8%82%A1%E6%96%87/">八股文</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <span id="more"></span>

<h2 id="1-为什么Java代码可以实现一次编写、到处运行？"><a href="#1-为什么Java代码可以实现一次编写、到处运行？" class="headerlink" title="1. 为什么Java代码可以实现一次编写、到处运行？"></a>1. 为什么Java代码可以实现一次编写、到处运行？</h2><p><strong>JVM</strong>。</p>
<p>在程序运行前，Java源代码（.java）需要经过编译器编译成字节码（.class）。在程序运行时，JVM负责将字节码翻译成特定平台下的机器码并运行，也就是说，只要在不同的平台上安装对应的JVM，就可以运行字节码文件。</p>
<p>同一份Java源代码在不同的平台上运行，它不需要做任何的改变，并且只需要编译一次。而编译好的字节码，是通过JVM这个中间的“桥梁”实现跨平台的，JVM是与平台相关的软件，它能将统一的字节码翻译成该平台的机器码。在程序运行前，Java源代码需要讲过编译成字节码(.class)。在程序运行时，JVM负责将字节码翻译成特定平台下的机器码并运行。</p>
<h2 id="2-Java的访问权限"><a href="#2-Java的访问权限" class="headerlink" title="2. Java的访问权限"></a>2. Java的访问权限</h2><p>在<strong>修饰成员变量&#x2F;成员方法</strong>时，该成员的四种访问权限的含义如下：</p>
<ul>
<li>private：该成员可以被该<strong>类内</strong>部成员访问；</li>
<li>default：该成员可以被该<strong>类内</strong>部成员访问，也可以被<strong>同一包</strong>下其他的类访问；</li>
<li>protected：该成员可以被该<strong>类内</strong>部成员访问，也可以被<strong>同一包</strong>下其他的类访问，还可以被它的<strong>子类</strong>访问；</li>
<li>public：该成员可以被<strong>任意包</strong>下，<strong>任意类</strong>的成员进行访问。</li>
</ul>
<p>在<strong>修饰类</strong>时，该类只有两种访问权限，对应的访问权限的含义如下：</p>
<ul>
<li>default：该类可以被<strong>同一包</strong>下其他的类访问；</li>
<li>public：该类可以被<strong>任意包</strong>下，<strong>任意的类</strong>所访问。</li>
</ul>
<h2 id="3-Java的数据类型"><a href="#3-Java的数据类型" class="headerlink" title="3. Java的数据类型"></a>3. Java的数据类型</h2><p>Java数据类型包括<strong>基本数据类型</strong>和<strong>引用数据类型</strong>两大类。</p>
<p><strong>基本数据类型</strong>有8个，可以分为4个小类：</p>
<ul>
<li>整型：byte&#x2F;short&#x2F;int&#x2F;long （默认值是0 &#x2F; 0L）</li>
<li>浮点类型：float&#x2F;double （0.0F &#x2F; 0.0）</li>
<li>字符类型：char （’\u0000‘）</li>
<li>布尔类型：boolean (false)</li>
</ul>
<p>引用类型就是对一个对象的引用，根据引用对象类型的不同，可以将引用类型分为3类，即数组、类、接口类型。引用类型本质上就是通过指针，指向堆中对象所持有的内存空间，只是Java语言不再沿用指针这个说法而已。</p>
<ul>
<li>引用类型：数组、类、接口等等</li>
</ul>
<p><strong>PS：数据范围：</strong></p>
<ul>
<li>byte：1字节（8位），数据范围是 -2^7 ~ 2^7-1。</li>
<li>short：2字节（16位），数据范围是 -2^15 ~ 2^15-1。</li>
<li>int：4字节（32位），数据范围是 -2^31 ~ 2^31-1。</li>
<li>long：8字节（64位），数据范围是 -2^63 ~ 2^63-1。</li>
<li>float：4字节（32位），数据范围大约是 -3.4<em>10^38 ~ 3.4</em>10^38。</li>
<li>double：8字节（64位），数据范围大约是 -1.8<em>10^308 ~ 1.8</em>10^308。</li>
<li>char：2字节（16位），数据范围是 \u0000 ~ \uffff。</li>
<li>boolean：Java规范没有明确的规定，不同的JVM有不同的实现机制。</li>
</ul>
<h2 id="4-成员变量与局部变量"><a href="#4-成员变量与局部变量" class="headerlink" title="4. 成员变量与局部变量"></a>4. 成员变量与局部变量</h2><ul>
<li>成员变量<ul>
<li>类的范围内定义的变量</li>
<li>有默认初始值</li>
<li>未被static修饰的成员变量叫实例变量，存储于堆内，生命周期与对象相同</li>
<li>被static修饰的成员变量叫类变量，存储于方法区，生命周期与当前类相同</li>
</ul>
</li>
<li>局部变量<ul>
<li>在方法里定义的变量</li>
<li>没有默认初始值</li>
<li>存储于栈中</li>
</ul>
</li>
</ul>
<h2 id="5-自动装箱、自动拆箱"><a href="#5-自动装箱、自动拆箱" class="headerlink" title="5. 自动装箱、自动拆箱"></a>5. 自动装箱、自动拆箱</h2><ul>
<li>自动装箱：把一个基本类型的数据直接赋值给对应的包装类型</li>
<li>自动拆箱：把一个包装类型的对象直接赋值给对应的基本类型</li>
<li>通过自动装箱、自动拆箱功能，可以大大简化基本类型变量和包装类对象之间的转换过程。比如，某个方法的参数类型为包装类型，调用时我们所持有的数据却是基本类型的值，则可以不做任何特殊的处理，直接将这个基本类型的值传入给方法即可。</li>
</ul>
<h3 id="5-1-为啥要有包装类？"><a href="#5-1-为啥要有包装类？" class="headerlink" title="5.1 为啥要有包装类？"></a>5.1 为啥要有包装类？</h3><p>Java语言是面向对象的语言，其设计理念是“一切皆对象”。但8种基本数据类型却出现了例外，它们不具备对象的特性。正是为了解决这个问题，<strong>Java为每个基本数据类型都定义了一个对应的引用类型，这就是包装类。</strong></p>
<h3 id="5-2-包装类型的缓存机制"><a href="#5-2-包装类型的缓存机制" class="headerlink" title="5.2 包装类型的缓存机制"></a>5.2 包装类型的缓存机制</h3><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p>
<p>如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p>
<p>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现缓存机制。</p>
<p><strong>PS：</strong>所有整型包装类对象之间值的比较，建议全部使用 equals 方法比较。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-int和Integer的区别？-x3D-x3D-时会得到什么结果？"><a href="#6-int和Integer的区别？-x3D-x3D-时会得到什么结果？" class="headerlink" title="6. int和Integer的区别？&#x3D;&#x3D;时会得到什么结果？"></a>6. int和Integer的区别？&#x3D;&#x3D;时会得到什么结果？</h2><p>基本数据类型 &#x2F; 包装类</p>
<p>&#x3D;&#x3D; 时，Integer会自动拆箱为int</p>
<h2 id="7-对面向对象的理解"><a href="#7-对面向对象的理解" class="headerlink" title="7. 对面向对象的理解"></a>7. 对面向对象的理解</h2><h3 id="7-1-Is-a："><a href="#7-1-Is-a：" class="headerlink" title="7.1 Is-a："></a><strong>7.1 Is-a：</strong></h3><p><strong>是a：A Is B：A是B（继承关系，继承）。</strong></p>
<h3 id="7-2-has-a："><a href="#7-2-has-a：" class="headerlink" title="7.2 has-a："></a><strong>7.2 has-a：</strong></h3><p><strong>有a：A has B：A有B（从属关系，聚合）。</strong></p>
<h3 id="7-3-like-a："><a href="#7-3-like-a：" class="headerlink" title="7.3 like-a："></a><strong>7.3 like-a：</strong></h3><p><strong>像a：A like B：A像B（组合关系，接口）。</strong></p>
<p>如果A,B是Is-a关系，那么应该使用继承，例：玻璃杯、塑料杯都是杯子。</p>
<p>如果A,B是has-a关系，那么应该是用聚合，例：汽车由发动机，底盘，车身，电气设备等组成，那么应该把发动机，底盘这些类聚合成汽车。</p>
<p>如果A,B是like-a关系，那么应该使用组合，例：空调继承于制冷机，但它同时有加热功能，那么你应该把让空调继承制冷机类，并实现加热接口。</p>
<p>基本思想是使用类、对象、继承、封装、消息等基本概念进行程序设计。它从现实世界中客观的事物触发来构造软件系统，强调直接以现实世界中的事物为中心来思考，把他们抽象地表示为系统中的类。</p>
<h3 id="7-4-面向对象的三大特征"><a href="#7-4-面向对象的三大特征" class="headerlink" title="7.4 面向对象的三大特征"></a>7.4 面向对象的三大特征</h3><ul>
<li><p>封装：是面向对象编程语言对客观世界的模拟，在客观世界里，对象的状态信息都被隐藏在对象内部，外界无法直接操作和修改。对一个类或对象实现良好的封装，可以实现以下目的：</p>
<ul>
<li>隐藏类的实现细节；</li>
<li>让使用者只能通过事先预定的方法来访问数据，从而可以在该方法里加入控制逻辑，限制对成员变量的不合理访问；</li>
<li>可进行数据检查，从而有利于保证对象信息的完整性；</li>
<li>便于修改，提高代码的可维护性。</li>
</ul>
</li>
<li><p>继承：当子类继承父类使，将直接获得父类的一些属性和方法。</p>
</li>
<li><p>多态：因为子类其实是一种特殊的父类，因此Java允许把一个子类对象直接赋给一个父类引用变量，无须任何类型转换，或者被称为向上转型，向上转型由系统自动完成。<strong>编译时是父类类型，运行时是子类类型</strong></p>
<p>当把一个子类对象直接赋给父类引用变量时，例如 BaseClass obj &#x3D; new SubClass();，这个obj引用变量的编译时类型是BaseClass，而运行时类型是SubClass，当运行时调用该引用变量的方法时，其方法行为总是表现出子类方法的行为特征，而不是父类方法的行为特征，这就可能出现：相同类型的变量、调用同一个方法时呈现出多种不同的行为特征，这就是多态。</p>
</li>
</ul>
<h3 id="7-5-多态的实现方式？"><a href="#7-5-多态的实现方式？" class="headerlink" title="7.5 多态的实现方式？"></a>7.5 <strong>多态的实现方式？</strong></h3><p><strong>多态的实现离不开继承</strong>，在设计程序时，我们可以将参数的类型定义为父类型。在调用程序时，则可以根据实际情况，传入该父类型的某个子类型的实例，这样就实现了多态。对于父类型，可以有三种形式，即普通的类、抽象类、接口。对于子类型，则要根据它自身的特征，重写父类的某些方法，或实现抽象类&#x2F;接口的某些抽象方法。</p>
<h3 id="7-6-Java为什么不能多继承？"><a href="#7-6-Java为什么不能多继承？" class="headerlink" title="7.6 Java为什么不能多继承？"></a><strong>7.6 Java为什么不能多继承？</strong></h3><p>首先，Java是单继承的，指的是Java中一个类只能有一个直接的父类。Java不能多继承，则是说Java中一个类不能直接继承多个父类。</p>
<p>其次，Java在设计时借鉴了C++的语法，而C++是支持多继承的。Java语言之所以摒弃了多继承的这项特征，是因为<strong>多继承容易产生混淆</strong>。比如，两个父类中包含相同的方法时，子类在调用该方法或重写该方法时就会迷惑。</p>
<p>准确来说，Java是可以实现”多继承”的。因为尽管一个类只能有一个直接父类，但是却可以有任意多个间接的父类。这样的设计方式，避免了多继承时所产生的混淆。</p>
<h2 id="8-Object类"><a href="#8-Object类" class="headerlink" title="8. Object类"></a>8. Object类</h2><p>Object 类是一个特殊的类，<strong>是所有类的父类</strong>。</p>
<p><strong>Object类提供了如下几个常用方法：</strong></p>
<ul>
<li>Class&lt;?&gt; <strong>getClass</strong>()：返回该对象的运行时类。</li>
<li>boolean <strong>equals</strong>(Object obj)：判断指定对象与该对象是否相等。</li>
<li>int <strong>hashCode</strong>()：返回该对象的hashCode值。在默认情况下，Object类的hashCode()方法根据该对象的地址来计算。但很多类都重写了Object类的hashCode()方法，不再根据地址来计算其hashCode()方法值。</li>
<li>String <strong>toString</strong>()：返回该对象的字符串表示，当程序使用System.out.println()方法输出一个对象，或者把某个对象和字符串进行连接运算时，系统会自动调用该对象的toString()方法返回该对象的字符串表示。Object类的toString()方法返回 运行时类名@十六进制hashCode值 格式的字符串，但很多类都重写了Object类的toString()方法，用于返回可以表述该对象信息的字符串。</li>
</ul>
<p>另外，Object类还提供了<strong>wait</strong>()、<strong>notify</strong>()、<strong>notifyAll</strong>()这几个方法，通过这几个方法可以控制线程的暂停和运行。Object类还提供了一个clone()方法，该方法用于帮助其他对象来实现“自我克隆”，所谓“自我克隆”就是得到一个当前对象的副本，而且二者之间完全隔离。由于该方法使用了protected修饰，因此它只能被子类重写或调用。</p>
<p><strong>扩展阅读</strong></p>
<p>Object类还提供了一个<strong>finalize</strong>()方法，当系统中没有引用变量引用到该对象时，垃圾回收器调用此方法来清理该对象的资源。并且，针对某一个对象，垃圾回收器最多只会调用它的finalize()方法一次。</p>
<p>注意，finalize()方法何时调用、是否调用都是不确定的，我们也不要主动调用finalize()方法。从JDK9开始，这个方法被标记为不推荐使用的方法。</p>
<h2 id="9-hashCode-和equals-的关系"><a href="#9-hashCode-和equals-的关系" class="headerlink" title="9. hashCode()和equals()的关系"></a>9. hashCode()和equals()的关系</h2><p>hashCode()用于获取哈希码，equals()用于比较两个对象是否相等：</p>
<ul>
<li>如果两个对象相等，则他们必须有相同的哈希码</li>
<li>如果他们两个对象有相同的哈希码，则它们未必相等，（比如set查找时）</li>
</ul>
<p><strong>PS：</strong>在Java中，Set接口代表无序的、元素不可重复的集合，HashSet则是Set接口的典型实现。</p>
<p>当向HashSet中加入一个元素时，它需要判断集合中是否已经包含了这个元素，从而避免重复存储。由于这个判断十分的频繁，所以要讲求效率，绝不能采用遍历集合逐个元素进行比较的方式。实际上，HashSet是通过获取对象的哈希码，以及调用对象的equals()方法来解决这个判断问题的。</p>
<p>HashSet首先会调用对象的hashCode()方法获取其哈希码，并通过哈希码确定该对象在集合中存放的位置。假设这个位置之前已经存了一个对象，则HashSet会调用equals()对两个对象进行比较。若相等则说明对象重复，此时不会保存新加的对象。若不等说明对象不重复，但是它们存储的位置发生了碰撞，此时HashSet会采用链式结构在同一位置保存多个对象，即将新加对象链接到原来对象的之后。之后，再有新添加对象也映射到这个位置时，就需要与这个位置中所有的对象进行equals()比较，若均不相等则将其链到最后一个对象之后。</p>
<h3 id="9-1-介绍一下hashCode"><a href="#9-1-介绍一下hashCode" class="headerlink" title="9.1 介绍一下hashCode()"></a>9.1 介绍一下hashCode()</h3><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数。</p>
<h3 id="9-2-为什么要有hashCode"><a href="#9-2-为什么要有hashCode" class="headerlink" title="9.2 为什么要有hashCode"></a>9.2 为什么要有hashCode</h3><p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。</p>
<p>但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p>
<h3 id="9-2-hashcode和equals的区别"><a href="#9-2-hashcode和equals的区别" class="headerlink" title="9.2 hashcode和equals的区别"></a>9.2 hashcode和equals的区别</h3><h4 id="1-hashcode"><a href="#1-hashcode" class="headerlink" title="1.hashcode"></a>1.hashcode</h4><p> Object 中的 hashCode 方法求的是对象的散列值，例如在set中，通过散列值去定位要存放的位置，两个相同对象的散列值一定相同，而散列值相同的对象不一定相等。可以通过hashcode可以初步判断两个对象是否相等。</p>
<h4 id="2-equals"><a href="#2-equals" class="headerlink" title="2.equals"></a>2.equals</h4><p>Object 类中的 equals 方法用于检测一个对象是否等于另外一个对象。在 Object 类中，这个方法将判断两个对象是否具有相同的引用。如果两个对象具有相同的引用，它们一定是相等的。</p>
<p>equals 方法的实现源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在大多数情况下这样的比较是没有意义的，因为对象的引用一般不相等，即使值相等。例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">u1.setName(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">u1.setAge(<span class="number">18</span>);</span><br><span class="line">		</span><br><span class="line"><span class="type">Person</span> <span class="variable">u2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">u1.setName(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">u1.setAge(<span class="number">18</span>);</span><br></pre></td></tr></table></figure>

<p>因此<strong>通常情况下，我们要判断两个对象是否相等，一定要重写 equals 方法</strong>。</p>
<h4 id="3-两者的区别"><a href="#3-两者的区别" class="headerlink" title="3.两者的区别"></a>3.两者的区别</h4><ul>
<li>如果两个对象 equals，Java 运行时环境会认为他们的 hashCode 一定相等。</li>
<li>如果两个对象不 equals，他们的 hashCode 有可能相等。</li>
<li>如果两个对象 hashCode 相等，他们不一定 equals。</li>
<li>如果两个对象 hashCode 不相等，他们一定不 equals</li>
</ul>
<h3 id="9-4-为什么重写equals方法必须要重写hashCode-方法？"><a href="#9-4-为什么重写equals方法必须要重写hashCode-方法？" class="headerlink" title="9.4 为什么重写equals方法必须要重写hashCode()方法？"></a>9.4 为什么重写equals方法必须要重写hashCode()方法？</h3><p><strong>判断的时候先根据hashcode进行的判断，相同的情况下再根据equals()方法进行判断。如果只重写了equals方法，而不重写hashcode的方法，会造成hashcode的值不同，直接跳过equals方法，而equals()方法判断出来的结果为true。</strong>例如我们在判断两个对象时，会根据对象的属性去判断是否相等，因此会修改equals方法，而在执行equals之前会先通过hashcode判断对象是否相等，对象通常是不相等的，那么就直接返回false，不会再执行equals了，所以我们也得修改haskcode方法，让其根据对象的属性去生成散列值。如下：对象1和对象2应该是相等的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 对象 1</span></span><br><span class="line"><span class="type">Persion</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Persion</span>();</span><br><span class="line">p1.setName(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">p1.setAge(<span class="number">18</span>);</span><br><span class="line"><span class="comment">// 对象 2</span></span><br><span class="line"><span class="type">Persion</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Persion</span>();</span><br><span class="line">p2.setName(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">p2.setAge(<span class="number">18</span>);</span><br></pre></td></tr></table></figure>

<p>重写两个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 引用相等返回 true</span></span><br><span class="line">        <span class="comment">// 如果等于 null，或者对象类型不同返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 强转为自定义 Persion 类型</span></span><br><span class="line">        <span class="type">Persion</span> <span class="variable">persion</span> <span class="operator">=</span> (Persion) o;</span><br><span class="line">        <span class="comment">// 如果 age 和 name 都相等，就返回 true</span></span><br><span class="line">        <span class="keyword">return</span> age == persion.age &amp;&amp;</span><br><span class="line">                Objects.equals(name, persion.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 对比 name 和 age 是否相等</span></span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-5-x3D-x3D-和equals"><a href="#9-5-x3D-x3D-和equals" class="headerlink" title="9.5 &#x3D;&#x3D; 和equals()"></a>9.5 &#x3D;&#x3D; 和equals()</h3><p><strong>&#x3D;&#x3D;运算符</strong>：</p>
<ul>
<li>作用于基本数据类型时，是比较两个数值是否相等；</li>
<li>作用于引用数据类型时，是比较两个对象的内存地址是否相同，即判断它们是否为同一个对象；</li>
</ul>
<p><strong>equals()方法</strong>：</p>
<ul>
<li>没有重写时，Object默认以 &#x3D;&#x3D; 来实现，即比较两个对象的内存地址是否相同；</li>
<li>进行重写后，一般会按照对象的内容来进行比较，若两个对象内容相同则认为对象相等，否则认为对象不等。</li>
</ul>
<h2 id="10-String、StringBuilder和StringBuffer的区别？"><a href="#10-String、StringBuilder和StringBuffer的区别？" class="headerlink" title="10. String、StringBuilder和StringBuffer的区别？"></a>10. <strong>String、StringBuilder和StringBuffer的区别？</strong></h2><ul>
<li><p><strong>String类</strong>是不可变类，即一旦一个String对象被创建以后，包含在这个对象中的字符序列是<strong>不可改变</strong>的，直至这个对象被销毁。</p>
<ul>
<li>字符串数组保存，不可变类，一旦创建，其值不可改变；常量，<strong>线程安全</strong>。</li>
<li>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。</li>
<li>字符串对象<strong>通过“+”的字符串拼接</strong>方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</li>
</ul>
</li>
<li><p><strong>StringBuffer</strong>对象则代表一个字符序列<strong>可变</strong>的字符串，当一个StringBuffer被创建以后，通过StringBuffer提供的append()、insert()、reverse()、setCharAt()、setLength()等方法可以改变这个字符串对象的字符序列。</p>
<ul>
<li><code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。</li>
<li><code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，StringBuffer是<strong>线程安全</strong>的。</li>
<li>一旦通过StringBuffer生成了最终想要的字符串，就可以调用它的toString()方法将其转换为一个String对象。</li>
</ul>
</li>
<li><p><strong>StringBuffer</strong>、<strong>StringBuilder</strong>都代表可变的字符串对象，它们有共同的父类 AbstractStringBuilder，并且两个类的构造方法和成员方法也基本相同。</p>
<ul>
<li>StringBuilder是<strong>非线程安全</strong>的，所以StringBuilder性能略高。</li>
<li>一般情况下，要创建一个内容可变的字符串，建议优先考虑<strong>StringBuilder</strong>类。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</li>
</ul>
</li>
<li><p><strong>对于三者使用的总结：</strong></p>
<ul>
<li>操作少量的数据: 适用 <code>String</code></li>
<li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li>
<li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li>
</ul>
</li>
<li><p><strong>String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？</strong></p>
<p>会创建 <strong>1 或 2</strong> 个字符串对象。</p>
<ul>
<li>如果字符串常量池中不存在字符串对象“abc”的引用，那么会在堆中创建 1 个字符串对象“abc”，常量池中创建一个对象“abc”。</li>
<li>如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”</li>
</ul>
</li>
<li><p><strong>intern 方法有什么作用?</strong></p>
<p><code>String.intern()</code> 是一个 native（本地）方法，其作用是<strong>将指定的字符串对象的引用保存在字符串常量池中</strong>，可以简单分为两种情况：</p>
<ul>
<li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</li>
<li>如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。</li>
</ul>
</li>
</ul>
<h2 id="11-接口和抽象类"><a href="#11-接口和抽象类" class="headerlink" title="11. 接口和抽象类"></a>11. 接口和抽象类</h2><h3 id="11-1-对比"><a href="#11-1-对比" class="headerlink" title="11.1 对比"></a>11.1 对比</h3><ul>
<li><strong>接口</strong>体现的是一种规范。接口规定了实现者必须向外提供哪些服务，以及如何调用这些服务。一个程序中使用接口时，接口是多个模块间的耦合标准；当在多个应用程序之间使用接口时，接口是多个程序之间的通信标准。<ul>
<li>接口中只能包含静态常量、方法（抽象实例方法、类方法、默认方法或私有方法）、内部类（包括内部类、枚举）。</li>
</ul>
</li>
<li><strong>抽象类</strong>体现的是一种模板式设计。抽象方法只能在抽象类中定义。</li>
</ul>
<p><strong>区别：</strong></p>
<ul>
<li>接口不能含有普通方法；抽象类可以。</li>
<li>接口只能定义静态常量；抽象类可以非静态，也可以定义静态。</li>
<li>接口不能含有构造器；抽象类可以有，但是目的是让其子类调用构造器来完成抽象类的初始化操作。</li>
<li>抽象类最多只能有一个父类；但一个类可以直接实现多个接口，通过实现多个接口可以弥补单继承的不足。</li>
</ul>
<p><strong>共同点：</strong></p>
<ul>
<li>都不能被实例化，都位于继承树的顶端</li>
<li>都可以包含<strong>抽象方法</strong>。</li>
<li>都可以有默认实现的方法（Java 8 可以用 <code>default</code> 关键在接口中定义默认方法）。</li>
</ul>
<h3 id="11-2-抽象类是否可以继承实体类（具体类）"><a href="#11-2-抽象类是否可以继承实体类（具体类）" class="headerlink" title="11.2 抽象类是否可以继承实体类（具体类）"></a>11.2 抽象类是否可以继承实体类（具体类）</h3><p>可以继承，前提是实体类必须有明确的构造函数。</p>
<h3 id="11-3-抽象类是否可以实现接口"><a href="#11-3-抽象类是否可以实现接口" class="headerlink" title="11.3 抽象类是否可以实现接口"></a>11.3 抽象类是否可以实现接口</h3><p>但是抽象类实现接口，可以完全覆盖&#x2F;重写 接口中的方法，也可只重写接口中的某几个方法子类在继承抽象类时，子类重写的方法即为抽象类中未重写接口中的方法。在Java中，使用抽象类来实现接口，并不是毫无作用。相反，有时间有很大的作用。</p>
<p> 当你只想实现接口中的个别方法（不是所有方法）时，你可以先写一个抽象类来实现该接口，并实现除了你想要的方法之外的所有方法（方法体为空）。接着再用你的类继承这个抽象类，这个类中就只用实现你需要的方法了，这样就可以达到你的需要了。但是，如果你直接实现接口的话，你就需要实现接口的所有方法。</p>
<h2 id="12-Java的异常机制"><a href="#12-Java的异常机制" class="headerlink" title="12. Java的异常机制"></a>12. Java的异常机制</h2><ul>
<li>异常处理：try，catch，finally</li>
<li>抛出异常 throw：系统会自动抛出异常。也可以主动抛出异常。</li>
<li>异常跟踪栈：异常机制会导致异常在方法之间传播。</li>
<li>异常接口：<ul>
<li>Error：错误。无法恢复、不可捕获。</li>
<li>Exception：异常。<ul>
<li>Cheched异常。——都是可以被处理的异常</li>
<li>Runtime异常。——所有RuntimeException类及其子类的实例都称为Runtime异常，其他都是Checked异常。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="12-1-Error-和-Exception-区别是什么？"><a href="#12-1-Error-和-Exception-区别是什么？" class="headerlink" title="12.1 Error 和 Exception 区别是什么？"></a>12.1 Error 和 Exception 区别是什么？</h3><p>Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。 Throwable 类有两个<br>重要的子类 Exception（异常）和 Error（错误）。</p>
<p>Exception 和 Error 二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p>
<ul>
<li><strong>Exception</strong> ：程序本身可以处理的异常，可以通过 catch 来进行捕获，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。 Exception 又可以分为运行时异常(RuntimeException, 又叫非受检查异常)和非运行时异常(又叫受检查异常) 。</li>
<li><strong>Error</strong> ：属于程序无法处理的错误 ，我们没办法通过 catch 来进行捕获 。例如，系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复。</li>
</ul>


<h3 id="12-1-非受检查异常-运行时异常-和受检查异常-非运行时异常-的区别？"><a href="#12-1-非受检查异常-运行时异常-和受检查异常-非运行时异常-的区别？" class="headerlink" title="12.1 非受检查异常(运行时异常)和受检查异常(非运行时异常)的区别？"></a>12.1 非受检查异常(运行时异常)和受检查异常(非运行时异常)的区别？</h3><p><strong>区别</strong>：<strong>是否强制要求调用者必须处理此异常</strong>，如果强制要求调用者必须进行处理，那么就使用受检查异常，否则就选择非受检查异常。</p>
<p><strong>运行时异常</strong>：包括 RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。 Java 编译器不会检查运行时异常。例如： NullPointException(空指针) 、 NumberFormatException（字符串转换为数字） 、 IndexOutOfBoundsException(数组越界) 、 ClassCastException(类转换异常) 、ArrayStoreException(数据存储异常，操作数组时类型不一致) 等。</p>
<p><strong>非运行时异常</strong>：是Exception 中除 RuntimeException 及其子类之外的异常。 Java 编译器会检查非运行时异常。常见的受检查异常有： IO 相关的异常、 ClassNotFoundException 、 SQLException 等。</p>
<h3 id="12-3-throw-和-throws-的区别是什么？"><a href="#12-3-throw-和-throws-的区别是什么？" class="headerlink" title="12.3 throw 和 throws 的区别是什么？"></a>12.3 throw 和 throws 的区别是什么？</h3><p>Java 中的异常处理除了包括捕获异常和处理异常之外，还包括声明异常和拋出异常，可以通过 throws关键字在方法上声明该方法要拋出的异常，或者在方法内部通过 throw 拋出异常对象。</p>
<p><strong>在使用上的几点区别如下</strong>：</p>
<ul>
<li><strong>throw</strong> 关键字用在方法内部，只能用于抛出一种异常，用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。</li>
<li><strong>throws</strong> 关键字用在方法声明上，可以抛出多个异常，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。</li>
</ul>
<h3 id="12-4-NoClassDefFoundError-和ClassNotFoundException-区别？"><a href="#12-4-NoClassDefFoundError-和ClassNotFoundException-区别？" class="headerlink" title="12.4 NoClassDefFoundError 和ClassNotFoundException 区别？"></a>12.4 NoClassDefFoundError 和ClassNotFoundException 区别？</h3><p><strong>NoClassDefFoundError</strong> 是一个 Error 类型的异常，是由 JVM 引起的，不应该尝试捕获这个异常。引起该异常的原因是 JVM 或 ClassLoader 尝试<strong>加载某类时在内存中找不到该类的定义</strong>，该动作发生在运行期间，即编译时该类存在，但是在运行时却找不到了，可能是变异后被删除了等原因导致。</p>
<p><strong>ClassNotFoundException</strong> 是一个受检查异常，需要显式地使用 try-catch 对其进行捕获和处理，或在方法签名中用 throws 关键字进行声明。当使用 Class.forName, ClassLoader.loadClass 或<br>ClassLoader.findSystemClass 动态加载类到内存的时候，通过<strong>传入的类路径参数没有找到该类</strong>，就会抛出该异常；另一种抛出该异常的可能原因是某个类已经由一个类加载器加载至内存中，另一个加载器又尝试去加载它。</p>
<h3 id="12-5-JVM是如何处理异常的？"><a href="#12-5-JVM是如何处理异常的？" class="headerlink" title="12.5 JVM是如何处理异常的？"></a>12.5 JVM是如何处理异常的？</h3><p>在一个方法中如果发生异常，这个方法<strong>会创建一个异常对象，并转交给 JVM</strong>，（该异常对象包含异常名称，异常描述以及异常发生时应用程序的状态）。创建异常对象并转交给 JVM 的过程称为<strong>抛出异常</strong>。可能有一系列的方法调用，最终才进入抛出异常的方法，这一系列方法调用的有序列表叫做<strong>调用栈</strong>。</p>
<p>JVM 会顺着调用栈去查找看是否有可以处理异常的代码，如果有，则调用异常处理代码。当 JVM 发现可以处理异常的代码时，会把发生的异常传递给它。如果 JVM 没有找到可以处理该异常的代码块，JVM 就会将该异常转交给默认的异常处理器（默认处理器为 JVM 的一部分），默认异常处理器打印出异常信息并终止应用程序。</p>
<h2 id="13-泛型"><a href="#13-泛型" class="headerlink" title="13. 泛型"></a>13. 泛型</h2><p>把一个对象丢进Java集合之后，集合会忘记这个对象的数据类型，再取出来时该对象就变成了Object类型。有这么两个缺点：1）每次使用时都需要强制转换成想要的类型；2）在编译时编译器并不知道类型转换是否正常，运行时才知道，不安全。</p>
<p>Java5开始，就引入了“参数化类型”的概念，允许程序在创建集合是时指定集合元素的类型，Java的参数化类型被称为“泛型”。</p>
<ul>
<li>泛型擦除：把一个具有泛型信息的对象赋给另一个没有泛型信息的变量时，所有尖括号之间的类型信息都会被扔掉。</li>
</ul>
<h2 id="14-Java反射机制"><a href="#14-Java反射机制" class="headerlink" title="14. Java反射机制"></a>14. Java反射机制</h2><p>Java程序中的对象在运行时可以表现出两种类型：编译时类型和运行时类型。</p>
<p>有时，程序在运行时接收到外部传入的一个对象，该对象编译时类型是Object，但程序又需要调用该对象的运行时类型的方法。这就要求程序需要在运行时发现对象和类的真实信息，有两个办法：</p>
<ul>
<li>第一种做法是加上在编译时和运行时都完全知道类型的具体信息，可以先使用instanceof判断，然后进行强制类型转换。</li>
<li>否则就必须要使用<strong>反射</strong>。<strong>反射赋予了我们在运行时分析类以及执行类中方法的能力。</strong>通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。</li>
</ul>
<h3 id="14-1-反射的应用场景："><a href="#14-1-反射的应用场景：" class="headerlink" title="14.1 反射的应用场景："></a>14.1 反射的应用场景：</h3><ul>
<li>JDBC时，创建数据库的连接，需要先通过反射机制加载数据库的驱动程序。</li>
<li>框架的注解&#x2F;XML配置，从配置中解析出的时字符串，需要利用反射机制实例化。</li>
<li>AOP。在运行时创建目标对象的代理类。</li>
</ul>
<h3 id="14-2-获取-Class-对象的四种方式"><a href="#14-2-获取-Class-对象的四种方式" class="headerlink" title="14.2 获取 Class 对象的四种方式"></a>14.2 获取 Class 对象的四种方式</h3><p><strong>1. 知道具体类的情况下可以使用：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass</span> <span class="operator">=</span> TargetObject.class;</span><br></pre></td></tr></table></figure>

<p>但是我们一般是不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象，通过此方式获取 Class 对象不会进行初始化</p>
<p><strong>2. 通过 <code>Class.forName()</code>传入类的全路径获取：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>3. 通过对象实例<code>instance.getClass()</code>获取：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TargetObject</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TargetObject</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass2</span> <span class="operator">=</span> o.getClass();</span><br></pre></td></tr></table></figure>

<p><strong>4. 通过类加载器<code>xxxClassLoader.loadClass()</code>传入类路径获取:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> ClassLoader.loadClass(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>通过类加载器获取 Class 对象不会进行初始化，意味着不进行包括初始化等一系列步骤，静态代码块和静态对象不会得到执行。</p>
<h2 id="15-Java的代理模式"><a href="#15-Java的代理模式" class="headerlink" title="15. Java的代理模式"></a>15. Java的代理模式</h2><p>使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</p>
<p>代理模式有<strong>静态代理</strong>和<strong>动态代理</strong>两种实现方式。</p>
<h3 id="15-1-静态代理"><a href="#15-1-静态代理" class="headerlink" title="15.1 静态代理"></a>15.1 静态代理</h3><p>从 JVM 层面来说， 静态代理在<strong>编译时</strong>就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。</p>
<p><strong>静态代理实现步骤:</strong></p>
<ol>
<li>定义一个接口及其实现类；</li>
<li>创建一个代理类同样实现这个接口</li>
<li>将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</li>
</ol>
<h3 id="15-2-动态代理"><a href="#15-2-动态代理" class="headerlink" title="15.2 动态代理"></a>15.2 动态代理</h3><p>从 JVM 角度来说，动态代理是在<strong>运行时</strong>动态生成类字节码，并加载到 JVM 中的。</p>
<h4 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="- JDK 动态代理"></a>- JDK 动态代理</h4><p>​	在 Java 动态代理机制中 <code>InvocationHandler</code> 接口和 <code>Proxy</code> 类是核心。只能代理实现了接口的类。</p>
<p><strong>步骤：</strong></p>
<ol>
<li>定义一个接口及其实现类；</li>
<li>自定义 <code>InvocationHandler</code> 并重写<code>invoke</code>方法，在 <code>invoke</code> 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；</li>
<li>通过 <code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code> 方法创建代理对象；</li>
</ol>
<h4 id="CGLIB-动态代理"><a href="#CGLIB-动态代理" class="headerlink" title="- CGLIB 动态代理"></a>- CGLIB 动态代理</h4><p>JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。</p>
<p>在 CGLIB 动态代理机制中 <code>MethodInterceptor</code> 接口和 <code>Enhancer</code> 类是核心。</p>
<p><strong>步骤：</strong></p>
<ol>
<li>定义一个类；</li>
<li>自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法，和 JDK 动态代理中的 <code>invoke</code> 方法类似；</li>
<li>通过 <code>Enhancer</code> 类的 <code>create()</code>创建代理类；</li>
</ol>
<h4 id="JDK代理和CGLib代理的区别"><a href="#JDK代理和CGLib代理的区别" class="headerlink" title="- JDK代理和CGLib代理的区别"></a>- JDK代理和CGLib代理的区别</h4><ol>
<li><strong>JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。</strong> 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</li>
<li>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</li>
</ol>
<h3 id="15-3-静态代理和动态代理的对比"><a href="#15-3-静态代理和动态代理的对比" class="headerlink" title="15.3 静态代理和动态代理的对比"></a>15.3 静态代理和动态代理的对比</h3><ol>
<li><strong>灵活性</strong> ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</li>
<li><strong>JVM 层面</strong> ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</li>
</ol>
<h2 id="16-序列化与反序列化"><a href="#16-序列化与反序列化" class="headerlink" title="16. 序列化与反序列化"></a>16. 序列化与反序列化</h2><p>序列化机制可以将对象转换成字节序列，这些字节序列可以保存在磁盘上，也可以在网络中传输，并允许程序将这些字节序列再次恢复成原来的对象。</p>
<p>对象的<strong>序列化</strong>是指 将数据结构或对象转换成二进制字节流的过程。</p>
<p>对象的<strong>反序列化</strong>是指 将在序列化过程中所生成的二进制字节流的过程转换成数据结构或者对象的过程。</p>
<p>如果对象要支持序列化机制，则它的类需要实现Serializable接口，该接口是一个标记接口，并没有提供任何方法，只是标明该类是可以序列化的。如果要实现序列化，则需要使用对象流的一些方法。</p>
<p><strong>两种序列化方式</strong>：</p>
<img src="/2022/10/05/Java%E5%9F%BA%E7%A1%80/Untitled.png" class="">

<p><strong>SerialVersionUID代表序列化的版本</strong>，通过定义类的序列化版本。Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。</p>
<h3 id="1）为什么要显示指定serialVersionUID的值？"><a href="#1）为什么要显示指定serialVersionUID的值？" class="headerlink" title="1）为什么要显示指定serialVersionUID的值？"></a>1）为什么要显示指定serialVersionUID的值？</h3><p>如果不显示指定serialVersionUID, JVM在序列化时会根据属性自动生成一个serialVersionUID, 然后与属性一起序列化, 再进行持久化或网络传输. 在反序列化时, JVM会再根据属性自动生成一个新版serialVersionUID, 然后将这个新版serialVersionUID与序列化时生成的旧版serialVersionUID进行比较,如果相同则反序列化成功, 否则报错。</p>
<p>如果显示指定了, JVM在序列化和反序列化时仍然都会生成一个serialVersionUID, 但值为我们显示指定的值, 这样在反序列化时新旧版本的serialVersionUID就一致了.</p>
<p><strong>在实际开发中, 不显示指定serialVersionUID的会导致什么问题?</strong> 如果我们的类写完后不再修改, 那当然不会有问题, 但这在实际开发中是不可能的, 我们的类会不断迭代, 一旦类被修改了, 那旧对象反序列化就会报错. 所以在实际开发中, 我们都会显示指定一个serialVersionUID, 值是多少无所谓, 只要不变就行。</p>
<h3 id="2）Java序列化中如果有的字段不想进行序列化，怎么办？"><a href="#2）Java序列化中如果有的字段不想进行序列化，怎么办？" class="headerlink" title="2）Java序列化中如果有的字段不想进行序列化，怎么办？"></a>2）Java序列化中如果有的字段不想进行序列化，怎么办？</h3><p>对于不想进行序列化的变量，使用 <strong>transient</strong> 关键字修饰。<br>transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后， transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。transient 只能修饰变量，不能修饰类和方法。</p>
<h3 id="3）静态变量会被序列化吗"><a href="#3）静态变量会被序列化吗" class="headerlink" title="3）静态变量会被序列化吗?"></a>3）静态变量会被序列化吗?</h3><p><strong>不会</strong>。因为<strong>序列化是针对对象</strong>而言的, 而静态变量优先于对象存在, 随着类的加载而加载, 所以不会被序列化。<br>看到这个结论, 是不是有人会问, **serialVersionUID也被static修饰, 为什么serialVersionUID会被序列化?**其实serialVersionUID属性并没有被序列化, JVM在序列化对象时会自动生成一个serialVersionUID, 然后将我们显示指定的serialVersionUID属性值赋给自动生成的serialVersionUID。</p>
<h3 id="4）实际开发中有哪些用到序列化和反序列化的场景？"><a href="#4）实际开发中有哪些用到序列化和反序列化的场景？" class="headerlink" title="4）实际开发中有哪些用到序列化和反序列化的场景？"></a>4）实际开发中有哪些用到序列化和反序列化的场景？</h3><ul>
<li><p>对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</p>
</li>
<li><p>将对象存储到文件中的时候需要进行序列化，将对象从文件中读取出来需要进行反序列化。</p>
</li>
<li><p>将对象存储到缓存数据库（如 Redis）时需要用到序列化，将对象从缓存数据库中读取出来需要反序列化</p>
</li>
</ul>
<h2 id="17-Java-中-IO-流"><a href="#17-Java-中-IO-流" class="headerlink" title="17. Java 中 IO 流"></a>17. Java 中 IO 流</h2><ul>
<li><p>分类</p>
<ul>
<li><p>按照流的流向分，可以分为输入流和输出流；</p>
</li>
<li><p>按照操作单元划分，可以划分为字节流和字符流；</p>
</li>
<li><p>按照流的角色划分为节点流和处理流。</p>
</li>
</ul>
</li>
<li><p>Java IO 流的 40 多个类都是从4 个抽象类基类中派生出来的。</p>
<ul>
<li>InputStream &#x2F; Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li>OutputStream &#x2F; Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
</li>
</ul>
<h3 id="既然有了字节流-为什么还要有字符流"><a href="#既然有了字节流-为什么还要有字符流" class="headerlink" title="既然有了字节流,为什么还要有字符流?"></a>既然有了字节流,为什么还要有字符流?</h3><p><del>（问题本质想问：<strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I&#x2F;O 流操作要分为字节流操作和字符流操作呢？</strong>）</del></p>
<p><strong>回答</strong>：字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I&#x2F;O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p>
<p><strong>按操作方式分类结构图：</strong></p>
<img src="/2022/10/05/Java%E5%9F%BA%E7%A1%80/IO-%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F%E5%88%86%E7%B1%BB.png" class="">

<p>按操作对象分类结构图：</p>
<img src="/2022/10/05/Java%E5%9F%BA%E7%A1%80/IO-%E6%93%8D%E4%BD%9C%E5%AF%B9%E8%B1%A1%E5%88%86%E7%B1%BB.png" class="">

<h2 id="18-String类有哪些方法？"><a href="#18-String类有哪些方法？" class="headerlink" title="18. String类有哪些方法？"></a>18. String类有哪些方法？</h2><ul>
<li>char charAt(int index)：返回指定索引处的字符；</li>
<li>String substring(int beginIndex, int endIndex)：从此字符串中截取出一部分子字符串；</li>
<li>String[] split(String regex)：以指定的规则将此字符串分割成数组；</li>
<li>String trim()：删除字符串前导和后置的空格；</li>
<li>int indexOf(String str)：返回子串在此字符串首次出现的索引；</li>
<li>int lastIndexOf(String str)：返回子串在此字符串最后出现的索引；</li>
<li>boolean startsWith(String prefix)：判断此字符串是否以指定的前缀开头；</li>
<li>boolean endsWith(String suffix)：判断此字符串是否以指定的后缀结尾；</li>
<li>String toUpperCase()：将此字符串中所有的字符大写；</li>
<li>String toLowerCase()：将此字符串中所有的字符小写；</li>
<li>String replaceFirst(String regex, String replacement)：用指定字符串替换第一个匹配的子串；</li>
<li>String replaceAll(String regex, String replacement)：用指定字符串替换所有的匹配的子串。</li>
</ul>
<h3 id="String可以被继承吗？"><a href="#String可以被继承吗？" class="headerlink" title="String可以被继承吗？"></a>String可以被继承吗？</h3><p>String类由final修饰，所以不能被继承。</p>
<p>在Java中，String类被设计为不可变类，主要表现在它保存字符串的成员变量是final的。</p>
<ul>
<li>Java 9之前字符串采用char[]数组来保存字符，即 private final char[] value；</li>
<li>Java 9做了改进，采用byte[]数组来保存字符，即 private final byte[] value；</li>
</ul>
<p>之所以要把String类设计为不可变类，主要是出于安全和性能的考虑，可归纳为如下4点。</p>
<ul>
<li>由于字符串无论在任何 Java 系统中都广泛使用，会用来存储敏感信息，如账号，密码，网络路径，文件处理等场景里，保证字符串 String 类的安全性就尤为重要了，如果字符串是可变的，容易被篡改，那我们就无法保证使用字符串进行操作时，它是安全的，很有可能出现 SQL 注入，访问危险文件等操作。</li>
<li>在多线程中，只有不变的对象和值是线程安全的，可以在多个线程中共享数据。由于 String 天然的不可变，当一个线程”修改“了字符串的值，只会产生一个新的字符串对象，不会对其他线程的访问产生副作用，访问的都是同样的字符串数据，不需要任何同步操作。</li>
<li>字符串作为基础的数据结构，大量地应用在一些集合容器之中，尤其是一些散列集合，在散列集合中，存放元素都要根据对象的 hashCode() 方法来确定元素的位置。由于字符串 hashcode 属性不会变更，保证了唯一性，使得类似 HashMap，HashSet 等容器才能实现相应的缓存功能。由于 String 的不可变，避免重复计算 hashcode，只要使用缓存的 hashcode 即可，这样一来大大提高了在散列集合中使用 String 对象的性能。</li>
<li>当字符串不可变时，字符串常量池才有意义。字符串常量池的出现，可以减少创建相同字面量的字符串，让不同的引用指向池中同一个字符串，为运行时节约很多的堆内存。若字符串可变，字符串常量池失去意义，基于常量池的 String.intern() 方法也失效，每次创建新的字符串将在堆内开辟出新的空间，占据更多的内存。</li>
</ul>
<p>因为要保证String类的不可变，那么将这个类定义为final的就很容易理解了。如果没有final修饰，那么就会存在String的子类，这些子类可以重写String类的方法，强行改变字符串的值，这便违背了String类设计的初衷。</p>
<h2 id="19-深拷贝、浅拷贝、引用拷贝？"><a href="#19-深拷贝、浅拷贝、引用拷贝？" class="headerlink" title="19. 深拷贝、浅拷贝、引用拷贝？"></a>19. 深拷贝、浅拷贝、引用拷贝？</h2><ul>
<li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说<strong>拷贝对象和原对象共用同一个内部对象</strong>。</li>
<li><strong>深拷贝</strong> ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。拷贝对象和原对象已经不是同一个对象。</li>
<li><strong>引用拷贝</strong>：引用拷贝就是两个不同的引用指向同一个对象。</li>
</ul>


<h3 id="碰到的具体例子"><a href="#碰到的具体例子" class="headerlink" title="碰到的具体例子"></a>碰到的具体例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lists.add(list)和lists.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>＜＞(list))</span><br><span class="line">res.add(list)为浅拷贝，res中添加的都是list这个内存地址的引用，后续list内容的变化会导致res的变化，在原来地址改变数据，内容肯定会被改变</span><br><span class="line">res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(list))为深拷贝，每次添加lisi，都为list对象开辟一个新地址，存放的内容为list链表，所以后续不会被影响。    </span><br></pre></td></tr></table></figure>

<h2 id="20-面向对象的原则"><a href="#20-面向对象的原则" class="headerlink" title="20.面向对象的原则"></a>20.面向对象的原则</h2><p>单一职责原则（SRP） 、开放封闭原则（OCP）  、里氏替换原则（LSP）、  依赖倒置原则（DIP）、  接口隔离原则（ISP）、迪米特法则（Law Of Demeter）、组合&#x2F;聚合复用原则（Composite&#x2F;Aggregate Reuse Principle CARP）</p>
<p><strong>1. 单一职责原则（Single Responsibility Principle）</strong></p>
<p>每一个类应该专注于做一件事情。可以降低类的复杂度，一个类只负责一项职责。</p>
<p><strong>2. 里氏替换原则（Liskov Substitution Principle）</strong></p>
<p>超类存在的地方，子类是可以替换的。在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</p>
<p>使用里氏替换原则时需要注意，子类必须实现父类中声明的所有方法。尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。</p>
<p>从大局看Java的多态就属于这个原则。</p>
<p><strong>3. 依赖倒置原则（Dependence Inversion Principle）</strong></p>
<p>实现尽量依赖抽象，不依赖具体实现。具体依赖抽象，上层依赖下层。假设B是较A低的模块，但B需要使用到A的功能，这个时候，B不应当直接使用A中的具体类；而应当由B定义一抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口；这样就达到了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。</p>
<p>采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，减少并行开发引起的风险，提高代码的可读性和可维护性。</p>
<p>从大局看Java的多态就属于这个原则。</p>
<p><strong>4. 接口隔离原则（Interface Segregation Principle）</strong></p>
<p>应当为客户端提供尽可能小的单独的接口，而不是提供大的总的接口。也就是要为各个类建立专用的接口，否则类在实现接口时，会实现一些用不到的方法。</p>
<p><strong>5. 迪米特法则（Law Of Demeter）</strong></p>
<p>又叫最少知识原则，一个软件实体应当尽可能少的与其他实体发生相互作用。在一个类里，能少用多少其他类就少用多少。</p>
<p><strong>6. 开闭原则（Open Close Principle）</strong></p>
<p>面向扩展开放，面向修改关闭。意味着有新的需求或变化时，不需要修改源代码，可以对现有代码进行扩展，以适应新的情况。</p>
<p><strong>7. 组合&#x2F;聚合复用原则（Composite&#x2F;Aggregate Reuse Principle CARP）</strong></p>
<p>尽量使用合成&#x2F;聚合达到复用，尽量少用继承。原则： 一个类中有另一个类的对象。</p>
<h2 id="21-子类能否可以重写父类中的静态方法"><a href="#21-子类能否可以重写父类中的静态方法" class="headerlink" title="21.子类能否可以重写父类中的静态方法"></a>21.子类能否可以重写父类中的静态方法</h2><p>不可以，子类重写的方法不会覆盖父类的方法，二者之间仍然独立。</p>
<p>Fu a &#x3D; new Zi();</p>
<p>通过a调用的方法还是父类的方法。</p>
<p>静态方法属于类，在编译阶段类被加载时，类的静态方法或者属性就会被分配内存，存储到类所在的内存中（堆内存的方法区中）；而类的非静态方法却是属于对象的，每个对象都有一份非静态方法的引用，并且若方法被重写，引用的就是子类重写的方法，且这是在运行时创建；</p>
<p>因此：</p>
<p><strong>一个父类的变量，指向子类的对象，调用一个被子类重写的静态方法时，由于这是一个父类的变量，并且静态方法属于类，所以在调用时，JVM会去父类所在的内存中寻找这个方法，所以最终的结果就是调用父类的方法，而不是子类重写的方法。</strong></p>
<h2 id="22-I-x2F-O"><a href="#22-I-x2F-O" class="headerlink" title="22.I&#x2F;O"></a>22.I&#x2F;O</h2><h3 id="22-1-何为-I-x2F-O"><a href="#22-1-何为-I-x2F-O" class="headerlink" title="22.1 何为 I&#x2F;O?"></a>22.1 何为 I&#x2F;O?</h3><p>I&#x2F;O（<strong>I</strong>nput&#x2F;<strong>O</strong>utpu） 即<strong>输入／输出</strong> 。</p>
<p><strong>我们先从计算机结构的角度来解读一下 I&#x2F;O。</strong></p>
<p>根据冯.诺依曼结构，计算机结构分为 5 大部分：运算器、控制器、存储器、输入设备、输出设备。</p>
<img src="/2022/10/05/Java%E5%9F%BA%E7%A1%80/20.jpeg" class="">

<p>输入设备（比如键盘）和输出设备（比如显示器）都属于外部设备。网卡、硬盘这种既可以属于输入设备，也可以属于输出设备。</p>
<p>输入设备向计算机输入数据，输出设备接收计算机输出的数据。</p>
<p><strong>从计算机结构的视角来看的话， I&#x2F;O 描述了计算机系统与外部设备之间通信的过程。</strong></p>
<p><strong>我们再先从应用程序的角度来解读一下 I&#x2F;O。</strong></p>
<p>根据大学里学到的操作系统相关的知识：为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 <strong>用户空间（User space）</strong> 和 <strong>内核空间（Kernel space ）</strong> 。</p>
<p>像我们平常运行的应用程序都是运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如文件管理、进程通信、内存管理等等。也就是说，我们想要进行 IO 操作，一定是要依赖内核空间的能力。</p>
<p>并且，用户空间的程序不能直接访问内核空间。</p>
<p>当想要执行 IO 操作时，由于没有执行这些操作的权限，只能发起系统调用请求操作系统帮忙完成。</p>
<p>因此，用户进程想要执行 IO 操作的话，必须通过 <strong>系统调用</strong> 来间接访问内核空间</p>
<p>我们在平常开发过程中接触最多的就是 <strong>磁盘 IO（读写文件）</strong> 和 <strong>网络 IO（网络请求和响应）</strong>。</p>
<p><strong>从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。</strong></p>
<p>当应用程序发起 I&#x2F;O 调用后，会经历两个步骤：</p>
<ol>
<li>内核等待 I&#x2F;O 设备准备好数据</li>
<li>内核将数据从内核空间拷贝到用户空间。</li>
</ol>
<h3 id="22-2-Java-中-3-种常见-IO-模型"><a href="#22-2-Java-中-3-种常见-IO-模型" class="headerlink" title="22.2 Java 中 3 种常见 IO 模型"></a>22.2 Java 中 3 种常见 IO 模型</h3><h4 id="1-BIO-Blocking-I-x2F-O"><a href="#1-BIO-Blocking-I-x2F-O" class="headerlink" title="1.BIO (Blocking I&#x2F;O)"></a>1.BIO (Blocking I&#x2F;O)</h4><p><strong>BIO 属于同步阻塞 IO 模型</strong> 。</p>
<p>同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。</p>
<img src="/2022/10/05/Java%E5%9F%BA%E7%A1%80/6.image" class="">

<p>在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I&#x2F;O 处理模型来应对更高的并发量。</p>
<h4 id="2-NIO-Non-blocking-x2F-New-I-x2F-O"><a href="#2-NIO-Non-blocking-x2F-New-I-x2F-O" class="headerlink" title="2.NIO (Non-blocking&#x2F;New I&#x2F;O)"></a>2.NIO (Non-blocking&#x2F;New I&#x2F;O)</h4><p>Java 中的 NIO 于 Java 1.4 中引入，对应 <code>java.nio</code> 包，提供了 <code>Channel</code> , <code>Selector</code>，<code>Buffer</code> 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它是支持面向缓冲的，基于通道的 I&#x2F;O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。</p>
<p>Java 中的 NIO 可以看作是 <strong>I&#x2F;O 多路复用模型</strong>。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。</p>
<p><strong>同步非阻塞 IO 模型</strong>。</p>
<img src="/2022/10/05/Java%E5%9F%BA%E7%A1%80/bb.image" class="">

<p>同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</p>
<p>相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。</p>
<p>但是，这种 IO 模型同样存在问题：<strong>应用程序不断进行 I&#x2F;O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</strong></p>
<p>这个时候，<strong>I&#x2F;O 多路复用模型</strong> 就上场了。</p>
<img src="/2022/10/05/Java%E5%9F%BA%E7%A1%80/88.image" class="">

<p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -&gt; 用户空间）还是阻塞的。</p>
<blockquote>
<p>目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，目前几乎在所有的操作系统上都有支持。</p>
<ul>
<li><strong>select 调用</strong> ：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。</li>
<li><strong>epoll 调用</strong> ：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。</li>
</ul>
</blockquote>
<p><strong>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。</strong></p>
<p>Java 中的 NIO ，有一个非常重要的<strong>选择器 ( Selector )</strong> 的概念，也可以被称为 <strong>多路复用器</strong>。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。</p>
<h4 id="3-AIO-Asynchronous-I-x2F-O"><a href="#3-AIO-Asynchronous-I-x2F-O" class="headerlink" title="3.AIO (Asynchronous I&#x2F;O)"></a>3.AIO (Asynchronous I&#x2F;O)</h4><p>AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。</p>
<p>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p>
<img src="/2022/10/05/Java%E5%9F%BA%E7%A1%80/30.image" class="">

<p>总结</p>
<img src="/2022/10/05/Java%E5%9F%BA%E7%A1%80/33.png" class="">

<h2 id="23-NIO的零拷贝"><a href="#23-NIO的零拷贝" class="headerlink" title="23.NIO的零拷贝"></a>23.NIO的零拷贝</h2><h3 id="23-1-传统IO"><a href="#23-1-传统IO" class="headerlink" title="23.1 传统IO"></a>23.1 传统IO</h3><p>传统IO读取数据并通过网络发送的流程，如下图</p>
<img src="/2022/10/05/Java%E5%9F%BA%E7%A1%80/640.jfif" class="">

<p>磁盘到内核空间属于DMA拷贝，用户空间与内核空间之间的数据传输并没有类似DMA这种可以不需要CPU参与的传输方式，因此用户空间与内核空间之间的数据传输是需要CPU全程参与的。</p>
<ol>
<li>read()调用导致上下文从用<strong>户态切换到内核态</strong>。内核通过sys_read()（或等价的方法）从文件读取数据。DMA引擎执行第一次拷贝：<strong>从文件读取数据并存储到内核空间的缓冲区</strong>。（<strong>第一次上下文切换和拷贝</strong>）</li>
<li>请求的数据<strong>从内核的读缓冲区拷贝到用户缓冲区</strong>，然后read()方法返回。read()方法返回导致上下文从<strong>内核态切换到用户态</strong>。现在待读取的数据已经存储在用户空间内的缓冲区。至此，完成了一次IO的读取过程。（<strong>第二次上下文切换和拷贝</strong>）</li>
<li>send()调用导致上下文从<strong>用户态切换到内核态</strong>。第三次拷贝数据从<strong>用户空间重新拷贝到内核空间缓冲区</strong>。但是，这一次，数据被写入一个不同的缓冲区，一个与目标套接字相关联的缓冲区。（<strong>第三次上下文切换和拷贝</strong>）</li>
<li>send()系统调用返回导致第四次上下文切换。当DMA引擎将数据<strong>从内核缓冲区传输到协议引擎缓冲区</strong>时，第四次拷贝是独立且异步的。（<strong>第四次上下文切换和拷贝</strong>）</li>
</ol>
<h3 id="23-2-NIO的零拷贝"><a href="#23-2-NIO的零拷贝" class="headerlink" title="23.2 NIO的零拷贝"></a>23.2 NIO的零拷贝</h3><p>NIO的零拷贝由transferTo方法实现。transferTo方法将数据从FileChannel对象传送到可写的字节通道（如Socket Channel等）。在transferTo方法内部实现中，由native方法transferTo0来实现，它依赖底层操作系统的支持。在UNIX和Linux系统中，调用这个方法会引起sendfile()系统调用，实现了数据直接从内核的读缓冲区传输到套接字缓冲区，避免了用户态(User-space) 与内核态(Kernel-space) 之间的数据拷贝。</p>
<img src="/2022/10/05/Java%E5%9F%BA%E7%A1%80/640-1663641836963.jfif" class="">

<p>使用NIO零拷贝，流程简化为两步：</p>
<ol>
<li>transferTo方法调用触发DMA引擎将文件上下文信息拷贝到内核读缓冲区，接着内核将数据从内核缓冲区拷贝到与套接字相关联的缓冲区。</li>
<li>DMA引擎将数据从内核套接字缓冲区传输到协议引擎（第三次数据拷贝）。</li>
</ol>
<p>相比传统IO，使用NIO零拷贝后改进的地方：</p>
<ol>
<li>将上下文切换次数从4次减少到了2次；</li>
<li>将数据拷贝次数从4次减少到了3次（其中只有1次涉及了CPU，另外2次是DMA直接存取）。</li>
</ol>
<h2 id="24-this和super的区别"><a href="#24-this和super的区别" class="headerlink" title="24.this和super的区别"></a>24.this和super的区别</h2><p>1、super()主要是对父类构造函数的调用，this()是对重载构造函数的调用<br>2、super()主要是在子类中调用父类的构造方法，在不同的类中使用；this()主要是在同一类中调用其他方法</p>
<p>3.this()和super()不能出现在同一个构造函数中</p>
<p>相同点：<br>1、super()和this()都必须在构造函数的第一行进行调用，否则就是错误的</p>
<p>2.this()和super()都指的是对象，不可以在static环境中使用，包括static变量、方法、代码块。</p>
<h2 id="25-Java8新特性"><a href="#25-Java8新特性" class="headerlink" title="25.Java8新特性"></a>25.Java8新特性</h2><h3 id="25-1-lambda表达式"><a href="#25-1-lambda表达式" class="headerlink" title="25.1 lambda表达式"></a>25.1 lambda表达式</h3><p>Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）</p>
<h3 id="25-2-函数式接口"><a href="#25-2-函数式接口" class="headerlink" title="25.2 函数式接口"></a>25.2 函数式接口</h3><p>指的是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口，这样的接口可以隐式转换为 Lambda 表达式</p>
<h3 id="25-3-方法引用"><a href="#25-3-方法引用" class="headerlink" title="25.3 方法引用"></a>25.3 方法引用</h3><p>可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用</p>
<h3 id="25-4-默认方法"><a href="#25-4-默认方法" class="headerlink" title="25.4 默认方法"></a>25.4 默认方法</h3><p>默认方法就是一个在接口里面有了一个实现的方法</p>
<h3 id="25-5-Stream-API"><a href="#25-5-Stream-API" class="headerlink" title="25.5 Stream API"></a>25.5 Stream API</h3><p>对数据集合进行操作。</p>
<p>注意点：</p>
<p>（1）Stream自己不会存储元素。</p>
<p>（2）Stream不会改变源对象。相反，他们会返回一个持有结果的新Stream。</p>
<p>（3）Stream操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</p>
<p>skip(n) ——跳过元素，返回一个扔掉了前 n 个元素的流。</p>
<p>distinct——筛选，去除重复</p>
<p>map-接收Lambda，将元素转换成其他形式或提取信息。接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</p>
<p>sorted()—自然排序（Comparable）</p>
<h3 id="25-6-Optional类"><a href="#25-6-Optional类" class="headerlink" title="25.6 Optional类"></a>25.6 Optional类</h3><p>Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。</p>
<h3 id="25-7-Date-TimeAPI"><a href="#25-7-Date-TimeAPI" class="headerlink" title="25.7 Date TimeAPI"></a>25.7 <strong>Date TimeAPI</strong></h3><p>加强对日期与时间的处理。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/" rel="tag">八股文</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-Java集合"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/10/05/Java%E9%9B%86%E5%90%88/"
    >Java集合</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/10/05/Java%E9%9B%86%E5%90%88/" class="article-date">
  <time datetime="2022-10-05T12:45:00.000Z" itemprop="datePublished">2022-10-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%85%AB%E8%82%A1%E6%96%87/">八股文</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="1-Java集合框架图"><a href="#1-Java集合框架图" class="headerlink" title="1.Java集合框架图"></a>1.Java集合框架图</h2><img src="/2022/10/05/Java%E9%9B%86%E5%90%88/Untitled2.png" class="" title="框架图"> 
      <a class="article-more-link" href="/2022/10/05/Java%E9%9B%86%E5%90%88/"
        >阅读更多...</a
      >
       
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/" rel="tag">八股文</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-java"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/10/05/java/"
    >java</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/10/05/java/" class="article-date">
  <time datetime="2022-10-05T08:26:49.000Z" itemprop="datePublished">2022-10-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/test/">test</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <img src="/2022/10/05/java/example.jpg" class="" title="This is an example image">

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-Java面经"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/10/05/Java%E9%9D%A2%E7%BB%8F/"
    >java</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/10/05/Java%E9%9D%A2%E7%BB%8F/" class="article-date">
  <time datetime="2022-10-05T08:26:49.000Z" itemprop="datePublished">2022-10-05</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>Java面经</p>
<h1 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h1><h2 id="1-为什么Java代码可以实现一次编写、到处运行？"><a href="#1-为什么Java代码可以实现一次编写、到处运行？" class="headerlink" title="1. 为什么Java代码可以实现一次编写、到处运行？"></a>1. 为什么Java代码可以实现一次编写、到处运行？</h2><p><strong>JVM</strong>。</p>
<p>在程序运行前，Java源代码（.java）需要经过编译器编译成字节码（.class）。在程序运行时，JVM负责将字节码翻译成特定平台下的机器码并运行，也就是说，只要在不同的平台上安装对应的JVM，就可以运行字节码文件。</p>
<p>同一份Java源代码在不同的平台上运行，它不需要做任何的改变，并且只需要编译一次。而编译好的字节码，是通过JVM这个中间的“桥梁”实现跨平台的，JVM是与平台相关的软件，它能将统一的字节码翻译成该平台的机器码。在程序运行前，Java源代码需要讲过编译成字节码(.class)。在程序运行时，JVM负责将字节码翻译成特定平台下的机器码并运行。</p> 
      <a class="article-more-link" href="/2022/10/05/Java%E9%9D%A2%E7%BB%8F/"
        >阅读更多...</a
      >
       
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-Hexo和Github搭建个人博客"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/10/05/Hexo%E5%92%8CGithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"
    >Hexo和Github搭建个人博客</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/10/05/Hexo%E5%92%8CGithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" class="article-date">
  <time datetime="2022-10-05T07:20:00.000Z" itemprop="datePublished">2022-10-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%8D%9A%E5%AE%A2/">博客</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <span id="more"></span>

<h2 id="1-安装环境"><a href="#1-安装环境" class="headerlink" title="1 安装环境"></a>1 安装环境</h2><h3 id="1-1-git"><a href="#1-1-git" class="headerlink" title="1.1 git"></a>1.1 git</h3><p>​	安装好以后，在任意地方鼠标右键可以看到：Git Bash Here，点击后打开了。输入：git –version，显示 版本信息，则安装成功。</p>
<h3 id="1-2-nodejs"><a href="#1-2-nodejs" class="headerlink" title="1.2 nodejs"></a>1.2 nodejs</h3><p>​	安装好之后，配置环境变量，并在终端里面输入：node -v，显示版本信息，说明安装成功。</p>
<h3 id="1-3-Hexo"><a href="#1-3-Hexo" class="headerlink" title="1.3 Hexo"></a>1.3 Hexo</h3><p>1.安装命令：npm install hexo -g</p>
<p>2.测试是否安装成功，命令：hexo -v</p>
<h3 id="1-4-安装hexo依赖"><a href="#1-4-安装hexo依赖" class="headerlink" title="1.4 安装hexo依赖"></a>1.4 安装hexo依赖</h3><p>​	命令：npm install <code>--</code>save hexo-deployer-git</p>
<h3 id="1-5-注册github"><a href="#1-5-注册github" class="headerlink" title="1.5 注册github"></a>1.5 注册github</h3><h3 id="1-6-git配置SSH-key"><a href="#1-6-git配置SSH-key" class="headerlink" title="1.6 git配置SSH key"></a>1.6 git配置SSH key</h3><p>​	可以免密的将本地的源码和资源上传到github，无需要每次都输账号和密码。</p>
<h2 id="2-Hexo"><a href="#2-Hexo" class="headerlink" title="2 Hexo"></a>2 Hexo</h2><h3 id="2-1-基本命令"><a href="#2-1-基本命令" class="headerlink" title="2.1 基本命令"></a>2.1 基本命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;postName&quot; #新建文章 </span><br><span class="line">hexo new page &quot;pageName&quot; #新建页面 </span><br><span class="line">hexo generate #生成静态页面至public目录 </span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server） </span><br><span class="line">hexo deploy #部署到GitHub </span><br><span class="line">hexo help  # 查看帮助 </span><br><span class="line">hexo version  #查看Hexo的版本</span><br></pre></td></tr></table></figure>

<p>​	可以用首字母代替指令，例如</p>
<p>​	hexo n &#x3D;&#x3D; hexo new</p>
<p>​	hexo g &#x3D;&#x3D; hexo generate</p>
<h3 id="2-2-新建一个保存博客的存放目录"><a href="#2-2-新建一个保存博客的存放目录" class="headerlink" title="2.2 新建一个保存博客的存放目录"></a>2.2 新建一个保存博客的存放目录</h3><p>1.进入到本地博客存放目录</p>
<p>2.初始化个人博客，命令：hexo init</p>
<h3 id="2-3-生成静态页面"><a href="#2-3-生成静态页面" class="headerlink" title="2.3 生成静态页面"></a>2.3 生成静态页面</h3><p>​	命令：hexo g</p>
<h3 id="2-4-预览，在本地运行"><a href="#2-4-预览，在本地运行" class="headerlink" title="2.4 预览，在本地运行"></a>2.4 预览，在本地运行</h3><p>​	命令：hexo s</p>
<p>​	在浏览器通过 <a target="_blank" rel="noopener" href="http://localhost:4000/">http://localhost:4000/</a> 访问</p>
<h2 id="3-自定义主题"><a href="#3-自定义主题" class="headerlink" title="3 自定义主题"></a>3 自定义主题</h2><h3 id="3-1-在网上找到喜欢的主题"><a href="#3-1-在网上找到喜欢的主题" class="headerlink" title="3.1 在网上找到喜欢的主题"></a>3.1 在网上找到喜欢的主题</h3><p>​	本人使用的是以下主题：</p>
<p>​	效果预览：<a target="_blank" rel="noopener" href="https://disq.us/url?url=https://shen-yu.gitee.io:7RjU0u30gp2dECnwc0UWpxOCJpY&cuid=2997290">https://shen-yu.gitee.io</a><br>​	GitHub地址：<a target="_blank" rel="noopener" href="https://disq.us/url?url=https://github.com/Shen-Yu/hexo-theme-ayer:4x_z81HEOuEqS0wquhdAviktmRM&cuid=2997290">https://github.com/Shen-Yu/hexo-theme-ayer</a></p>
<p>​	按照指示操作即可。具体操作如下：</p>
<h3 id="3-2-将仓库克隆到本地"><a href="#3-2-将仓库克隆到本地" class="headerlink" title="3.2 将仓库克隆到本地"></a>3.2 将仓库克隆到本地</h3><h3 id="3-3-将文件整个放入themes文件夹下"><a href="#3-3-将文件整个放入themes文件夹下" class="headerlink" title="3.3 将文件整个放入themes文件夹下"></a>3.3 将文件整个放入themes文件夹下</h3><p>​	修改文件hexo-theme-ayer名字为ayer</p>
<h3 id="3-4-修改配置文件"><a href="#3-4-修改配置文件" class="headerlink" title="3.4 修改配置文件"></a>3.4 修改配置文件</h3><p>​	在主项目的<code>_config.yml</code>中，将theme改为<code>theme: ayer</code></p>
<h3 id="3-5-根据需要修改ayer目录下的-config-yml配置文件"><a href="#3-5-根据需要修改ayer目录下的-config-yml配置文件" class="headerlink" title="3.5 根据需要修改ayer目录下的_config.yml配置文件"></a>3.5 根据需要修改ayer目录下的<code>_config.yml</code>配置文件</h3><h3 id="3-6-安装插件"><a href="#3-6-安装插件" class="headerlink" title="3.6 安装插件"></a>3.6 安装插件</h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://github.com/theme-next/hexo-generator-searchdb">hexo-generator-searchdb</a> 用于搜索</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>然后将以下配置复制到你博客根目录下的 <code>_config.yml</code> 里（注意不是 ayer 目录下的）:</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hexo-generator-searchdb</span></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo-generator-feed">hexo-generator-feed</a> 用于生成 RSS 订阅</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPYnpm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure>

<p>然后将以下配置复制到你博客根目录下的 <code>_config.yml</code> 里（注意不是 ayer 目录下的）:</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feed:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">atom</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">atom.xml</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">20</span></span><br><span class="line">  <span class="attr">hub:</span></span><br><span class="line">  <span class="attr">content:</span></span><br><span class="line">  <span class="attr">content_limit:</span> <span class="number">140</span></span><br><span class="line">  <span class="attr">content_limit_delim:</span> <span class="string">&quot; &quot;</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>其他插件可以自行决定是否下载：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/netcan/hexo-generator-index-pin-top">hexo-generator-index-pin-top</a> 用于文章置顶</li>
<li><a target="_blank" rel="noopener" href="https://github.com/MikeCoder/hexo-blog-encrypt/blob/master/ReadMe.zh.md">hexo-blog-encrypt</a> 用于文章加密</li>
</ul>
<h3 id="3-7-分类"><a href="#3-7-分类" class="headerlink" title="3.7 分类"></a>3.7 分类</h3><p>​	在主目录下创建，即在sources下生成新文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>

<p>​	然后将以下复制到 &#x2F;source&#x2F;categories&#x2F;index.md 文件</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">COPY---</span><br><span class="line">title: categories</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line"><span class="section">layout: &quot;categories&quot;</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>

<h3 id="3-8-标签"><a href="#3-8-标签" class="headerlink" title="3.8 标签"></a>3.8 标签</h3><p>​	在主目录下创建，即在sources下生成新文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>

<p>​	配置同分类一样</p>
<h3 id="3-9-友情链接"><a href="#3-9-友情链接" class="headerlink" title="3.9 友情链接"></a>3.9 友情链接</h3><p>​	在主目录下创建，即在sources下生成新文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page friends</span><br></pre></td></tr></table></figure>

<p>​	然后将以下复制到 &#x2F;source&#x2F;friends&#x2F;index.md 文件</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">COPY---</span><br><span class="line">title: friends</span><br><span class="line">type: friends</span><br><span class="line"><span class="section">layout: &quot;friends&quot;</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>

<p>​	然后在 ayer 主题目录下的 <code>_config.yml</code> 中自定义 <code>friends_link</code> 配置项即可</p>
<h2 id="4-写文章"><a href="#4-写文章" class="headerlink" title="4 写文章"></a>4 写文章</h2><h3 id="1-文章布局"><a href="#1-文章布局" class="headerlink" title="1 文章布局"></a>1 文章布局</h3><p>​	创建文章前要先选定模板，在hexo中也叫做布局。hexo支持三种布局（layout）：post(默认)、draft、page。</p>
<p>​	布局是一个markdown文件，它们保存在<code>scaffolds/</code>目录下，hexo自带的三种布局其实就是三个<code>.md</code>，可以修改。</p>
<h3 id="2-创建文章"><a href="#2-创建文章" class="headerlink" title="2 创建文章"></a>2 创建文章</h3><p>​	你可以在git界面中执行下列命令来创建一篇新文章或者新的页面。自动添加到对应位置，例如<code>hexo new java</code>，在<code>_posts</code>文件夹下创建<code>java.md</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>

<p>​	你 可以在命令中指定文章的布局（layout），默认为 <code>post</code>，可以通过修改 <code>_config.yml</code> 中的 <code>default_layout</code> 参数来指定默认布局。</p>
<p><strong>提示</strong>：在文章头文件中添加标签和类别</p>
<h3 id="3-管理文章中图片资源"><a href="#3-管理文章中图片资源" class="headerlink" title="3 管理文章中图片资源"></a>3 管理文章中图片资源</h3><p>​	Hexo也提供了组织化的方式来管理资源，通过将 <code>config.yml</code> 文件中的 <code>post_asset_folder</code> 选项设为 <code>true</code> 来打开。</p>
<p>​	当资源文件管理功能打开后，Hexo将会在你每一次通过 <code>hexo new [layout] </code> 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。将所有与文章有关的资源放在这个关联文件夹中之后，可以通过相对路径来引用它们。</p>
<p>​	引用格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_path slug %&#125;</span><br><span class="line">&#123;% asset_img slug [title] %&#125;</span><br><span class="line">&#123;% asset_link slug [title] %&#125;</span><br></pre></td></tr></table></figure>

<p>​	比如说：当你打开文章资源文件夹功能后，你把一个 <code>example.jpg</code> 图片放在了你的资源文件夹中，引用方式如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img example.jpg This is an example image %&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-文章截断"><a href="#4-文章截断" class="headerlink" title="4 文章截断"></a>4 文章截断</h3><p>​	在文章中使用<code>&lt; !--more--&gt;</code> 手动进行截断，这种方法可以根据文章的内容，自己在合适的位置添加 <code>&lt; !--more--&gt;</code> 标签，使用灵活，也是Hexo推荐的方法。</p>
<h2 id="5-部署到github"><a href="#5-部署到github" class="headerlink" title="5 部署到github"></a>5 部署到github</h2><h3 id="5-1-新建一个github仓库"><a href="#5-1-新建一个github仓库" class="headerlink" title="5.1 新建一个github仓库"></a>5.1 新建一个github仓库</h3><p>仓库命名为<code>用户名.github.io</code></p>
<h3 id="5-2-编辑config-yml，config-yml在博客存放根目录下"><a href="#5-2-编辑config-yml，config-yml在博客存放根目录下" class="headerlink" title="5.2 编辑config.yml，config.yml在博客存放根目录下"></a>5.2 编辑<code>config.yml</code>，<code>config.yml</code>在博客存放根目录下</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">github.com:用户名/用户名.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>

<p>repository仓库地址改为自己的</p>
<p>branch看自己的github仓库是master还是main</p>
<h3 id="5-3-发布到github"><a href="#5-3-发布到github" class="headerlink" title="5.3 发布到github"></a>5.3 发布到github</h3><p>命令：hexo d</p>
<h3 id="5-4-在浏览器访问"><a href="#5-4-在浏览器访问" class="headerlink" title="5.4 在浏览器访问"></a>5.4 在浏览器访问</h3><p>https:&#x2F;&#x2F;用户名.github.io&#x2F;（提交会有延迟）</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%9A%E5%AE%A2/" rel="tag">博客</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-hello-world"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/10/05/hello-world/"
    >Hello World</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/10/05/hello-world/" class="article-date">
  <time datetime="2022-10-05T02:43:05.829Z" itemprop="datePublished">2022-10-05</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="雷吼哇"><a href="#雷吼哇" class="headerlink" title="雷吼哇~"></a>雷吼哇~</h2> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
  </article>
  

  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022
        <i class="ri-heart-fill heart_icon"></i> pp-lv
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.png" alt="LPL&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">Categories</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">Tags</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">About</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i></p>
  <div class="reward-box">
    
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>